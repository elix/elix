{"version":3,"sources":["webpack:///webpack/bootstrap 9172c801b3cf8f4404ab","webpack:///./elements/elix-all/globals.js","webpack:///./elements/elix-simple-element/globals.js","webpack:///./elements/elix-simple-element/src/SimpleElement.js","webpack:///./elements/elix-mixins/src/SimpleAttributeMixin.js","webpack:///./elements/elix-mixins/src/SimpleTemplateMixin.js","webpack:///./elements/elix-mixins/globals.js","webpack:///./elements/elix-mixins/src/microtask.js","webpack:///./elements/elix-mixins/src/SingleSelectionMixin.js","webpack:///./elements/elix-mixins/src/createSymbol.js","webpack:///./elements/elix-mixins/src/CustomEvent.js","webpack:///./elements/elix-mixins/src/symbols.js"],"names":["simpleElement","componentMixins","webComponents","window","Elix","SimpleElement","shadowRoot","getElementById","textContent","value","HTMLElement","customElements","define","SimpleAttributeMixin","base","SimpleAttribute","attributeName","oldValue","newValue","prototype","attribute","SimpleTemplateMixin","SimpleTemplate","template","root","attachShadow","mode","innerHTML","className","microtask","SingleSelectionMixin","symbols","callbacks","element","document","createTextNode","counter","callback","push","executeCallbacks","length","shift","observer","MutationObserver","observe","characterData","canSelectNextSymbol","canSelectPreviousSymbol","selectionRequiredSymbol","selectionWrapsSymbol","externalSelectedIndexSymbol","externalSelectedItemSymbol","internalSelectedIndexSymbol","internalSelectedItemSymbol","SingleSelection","selectionRequired","defaults","selectionWraps","itemAdded","item","itemSelected","selectedItem","itemsChanged","trackSelectedItem","updatePossibleNavigations","selected","selectIndex","items","selectedIndex","newIndex","canSelectNext","changed","raiseChangeEvents","dispatchEvent","canSelectPrevious","index","parsedIndex","parseInt","hasItems","event","detail","previousSelectedItem","Array","indexOf","call","String","count","boundedIndex","Math","max","min","previousIndex","itemCount","indexInCurrentItems","previousSelectedIndex","newSelectedIndex","createSymbol","description","Symbol","customEventConstructor","customEventPolyfill","eventName","params","bubbles","cancelable","undefined","createEvent","initCustomEvent","originalPreventDefault","preventDefault","Object","defineProperty","get","e","defaultPrevented","setPrototypeOf","Event","CustomEvent"],"mappings":"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","file":"elix-all.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 9172c801b3cf8f4404ab","/*\n * This file is transpiled to create an ES5-compatible distribution of all\n * components in the project. If you're already using ES6 yourself, ignore this\n * file, and instead import the source file(s) you want from the specific\n * package you want.\n */\n\n// Import all the globals from each package.\n// We tell jshint to ignore the fact that we're not actually using them here.\n/* jshint ignore:start */\n\nimport * as simpleElement from '../elix-simple-element/globals';\nimport * as componentMixins from '../elix-mixins/globals';\nimport * as webComponents from '../elix-all/globals';\n\n/* jshint ignore:end */\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-all/globals.js","/*\n * This file is transpiled to create an ES5-compatible distribution in which\n * the package's main feature(s) are available via the window.Elix global.\n * If you're already using ES6 yourself, ignore this file, and instead import\n * the source file(s) you want from the src folder.\n */\n\nimport SimpleElement from './src/SimpleElement';\n\nwindow.Elix = window.Elix || {};\nwindow.Elix.SimpleElement = SimpleElement;\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-simple-element/globals.js","import SimpleAttributeMixin from '../../elix-mixins/src/SimpleAttributeMixin';\nimport SimpleTemplateMixin from '../../elix-mixins/src/SimpleTemplateMixin';\n\n\n/**\n * A simple element used to demonstrate the build and documentation process.\n *\n * [Live demo](http://elix.org/elix/elements/elix-simple-element/)\n *\n * @module SimpleElement\n * @mixes SimpleAttributeMixin\n * @mixes SimpleTemplateMixin\n */\nclass SimpleElement extends SimpleTemplateMixin(SimpleAttributeMixin(HTMLElement)) {\n\n  /**\n   * Specifies the greeting.\n   *\n   * @type {string}\n   * @default greeting\n   */\n  get greeting() {\n    return this.shadowRoot.getElementById('greeting').textContent;\n  }\n  set greeting(value) {\n    this.shadowRoot.getElementById('greeting').textContent = value;\n  }\n\n  static get observedAttributes() {\n    return ['greeting'];\n  }\n\n  get template() {\n    return `<span id=\"greeting\">Hello</span>, <slot></slot>.`;\n  }\n}\n\ncustomElements.define('elix-simple-element', SimpleElement);\nexport default SimpleElement;\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-simple-element/src/SimpleElement.js","/**\n * Mixin which adds simplistic mapping of attributes to properties.\n *\n * @module SimpleAttributeMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function SimpleAttributeMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class SimpleAttribute extends base {\n    \n    /*\n     * Handle a change to the attribute with the given name.\n     */\n    attributeChangedCallback(attributeName, oldValue, newValue) {\n  \t  if (super.attributeChangedCallback) { super.attributeChangedCallback(); }\n  \t  // If the attribute name corresponds to a property name, set the property.\n  \t  // Ignore standard HTMLElement properties handled by the DOM.\n  \t  if (attributeName in this && !(attributeName in HTMLElement.prototype)) {\n          this[attributeName] = newValue;\n  \t  }\n    }\n\n    /**\n     * Set/unset the attribute with the indicated name.\n     *\n     * This method exists primarily to handle the case where an element wants to\n     * set a default property value that should be reflected as an attribute. An\n     * important limitation of custom element consturctors is that they cannot\n     * set attributes. A call to `reflectAttribute` during the constructor will\n     * be deferred until the element is connected to the document.\n     *\n     * @param {string} attribute - The name of the *attribute* (not property) to set.\n     * @param {object} value - The value to set. If null, the attribute will be removed.\n     */\n    reflectAttribute(attribute, value) {\n      // For documentation purposes only\n    }\n\n  }\n\n  return SimpleAttribute;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/SimpleAttributeMixin.js","/**\n * Mixin which adds a simplistic means of cloning a string template into a new\n * shadow root.\n *\n * @module SimpleTemplateMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function SimpleTemplateMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class SimpleTemplate extends base {\n\n    constructor() {\n\t    super();\n\t    const template = this.template;\n\t    if (template) {\n        const root = this.attachShadow({ mode: 'open' });\n        root.innerHTML = template;\n\t    }\n    }\n\n    /**\n     * Set/unset the class with the indicated name.\n     *\n     * This method exists primarily to handle the case where an element wants to\n     * set a default property value that should be reflected as as class. An\n     * important limitation of custom element consturctors is that they cannot\n     * set attributes, including the `class` attribute. A call to\n     * `reflectClass` during the constructor will be deferred until the element\n     * is connected to the document.\n     *\n     * @param {string} className - The name of the class to set.\n     * @param {object} value - True to set the class, false to remove it.\n     */\n    reflectClass(className, value) {\n      // For documentation purposes only\n    }\n\n  }\n\n  return SimpleTemplate;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/SimpleTemplateMixin.js","/*\n * This file is transpiled to create an ES5-compatible distribution in which\n * the package's main feature(s) are available via the window.Basic global.\n * If you're already using ES6 yourself, ignore this file, and instead import\n * the source file(s) you want from the src folder.\n */\n\nimport microtask from './src/microtask';\nimport SimpleAttributeMixin from './src/SimpleAttributeMixin';\nimport SimpleTemplateMixin from './src/SimpleTemplateMixin';\nimport SingleSelectionMixin from './src/SingleSelectionMixin';\nimport symbols from './src/symbols';\n\nwindow.Elix = window.Elix || {};\n\nwindow.Elix.microtask = microtask;\nwindow.Elix.SimpleAttributeMixin = SimpleAttributeMixin;\nwindow.Elix.SimpleTemplateMixin = SimpleTemplateMixin;\nwindow.Elix.SingleSelectionMixin = SingleSelectionMixin;\nwindow.Elix.symbols = symbols;\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/globals.js","/*\n * Microtask helper for IE 11.\n *\n * Executing a function as a microtask is trivial in browsers that support\n * promises, whose then() clauses use microtask timing. IE 11 doesn't support\n * promises, but does support MutationObservers, which are also executed as\n * microtasks. So this helper uses an MutationObserver to achieve microtask\n * timing.\n *\n * See https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n *\n * Inspired by Polymer's async() function.\n */\n\n\n// The queue of pending callbacks to be executed as microtasks.\nconst callbacks = [];\n\n// Create an element that we will modify to force observable mutations.\nconst element = document.createTextNode('');\n\n// A monotonically-increasing value.\nlet counter = 0;\n\n\n/**\n * Add a callback to the microtask queue.\n *\n * This uses a MutationObserver so that it works on IE 11.\n *\n * NOTE: IE 11 may actually use timeout timing with MutationObservers. This\n * needs more investigation.\n *\n * @function microtask\n * @param {function} callback\n */\nexport default function microtask(callback) {\n  callbacks.push(callback);\n  // Force a mutation.\n  element.textContent = ++counter;\n}\n\n\n// Execute any pending callbacks.\nfunction executeCallbacks() {\n  while (callbacks.length > 0) {\n    const callback = callbacks.shift();\n    callback();\n  }\n}\n\n\n// Create the observer.\nconst observer = new MutationObserver(executeCallbacks);\nobserver.observe(element, {\n  characterData: true\n});\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/microtask.js","import createSymbol from './createSymbol';\nimport CustomEvent from './CustomEvent';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst canSelectNextSymbol = createSymbol('canSelectNext');\nconst canSelectPreviousSymbol = createSymbol('canSelectPrevious');\nconst selectionRequiredSymbol = createSymbol('selectionRequired');\nconst selectionWrapsSymbol = createSymbol('selectionWraps');\n\n// We want to expose both selectedIndex and selectedItem as independent\n// properties but keep them in sync. This allows a component user to reference\n// the selection by whatever means is most natural for their situation.\n//\n// To efficiently keep these properties in sync, we track \"external\" and\n// \"internal\" references for each property:\n//\n// The external index or item is the one we report to the outside world when\n// asked for selection.  When handling a change to index or item, we update the\n// external reference as soon as possible, so that if anyone immediately asks\n// for the current selection, they will receive a stable answer.\n//\n// The internal index or item tracks whichever index or item last received the\n// full set of processing. Processing includes raising a change event for the\n// new value. Once we've begun that processing, we store the new value as the\n// internal value to indicate we've handled it.\n//\nconst externalSelectedIndexSymbol = createSymbol('externalSelectedIndex');\nconst externalSelectedItemSymbol = createSymbol('externalSelectedItem');\nconst internalSelectedIndexSymbol = createSymbol('internalSelectedIndex');\nconst internalSelectedItemSymbol = createSymbol('internalSelectedItem');\n\n\n/**\n * Mixin which adds single-selection semantics for items in a list.\n *\n * This mixin expects a component to provide an `items` Array or NodeList of\n * all elements in the list.\n *\n * This mixin tracks a single selected item in the list, and provides means to\n * get and set that state by item position (`selectedIndex`) or item identity\n * (`selectedItem`). The selection can be moved in the list via the methods\n * `selectFirst`, `selectLast`, `selectNext`, and `selectPrevious`.\n *\n * This mixin does not produce any user-visible effects to represent\n * selection.\n *\n * @module SingleSelectionMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function SingleSelectionMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class SingleSelection extends base {\n\n    constructor() {\n      super();\n      // Set defaults.\n      if (typeof this.selectionRequired === 'undefined') {\n        this.selectionRequired = this[symbols.defaults].selectionRequired;\n      }\n      if (typeof this.selectionWraps === 'undefined') {\n        this.selectionWraps = this[symbols.defaults].selectionWraps;\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the next item, false if not (the\n     * selected item is the last item in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectNext() {\n      return this[canSelectNextSymbol];\n    }\n    set canSelectNext(canSelectNext) {\n      const changed = canSelectNext !== this[canSelectNextSymbol];\n      this[canSelectNextSymbol] = canSelectNext;\n      if ('canSelectNext' in base.prototype) { super.canSelectNext = canSelectNext; }\n      if (this[symbols.raiseChangeEvents] && changed) {\n        this.dispatchEvent(new CustomEvent('can-select-next-changed'));\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the previous item, false if not\n     * (the selected item is the first one in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectPrevious() {\n      return this[canSelectPreviousSymbol];\n    }\n    set canSelectPrevious(canSelectPrevious) {\n      const changed = canSelectPrevious !== this[canSelectPreviousSymbol];\n      this[canSelectPreviousSymbol] = canSelectPrevious;\n      if ('canSelectPrevious' in base.prototype) { super.canSelectPrevious = canSelectPrevious; }\n      if (this[symbols.raiseChangeEvents] && changed) {\n        this.dispatchEvent(new CustomEvent('can-select-previous-changed'));\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.selectionRequired = false;\n      defaults.selectionWraps = false;\n      return defaults;\n    }\n\n    /**\n     * Handle a new item being added to the list.\n     *\n     * The default implementation of this method simply sets the item's\n     * selection state to false.\n     *\n     * @param {HTMLElement} item - the item being added\n     */\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n      this[symbols.itemSelected](item, item === this.selectedItem);\n    }\n\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      // In case selected item changed position or was removed.\n      trackSelectedItem(this);\n\n      // In case the change in items affected which navigations are possible.\n      updatePossibleNavigations(this);\n    }\n\n    /**\n     * Apply the indicate selection state to the item.\n     *\n     * The default implementation of this method does nothing. User-visible\n     * effects will typically be handled by other mixins.\n     *\n     * @param {HTMLElement} item - the item being selected/deselected\n     * @param {boolean} selected - true if the item is selected, false if not\n     */\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    }\n\n    /**\n     * The index of the item which is currently selected.\n     *\n     * The setter expects an integer or a string representing an integer.\n     *\n     * A `selectedIndex` of -1 indicates there is no selection. Setting this\n     * property to -1 will remove any existing selection.\n     *\n     * @type {number}\n     */\n    get selectedIndex() {\n      return this[externalSelectedIndexSymbol] != null ?\n        this[externalSelectedIndexSymbol] :\n        -1;\n    }\n    set selectedIndex(index) {\n      // See notes at top about internal vs. external copies of this property.\n      const changed = index !== this[internalSelectedIndexSymbol];\n      let item;\n      let parsedIndex = parseInt(index);\n      if (parsedIndex !== this[externalSelectedIndexSymbol]) {\n        // Store the new index and the corresponding item.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        if (!(hasItems && parsedIndex >= 0 && parsedIndex < items.length)) {\n          parsedIndex = -1; // No item at that index.\n        }\n        this[externalSelectedIndexSymbol] = parsedIndex;\n        item = hasItems && parsedIndex >= 0 ? items[parsedIndex] : null;\n        this[externalSelectedItemSymbol] = item;\n      } else {\n        item = this[externalSelectedItemSymbol];\n      }\n\n      // Now let super do any work.\n      if ('selectedIndex' in base.prototype) { super.selectedIndex = index; }\n\n      if (changed) {\n        // The selected index changed.\n        this[internalSelectedIndexSymbol] = parsedIndex;\n\n        if (this[symbols.raiseChangeEvents]) {\n          const event = new CustomEvent('selected-index-changed', {\n            detail: {\n              selectedIndex: parsedIndex,\n              value: parsedIndex // for Polymer binding. TODO: Verify still necessary\n            }\n          });\n          this.dispatchEvent(event);\n        }\n      }\n\n      if (this[internalSelectedItemSymbol] !== item) {\n        // Update selectedItem property so it can have its own effects.\n        this.selectedItem = item;\n      }\n    }\n\n    /**\n     * The currently selected item, or null if there is no selection.\n     *\n     * Setting this property to null deselects any currently-selected item.\n     * Setting this property to an object that is not in the list has no effect.\n     *\n     * TODO: Even if selectionRequired, can still explicitly set selectedItem to null.\n     * TODO: If selectionRequired, leave selection alone?\n     *\n     * @type {object}\n     */\n    get selectedItem() {\n      return this[externalSelectedItemSymbol] || null;\n    }\n    set selectedItem(item) {\n      // See notes at top about internal vs. external copies of this property.\n      const previousSelectedItem = this[internalSelectedItemSymbol];\n      const changed = item !== previousSelectedItem;\n      let index;\n      if (item !== this[externalSelectedItemSymbol]) {\n        // Store item and look up corresponding index.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        index = hasItems ? Array.prototype.indexOf.call(items, item) : -1;\n        this[externalSelectedIndexSymbol] = index;\n        if (index < 0) {\n          item = null; // The indicated item isn't actually in `items`.\n        }\n        this[externalSelectedItemSymbol] = item;\n      } else {\n        index = this[externalSelectedIndexSymbol];\n      }\n\n      // Now let super do any work.\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n\n      if (changed) {\n        // The selected item changed.\n        this[internalSelectedItemSymbol] = item;\n\n        if (previousSelectedItem) {\n          // Update selection state of old item.\n          this[symbols.itemSelected](previousSelectedItem, false);\n        }\n        if (item) {\n          // Update selection state to new item.\n          this[symbols.itemSelected](item, true);\n        }\n\n        updatePossibleNavigations(this);\n\n        if (this[symbols.raiseChangeEvents]) {\n          const event = new CustomEvent('selected-item-changed', {\n            detail: {\n              selectedItem: item,\n              value: item // for Polymer binding\n            }\n          });\n          this.dispatchEvent(event);\n        }\n      }\n\n      if (this[internalSelectedIndexSymbol] !== index) {\n        // Update selectedIndex property so it can have its own effects.\n        this.selectedIndex = index;\n      }\n    }\n\n    /**\n     * Select the first item in the list.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectFirst() {\n      if (super.selectFirst) { super.selectFirst(); }\n      return selectIndex(this, 0);\n    }\n\n    /**\n     * True if the list should always have a selection (if it has items).\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionRequired() {\n      return this[selectionRequiredSymbol];\n    }\n    set selectionRequired(selectionRequired) {\n      this[selectionRequiredSymbol] = selectionRequired;\n      if ('selectionRequired' in base.prototype) { super.selectionRequired = selectionRequired; }\n      trackSelectedItem(this);\n    }\n\n    /**\n     * True if selection navigations wrap from last to first, and vice versa.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionWraps() {\n      return this[selectionWrapsSymbol];\n    }\n    set selectionWraps(value) {\n      this[selectionWrapsSymbol] = String(value) === 'true';\n      if ('selectionWraps' in base.prototype) { super.selectionWraps = value; }\n      updatePossibleNavigations(this);\n    }\n\n    /**\n     * Select the last item in the list.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectLast() {\n      if (super.selectLast) { super.selectLast(); }\n      return selectIndex(this, this.items.length - 1);\n    }\n\n    /**\n     * Select the next item in the list.\n     *\n     * If the list has no selection, the first item will be selected.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectNext() {\n      if (super.selectNext) { super.selectNext(); }\n      return selectIndex(this, this.selectedIndex + 1);\n    }\n\n    /**\n     * Select the previous item in the list.\n     *\n     * If the list has no selection, the last item will be selected.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectPrevious() {\n      if (super.selectPrevious) { super.selectPrevious(); }\n      const newIndex = this.selectedIndex < 0 ?\n        this.items.length - 1 :     // No selection yet; select last item.\n        this.selectedIndex - 1;\n      return selectIndex(this, newIndex);\n    }\n\n    /**\n     * Fires when the canSelectNext property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event can-select-next-changed\n     */\n\n    /**\n     * Fires when the canSelectPrevious property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event can-select-previous-changed\n     */\n\n    /**\n     * Fires when the selectedIndex property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event selected-index-changed\n     * @param {number} detail.selectedIndex The new selected index.\n     */\n\n    /**\n     * Fires when the selectedItem property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event selected-item-changed\n     * @param {HTMLElement} detail.selectedItem The new selected item.\n     */\n\n  }\n\n  return SingleSelection;\n}\n\n\n// Ensure the given index is within bounds, and select it if it's not already\n// selected.\nfunction selectIndex(element, index) {\n\n  const items = element.items;\n  if (items == null) {\n    // Nothing to select.\n    return false;\n  }\n\n  const count = items.length;\n  const boundedIndex = element.selectionWraps ?\n    // JavaScript mod doesn't handle negative numbers the way we want to wrap.\n    // See http://stackoverflow.com/a/18618250/76472\n    ((index % count) + count) % count :\n\n    // Keep index within bounds of array.\n    Math.max(Math.min(index, count - 1), 0);\n\n  const previousIndex = element.selectedIndex;\n  if (previousIndex !== boundedIndex) {\n    element.selectedIndex = boundedIndex;\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// Following a change in the set of items, or in the value of the\n// `selectionRequired` property, reacquire the selected item. If it's moved,\n// update `selectedIndex`. If it's been removed, and a selection is required,\n// try to select another item.\nfunction trackSelectedItem(element) {\n\n  const items = element.items;\n  const itemCount = items ? items.length : 0;\n\n  const previousSelectedItem = element.selectedItem;\n  if (!previousSelectedItem) {\n    // No item was previously selected.\n    if (element.selectionRequired) {\n      // Select the first item by default.\n      element.selectedIndex = 0;\n    }\n  } else if (itemCount === 0) {\n    // We've lost the selection, and there's nothing left to select.\n    element.selectedItem = null;\n  } else {\n    // Try to find the previously-selected item in the current set of items.\n    const indexInCurrentItems = Array.prototype.indexOf.call(items, previousSelectedItem);\n    const previousSelectedIndex = element.selectedIndex;\n    if (indexInCurrentItems < 0) {\n      // Previously-selected item was removed from the items.\n      // Select the item at the same index (if it exists) or as close as possible.\n      const newSelectedIndex = Math.min(previousSelectedIndex, itemCount - 1);\n      // Select by item, since index may be the same, and we want to raise the\n      // selected-item-changed event.\n      element.selectedItem = items[newSelectedIndex];\n    } else if (indexInCurrentItems !== previousSelectedIndex) {\n      // Previously-selected item still there, but changed position.\n      element.selectedIndex = indexInCurrentItems;\n    }\n  }\n}\n\n// Following a change in selection, report whether it's now possible to\n// go next/previous from the given index.\nfunction updatePossibleNavigations(element) {\n  let canSelectNext;\n  let canSelectPrevious;\n  const items = element.items;\n  if (items == null || items.length === 0) {\n    // No items to select.\n    canSelectNext = false;\n    canSelectPrevious = false;\n  } else if (element.selectionWraps) {\n    // Since there are items, can always go next/previous.\n    canSelectNext = true;\n    canSelectPrevious = true;\n  } else {\n    const index = element.selectedIndex;\n    if (index < 0 && items.length > 0) {\n      // Special case. If there are items but no selection, declare that it's\n      // always possible to go next/previous to create a selection.\n      canSelectNext = true;\n      canSelectPrevious = true;\n    } else {\n      // Normal case: we have an index in a list that has items.\n      canSelectPrevious = (index > 0);\n      canSelectNext = (index < items.length - 1);\n    }\n  }\n  if (element.canSelectNext !== canSelectNext) {\n    element.canSelectNext = canSelectNext;\n  }\n  if (element.canSelectPrevious !== canSelectPrevious) {\n    element.canSelectPrevious = canSelectPrevious;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/SingleSelectionMixin.js","/**\n * Helper function to create a symbol that can be used for associating private\n * data with an element.\n *\n * Mixins and component classes often want to associate private data with an\n * element instance, but JavaScript does not have direct support for true\n * private properties. One approach is to use the\n * [Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)\n * data type to set and retrieve data on an element.\n *\n * Unfortunately, the Symbol type is not available in Internet Explorer 11. The\n * `createSymbol` helper function exists as a workaround for IE 11. Rather than\n * returning a true Symbol, it simply returns an underscore-prefixed string.\n *\n * Usage:\n *\n *     const fooSymbol = createSymbol('foo');\n *\n *     class MyElement extends HTMLElement {\n *       get foo() {\n *         return this[fooSymbol];\n *       }\n *       set foo(value) {\n *         this[fooSymbol] = value;\n *       }\n *     }\n *\n * In IE 11, this sample will \"hide\" data behind an instance property this._foo.\n * The use of the underscore is meant to reduce (not eliminate) the potential\n * for name conflicts, and discourage (not prevent) external access to this\n * data. In modern browsers, the above code will eliminate the potential of\n * naming conflicts, and better hide the data behind a real Symbol.\n *\n * @function createSymbol\n * @param {string} description - A string to identify the symbol when debugging\n */\nexport default function createSymbol(description) {\n  return typeof Symbol === 'function' ?\n    Symbol(description) :\n    `_${description}`;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/createSymbol.js","/*\n * Polyfill for creating CustomEvents for IE 11.\n * Inspired by https://github.com/krambuhl/custom-event-polyfill.\n */\n\nlet customEventConstructor;\n\nfunction customEventPolyfill(eventName, params) {\n  params = params || {\n    bubbles: false,\n    cancelable: false,\n    detail: undefined\n  };\n  const event = document.createEvent(\"CustomEvent\");\n  event.initCustomEvent(eventName, params.bubbles, params.cancelable, params.detail);\n  const originalPreventDefault = event.preventDefault;\n  event.preventDefault = function() {\n    originalPreventDefault.call(this);\n    try {\n      Object.defineProperty(this, 'defaultPrevented', {\n        get: function () {\n          return true;\n        }\n      });\n    } catch(e) {\n      this.defaultPrevented = true;\n    }\n  };\n\n  return event;\n}\nObject.setPrototypeOf(customEventPolyfill, window.Event.prototype);\n\ntry {\n  new window.CustomEvent('test');\n  customEventConstructor = window.CustomEvent;\n} catch(e) {\n  customEventConstructor = customEventPolyfill;\n}\n\nexport default customEventConstructor;\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/CustomEvent.js","import createSymbol from './createSymbol';\n\n/**\n * A collection of Symbol objects for standard component properties and methods.\n *\n * These Symbol objects are used to allow mixins and a component to internally\n * communicate, without exposing these properties and methods in the component's\n * public API.\n *\n * To use these Symbol objects in your own component, include this module and\n * then create a property or method whose key is the desired Symbol.\n *\n *     import 'SingleSelectionMixin' from 'elix-mixins/src/SingleSelectionMixin';\n *     import 'symbols' from 'elix-mixins/src/symbols';\n *\n *     class MyElement extends SingleSelectionMixin(HTMLElement) {\n *       [symbols.itemSelected](item, selected) {\n *         // This will be invoked whenever an item is selected/deselected.\n *       }\n *     }\n *\n * @module symbols\n */\nconst symbols = {\n\n  /**\n   * Symbol for the `defaults` property.\n   *\n   * This property can be used to set or override defaults that will be applied\n   * to a new component instance. When implementing this property, take care to\n   * first acquire any defaults defined by the superclass. The standard idiom is\n   * as follows:\n   *\n   *     get [symbols.defaults]() {\n   *       const defaults = super[symbols.defaults] || {};\n   *       // Set or override default values here\n   *       defaults.customProperty = false;\n   *       return defaults;\n   *     }\n   *\n   * @var {object} defaults\n   */\n  defaults: createSymbol('defaults'),\n\n  /**\n   * Symbol for the `raiseChangeEvents` property.\n   *\n   * This property is used by mixins to determine whether they should raise\n   * property change events. The standard HTML pattern is to only raise such\n   * events in response to direct user interactions. For a detailed discussion\n   * of this point, see the Gold Standard checklist item for\n   * [Propery Change Events](https://github.com/webcomponents/gold-standard/wiki/Property%20Change%20Events).\n   *\n   * The above article describes a pattern for using a flag to track whether\n   * work is being performed in response to internal component activity, and\n   * whether the component should therefore raise property change events.\n   * This `raiseChangeEvents` symbol is a shared flag used for that purpose by\n   * all Elix mixins and components. Sharing this flag ensures that internal\n   * activity (e.g., a UI event listener) in one mixin can signal other mixins\n   * handling affected properties to raise change events.\n   *\n   * All UI event listeners (and other forms of internal handlers, such as\n   * timeouts and async network handlers) should set `raiseChangeEvents` to\n   * `true` at the start of the event handler, then `false` at the end:\n   *\n   *     this.addEventListener('click', event => {\n   *       this[symbols.raiseChangeEvents] = true;\n   *       // Do work here, possibly setting properties, like:\n   *       this.foo = 'Hello';\n   *       this[symbols.raiseChangeEvents] = false;\n   *     });\n   *\n   * Elsewhere, property setters that raise change events should only do so it\n   * this property is `true`:\n   *\n   *     set foo(value) {\n   *       // Save foo value here, do any other work.\n   *       if (this[symbols.raiseChangeEvents]) {\n   *         const event = new CustomEvent('foo-changed');\n   *         this.dispatchEvent(event);\n   *       }\n   *     }\n   *\n   * In this way, programmatic attempts to set the `foo` property will not\n   * trigger the `foo-changed` event, but UI interactions that update that\n   * property will cause those events to be raised.\n   *\n   * @var {boolean} raiseChangeEvents\n   */\n  raiseChangeEvents: createSymbol('raiseChangeEvents'),\n\n  /**\n   * Symbol for the `itemAdded` method.\n   *\n   * This method is invoked when a new item is added to a list.\n   *\n   * @function itemAdded\n   * @param {HTMLElement} item - the item being selected/deselected\n   */\n  itemAdded: createSymbol('itemAdded'),\n\n  /**\n   * Symbol for the `itemsChanged` method.\n   *\n   * This method is invoked when the underlying contents change. It is also\n   * invoked on component initialization â€“ since the items have \"changed\" from\n   * being nothing.\n   *\n   * @function itemsChanged\n   */\n  itemsChanged: createSymbol('itemsChanged'),\n\n  /**\n   * Symbol for the `itemSelected` method.\n   *\n   * This method is invoked when an item becomes selected or deselected.\n   *\n   * @function itemSelected\n   * @param {HTMLElement} item - the item being selected/deselected\n   * @param {boolean} selected - true if the item is selected, false if not\n   */\n  itemSelected: createSymbol('itemSelected')\n\n};\n\nexport default symbols;\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/symbols.js"],"sourceRoot":""}