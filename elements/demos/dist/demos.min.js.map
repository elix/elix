{"version":3,"sources":["webpack:///demos.min.js","webpack:///webpack/bootstrap 4d6ffcd0cb8944024b16","webpack:///./elements/demos/src/ListBox.js","webpack:///./elements/elix-mixins/src/ClickSelectionMixin.js","webpack:///./elements/elix-mixins/src/symbols.js","webpack:///./elements/elix-mixins/src/Symbol.js","webpack:///./elements/elix-mixins/src/SelectionAriaMixin.js","webpack:///./elements/elix-mixins/src/ShadowTemplateMixin.js","webpack:///./elements/elix-mixins/src/SingleSelectionMixin.js","webpack:///./elements/demos/src/SingleSelectionDemo.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","defineProperty","_createClass","defineProperties","target","props","i","length","descriptor","key","protoProps","staticProps","_get","get","object","property","receiver","Function","desc","getOwnPropertyDescriptor","undefined","parent","getPrototypeOf","getter","_ClickSelectionMixin","_ClickSelectionMixin2","_SelectionAriaMixin","_SelectionAriaMixin2","_ShadowTemplateMixin","_ShadowTemplateMixin2","_SingleSelectionMixin","_SingleSelectionMixin2","_symbols","_symbols2","mixins","base","reduce","cls","mixin","HTMLElement","ListBox","_base","this","_this","addEventListener","event","raiseChangeEvents","handled","keyCode","selectPrevious","selectNext","preventDefault","stopPropagation","setTimeout","itemsChanged","attributeName","oldValue","newValue","selectedIndex","parseInt","getAttribute","defaults","tabindex","setAttribute","itemSelected","item","selected","classList","toggle","_this2","Array","forEach","items","child","itemAdded","children","template","customElements","define","ClickSelectionMixin","ClickSelection","path","itemForTarget","selectionRequired","selectedItem","console","warn","listElement","itemCount","contains","_Symbol2","_Symbol3","symbols","uniqueString","description","count","symbolFunction","window","Symbol","_set","set","setter","SelectionAria","apply","arguments","role","itemRole","baseId","idCount","itemId","removeAttribute","ShadowTemplateMixin","ShadowTemplate","tag","localName","mapTagToTemplate","templateText","document","createElement","innerHTML","ShadyCSS","prepareTemplate","root","attachShadow","mode","clone","importNode","content","appendChild","applyStyle","SingleSelectionMixin","SingleSelection","selectionWraps","trackSelectedItem","updatePossibleNavigations","selectIndex","newIndex","canSelectNextSymbol","canSelectNext","changed","dispatchEvent","CustomEvent","canSelectPreviousSymbol","canSelectPrevious","externalSelectedIndexSymbol","index","internalSelectedIndexSymbol","parsedIndex","hasItems","externalSelectedItemSymbol","detail","internalSelectedItemSymbol","previousSelectedItem","indexOf","selectionRequiredSymbol","parsed","String","selectionWrapsSymbol","element","boundedIndex","Math","max","min","previousIndex","indexInCurrentItems","previousSelectedIndex","newSelectedIndex","_SingleSelectionMixin3","SingleSelectionDemo"],"mappings":"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","file":"demos.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1);\n\tmodule.exports = __webpack_require__(8);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tvar _ClickSelectionMixin = __webpack_require__(2);\n\t\n\tvar _ClickSelectionMixin2 = _interopRequireDefault(_ClickSelectionMixin);\n\t\n\tvar _SelectionAriaMixin = __webpack_require__(5);\n\t\n\tvar _SelectionAriaMixin2 = _interopRequireDefault(_SelectionAriaMixin);\n\t\n\tvar _ShadowTemplateMixin = __webpack_require__(6);\n\t\n\tvar _ShadowTemplateMixin2 = _interopRequireDefault(_ShadowTemplateMixin);\n\t\n\tvar _SingleSelectionMixin = __webpack_require__(7);\n\t\n\tvar _SingleSelectionMixin2 = _interopRequireDefault(_SingleSelectionMixin);\n\t\n\tvar _symbols = __webpack_require__(3);\n\t\n\tvar _symbols2 = _interopRequireDefault(_symbols);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This is currently a demo of how multiple mixins cooperate to perform useful\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * functions.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * * The component uses ShadowTemplateMixin to populate its shadow root.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * * A user can click on a child item, and ClickSelectionMixin will set the\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   selected item.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * * The SingleSelectionMixin will track the selected item, and map that to\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   changes in the selection state of the selected/deselected items.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * * The SelectionAriaMixin will reflect an item's selection state using ARIA\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   attributes to support assistive devices like screen readers.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This demo will eventually evolve into a complete list box component, but\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * at the moment omits many features, including support for Page Up/Page Down\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * keys, keeping the selected item in view, the ability to select an item\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * by typing its initial characters, and support for slot elements as children.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\t\n\t// We want to apply a number of mixin functions to HTMLElement.\n\tvar mixins = [_ClickSelectionMixin2.default, _SelectionAriaMixin2.default, _ShadowTemplateMixin2.default, _SingleSelectionMixin2.default];\n\t\n\t// The mixins are functions, so an efficient way to apply them all is with\n\t// reduce. This is just function composition. We end up with a base class we\n\t// can extend below.\n\tvar base = mixins.reduce(function (cls, mixin) {\n\t  return mixin(cls);\n\t}, HTMLElement);\n\t\n\t/**\n\t * A simple single-selection list box.\n\t *\n\t * This uses the base class we just created above, and adds in the behavior\n\t * unique to this list box element. As it turns out, much of this behavior is\n\t * also interesting to other components, and will eventually get factored into\n\t * other mixins.\n\t *\n\t * @extends HTMLElement\n\t * @mixes ClickSelectionMixin\n\t * @mixes SelectionAriaMixin\n\t * @mixes ShadowTemplateMixin\n\t * @mixes SingleSelectionMixin\n\t */\n\t\n\tvar ListBox = function (_base) {\n\t  _inherits(ListBox, _base);\n\t\n\t  function ListBox() {\n\t    _classCallCheck(this, ListBox);\n\t\n\t    // Simplistic keyboard handling for Left/Right and Up/Down keys.\n\t    var _this = _possibleConstructorReturn(this, (ListBox.__proto__ || Object.getPrototypeOf(ListBox)).call(this));\n\t\n\t    _this.addEventListener('keydown', function (event) {\n\t      _this[_symbols2.default.raiseChangeEvents] = true;\n\t      var handled = false;\n\t      switch (event.keyCode) {\n\t        case 37: // Left\n\t        case 38:\n\t          // Up\n\t          handled = _this.selectPrevious();\n\t          break;\n\t        case 39: // Right\n\t        case 40:\n\t          // Down\n\t          handled = _this.selectNext();\n\t          break;\n\t      }\n\t      if (handled) {\n\t        event.preventDefault();\n\t        event.stopPropagation();\n\t      }\n\t      _this[_symbols2.default.raiseChangeEvents] = false;\n\t    });\n\t\n\t    // The list needs to initialize any items it starts with by invoking the\n\t    // itemsChanged method. Mixins like the ARIA mixin will then use that signal\n\t    // to apply attributes to each item, as well as to the list element itself.\n\t    // For now, we invoke the method manually, but eventually we'll want a mixin\n\t    // to handle this common need. Because the Custom Element spec prevents an\n\t    // element from modifying itself in its own constructor, we do so in\n\t    // timeout.\n\t    setTimeout(function () {\n\t      _this[_symbols2.default.itemsChanged]();\n\t    });\n\t    return _this;\n\t  }\n\t\n\t  // Map attribute changes to the corresponding property.\n\t\n\t\n\t  _createClass(ListBox, [{\n\t    key: 'attributeChangedCallback',\n\t    value: function attributeChangedCallback(attributeName, oldValue, newValue) {\n\t      if (_get(ListBox.prototype.__proto__ || Object.getPrototypeOf(ListBox.prototype), 'attributeChangedCallback', this)) {\n\t        _get(ListBox.prototype.__proto__ || Object.getPrototypeOf(ListBox.prototype), 'attributeChangedCallback', this).call(this, attributeName, oldValue, newValue);\n\t      }\n\t      if (attributeName === 'selected-index') {\n\t        this.selectedIndex = parseInt(newValue);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'connectedCallback',\n\t    value: function connectedCallback() {\n\t      if (_get(ListBox.prototype.__proto__ || Object.getPrototypeOf(ListBox.prototype), 'connectedCallback', this)) {\n\t        _get(ListBox.prototype.__proto__ || Object.getPrototypeOf(ListBox.prototype), 'connectedCallback', this).call(this);\n\t      }\n\t      // Set a default tabindex so that the element can receive focus. That lets\n\t      // us support keyboard selection. We take care to avoid ovewritting any\n\t      // tabindex that's explicitly set on the list element.\n\t      if (this.getAttribute('tabindex') == null && this[_symbols2.default.defaults].tabindex !== null) {\n\t        this.setAttribute('tabindex', this[_symbols2.default.defaults].tabindex);\n\t      }\n\t    }\n\t\n\t    // We define a collection of default property values which can be set in\n\t    // the constructor or connectedCallback. Defining the actual default values\n\t    // in those calls would complicate things if a subclass someday wants to\n\t    // define its own default value.\n\t\n\t  }, {\n\t    key: _symbols2.default.itemSelected,\n\t\n\t\n\t    // Map item selection to a `selected` CSS class.\n\t    value: function value(item, selected) {\n\t      if (_get(ListBox.prototype.__proto__ || Object.getPrototypeOf(ListBox.prototype), _symbols2.default.itemSelected, this)) {\n\t        _get(ListBox.prototype.__proto__ || Object.getPrototypeOf(ListBox.prototype), _symbols2.default.itemSelected, this).call(this, item, selected);\n\t      }\n\t      item.classList.toggle('selected', selected);\n\t    }\n\t\n\t    // Simplistic implementation of an items property so that SingleSelectionMixin\n\t    // has items to work with. This doesn't handle Shadow DOM redistribution, so\n\t    // if someone puts a slot element inside the list, it won't behave as\n\t    // expected.\n\t\n\t  }, {\n\t    key: _symbols2.default.itemsChanged,\n\t\n\t\n\t    // A simplistic implementation of itemsChanged. A real implementation\n\t    // would also need to track changes in the set of children, and invoke\n\t    // itemAdded for new children.\n\t    value: function value() {\n\t      var _this2 = this;\n\t\n\t      Array.prototype.forEach.call(this.items, function (child) {\n\t        _this2[_symbols2.default.itemAdded](child);\n\t      });\n\t    }\n\t\n\t    // Tell the browser which attributes we want to handle.\n\t\n\t  }, {\n\t    key: _symbols2.default.defaults,\n\t    get: function get() {\n\t      var defaults = _get(ListBox.prototype.__proto__ || Object.getPrototypeOf(ListBox.prototype), _symbols2.default.defaults, this) || {};\n\t      // The default tab index is 0 (document order).\n\t      defaults.tabindex = 0;\n\t      return defaults;\n\t    }\n\t  }, {\n\t    key: 'items',\n\t    get: function get() {\n\t      return this.children;\n\t    }\n\t  }, {\n\t    key: _symbols2.default.template,\n\t\n\t\n\t    // Define a template that will be stamped into the Shadow DOM by the\n\t    // ShadowTemplateMixin.\n\t    get: function get() {\n\t      return '\\n      <style>\\n      :host {\\n        border: 1px solid gray;\\n        box-sizing: border-box;\\n        cursor: default;\\n        display: flex;\\n        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\\n      }\\n\\n      #itemsContainer {\\n        flex: 1;\\n        -webkit-overflow-scrolling: touch;\\n        overflow-y: scroll; /* for momentum scrolling */\\n      }\\n\\n      #itemsContainer ::slotted(*) {\\n        cursor: default;\\n        padding: 0.25em;\\n        -webkit-user-select: none;\\n        -moz-user-select: none;\\n        -ms-user-select: none;\\n        user-select: none;\\n      }\\n\\n      #itemsContainer ::slotted(.selected) {\\n        background: var(--elix-selected-background, highlight);\\n        color: var(--elix-selected-color, highlighttext);\\n      }\\n      </style>\\n\\n      <div id=\"itemsContainer\" role=\"none\">\\n        <slot></slot>\\n      </div>\\n    ';\n\t    }\n\t  }], [{\n\t    key: 'observedAttributes',\n\t    get: function get() {\n\t      return ['selected-index'];\n\t    }\n\t  }]);\n\t\n\t  return ListBox;\n\t}(base);\n\t\n\tcustomElements.define('sample-list-box', ListBox);\n\texports.default = ListBox;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = ClickSelectionMixin;\n\t\n\tvar _symbols = __webpack_require__(3);\n\t\n\tvar _symbols2 = _interopRequireDefault(_symbols);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t/**\n\t * Mixin which maps a click (actually, a mousedown) to a selection.\n\t *\n\t * This simple mixin is useful in list box-like elements, where a click on a\n\t * list item implicitly selects it.\n\t *\n\t * The standard use for this mixin is in list-like elements. Native list\n\t * boxes don't appear to be consistent with regard to whether they select\n\t * on mousedown or click/mouseup. This mixin assumes the use of mousedown.\n\t * On touch devices, that event appears to trigger when the touch is *released*.\n\t *\n\t * Much has been written about how to ensure \"fast tap\" behavior on mobile\n\t * devices. This mixin makes a very straightforward use of a standard event, and\n\t * this appears to perform well on mobile devices when, e.g., the viewport is\n\t * configured with `width=device-width`.\n\t *\n\t * This mixin expects the component to provide an `items` property. It also\n\t * expects the component to define a `selectedItem` property; you can provide\n\t * that yourself, or use [SingleSelectionMixin](SingleSelectionMixin.md).\n\t *\n\t * If the component receives a clicks that doesn't correspond to an item (e.g.,\n\t * the user clicks on the element background visible between items), the\n\t * selection will be removed. However, if the component defines a\n\t * `selectionRequired` and this is true, a background click will *not* remove\n\t * the selection.\n\t *\n\t * @module ClickSelectionMixin\n\t * @param base {Class} the base class to extend\n\t * @returns {Class} the extended class\n\t */\n\tfunction ClickSelectionMixin(base) {\n\t\n\t  /**\n\t   * The class prototype added by the mixin.\n\t   */\n\t  var ClickSelection = function (_base) {\n\t    _inherits(ClickSelection, _base);\n\t\n\t    function ClickSelection() {\n\t      _classCallCheck(this, ClickSelection);\n\t\n\t      var _this = _possibleConstructorReturn(this, (ClickSelection.__proto__ || Object.getPrototypeOf(ClickSelection)).call(this));\n\t\n\t      _this.addEventListener('mousedown', function (event) {\n\t\n\t        _this[_symbols2.default.raiseChangeEvents] = true;\n\t\n\t        // If the item clicked on is a button, the event seems to be raised in\n\t        // phase 2 (AT_TARGET) â€” but the event target will be the component, not\n\t        // the item that was clicked on.\n\t        var target = event.target === _this ? event.path[0] : // Event target isn't the item, so get it from path.\n\t        event.target;\n\t\n\t        // Find which item was clicked on and, if found, select it. For elements\n\t        // which don't require a selection, a background click will determine\n\t        // the item was null, in which we case we'll remove the selection.\n\t        var item = itemForTarget(_this, target);\n\t        if (item || !_this.selectionRequired) {\n\t\n\t          if (!('selectedItem' in _this)) {\n\t            console.warn('ClickSelectionMixin expects a component to define a \"selectedItem\" property.');\n\t          } else {\n\t            _this.selectedItem = item;\n\t          }\n\t\n\t          // We don't call preventDefault here. The default behavior for\n\t          // mousedown includes setting keyboard focus if the element doesn't\n\t          // already have the focus, and we want to preserve that behavior.\n\t          event.stopPropagation();\n\t        }\n\t\n\t        _this[_symbols2.default.raiseChangeEvents] = false;\n\t      });\n\t      return _this;\n\t    }\n\t\n\t    return ClickSelection;\n\t  }(base);\n\t\n\t  return ClickSelection;\n\t}\n\t\n\t/*\n\t * Return the list item that is, or contains, the indicated target element.\n\t * Return null if not found.\n\t */\n\tfunction itemForTarget(listElement, target) {\n\t  var items = listElement.items;\n\t  var itemCount = items ? items.length : 0;\n\t  for (var i = 0; i < itemCount; i++) {\n\t    var item = items[i];\n\t    if (item === target || item.contains(target)) {\n\t      return item;\n\t    }\n\t  }\n\t  return null;\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _Symbol2 = __webpack_require__(4);\n\t\n\tvar _Symbol3 = _interopRequireDefault(_Symbol2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * A collection of (potentially polyfilled) Symbol objects for standard\n\t * component properties and methods.\n\t *\n\t * These Symbol objects are used to allow mixins and a component to internally\n\t * communicate, without exposing these properties and methods in the component's\n\t * public API.\n\t *\n\t * To use these Symbol objects in your own component, include this module and\n\t * then create a property or method whose key is the desired Symbol.\n\t *\n\t *     import 'SingleSelectionMixin' from 'elix-mixins/src/SingleSelectionMixin';\n\t *     import 'symbols' from 'elix-mixins/src/symbols';\n\t *\n\t *     class MyElement extends SingleSelectionMixin(HTMLElement) {\n\t *       [symbols.itemSelected](item, selected) {\n\t *         // This will be invoked whenever an item is selected/deselected.\n\t *       }\n\t *     }\n\t *\n\t * @module symbols\n\t */\n\tvar symbols = {\n\t\n\t  /**\n\t   * Symbol for the `defaults` property.\n\t   *\n\t   * This property can be used to set or override defaults that will be applied\n\t   * to a new component instance. When implementing this property, take care to\n\t   * first acquire any defaults defined by the superclass. The standard idiom is\n\t   * as follows:\n\t   *\n\t   *     get [symbols.defaults]() {\n\t   *       const defaults = super[symbols.defaults] || {};\n\t   *       // Set or override default values here\n\t   *       defaults.customProperty = false;\n\t   *       return defaults;\n\t   *     }\n\t   *\n\t   * @var {object} defaults\n\t   */\n\t  defaults: (0, _Symbol3.default)('defaults'),\n\t\n\t  /**\n\t   * Symbol for the `raiseChangeEvents` property.\n\t   *\n\t   * This property is used by mixins to determine whether they should raise\n\t   * property change events. The standard HTML pattern is to only raise such\n\t   * events in response to direct user interactions. For a detailed discussion\n\t   * of this point, see the Gold Standard checklist item for\n\t   * [Propery Change Events](https://github.com/webcomponents/gold-standard/wiki/Property%20Change%20Events).\n\t   *\n\t   * The above article describes a pattern for using a flag to track whether\n\t   * work is being performed in response to internal component activity, and\n\t   * whether the component should therefore raise property change events.\n\t   * This `raiseChangeEvents` symbol is a shared flag used for that purpose by\n\t   * all Elix mixins and components. Sharing this flag ensures that internal\n\t   * activity (e.g., a UI event listener) in one mixin can signal other mixins\n\t   * handling affected properties to raise change events.\n\t   *\n\t   * All UI event listeners (and other forms of internal handlers, such as\n\t   * timeouts and async network handlers) should set `raiseChangeEvents` to\n\t   * `true` at the start of the event handler, then `false` at the end:\n\t   *\n\t   *     this.addEventListener('click', event => {\n\t   *       this[symbols.raiseChangeEvents] = true;\n\t   *       // Do work here, possibly setting properties, like:\n\t   *       this.foo = 'Hello';\n\t   *       this[symbols.raiseChangeEvents] = false;\n\t   *     });\n\t   *\n\t   * Elsewhere, property setters that raise change events should only do so it\n\t   * this property is `true`:\n\t   *\n\t   *     set foo(value) {\n\t   *       // Save foo value here, do any other work.\n\t   *       if (this[symbols.raiseChangeEvents]) {\n\t   *         const event = new CustomEvent('foo-changed');\n\t   *         this.dispatchEvent(event);\n\t   *       }\n\t   *     }\n\t   *\n\t   * In this way, programmatic attempts to set the `foo` property will not\n\t   * trigger the `foo-changed` event, but UI interactions that update that\n\t   * property will cause those events to be raised.\n\t   *\n\t   * @var {boolean} raiseChangeEvents\n\t   */\n\t  raiseChangeEvents: (0, _Symbol3.default)('raiseChangeEvents'),\n\t\n\t  /**\n\t   * Symbol for the `itemAdded` method.\n\t   *\n\t   * This method is invoked when a new item is added to a list.\n\t   *\n\t   * @function itemAdded\n\t   * @param {HTMLElement} item - the item being selected/deselected\n\t   */\n\t  itemAdded: (0, _Symbol3.default)('itemAdded'),\n\t\n\t  /**\n\t   * Symbol for the `itemsChanged` method.\n\t   *\n\t   * This method is invoked when the underlying contents change. It is also\n\t   * invoked on component initialization â€“ since the items have \"changed\" from\n\t   * being nothing.\n\t   *\n\t   * @function itemsChanged\n\t   */\n\t  itemsChanged: (0, _Symbol3.default)('itemsChanged'),\n\t\n\t  /**\n\t   * Symbol for the `itemSelected` method.\n\t   *\n\t   * This method is invoked when an item becomes selected or deselected.\n\t   *\n\t   * @function itemSelected\n\t   * @param {HTMLElement} item - the item being selected/deselected\n\t   * @param {boolean} selected - true if the item is selected, false if not\n\t   */\n\t  itemSelected: (0, _Symbol3.default)('itemSelected'),\n\t\n\t  /**\n\t   * Symbol for the `template` property.\n\t   *\n\t   * This property returns a component's template.\n\t   *\n\t   * @type {string|HTMLTemplateElement}\n\t   */\n\t  template: (0, _Symbol3.default)('template')\n\t};\n\t\n\texports.default = symbols;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/* The number of fake symbols we've served up */\n\tvar count = 0;\n\t\n\tfunction uniqueString(description) {\n\t  return '_' + description + count++;\n\t}\n\t\n\tvar symbolFunction = typeof window.Symbol === 'function' ? window.Symbol : uniqueString;\n\t\n\t/**\n\t * Polyfill for ES6 symbol class.\n\t *\n\t * Mixins and component classes often want to associate private data with an\n\t * element instance, but JavaScript does not have direct support for true\n\t * private properties. One approach is to use the\n\t * [Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)\n\t * data type to set and retrieve data on an element.\n\t *\n\t * Unfortunately, the Symbol type is not available in Internet Explorer 11. In\n\t * lieu of returning a true Symbol, this polyfill returns a different string\n\t * each time it is called.\n\t *\n\t * Usage:\n\t *\n\t *     const fooSymbol = Symbol('foo');\n\t *\n\t *     class MyElement extends HTMLElement {\n\t *       get foo() {\n\t *         return this[fooSymbol];\n\t *       }\n\t *       set foo(value) {\n\t *         this[fooSymbol] = value;\n\t *       }\n\t *     }\n\t *\n\t * In IE 11, this sample will \"hide\" data behind an instance property that looks\n\t * like this._foo0. The underscore is meant to reduce (not eliminate) potential\n\t * accidental access, and the unique number at the end is mean to avoid (not\n\t * eliminate) naming conflicts.\n\t *\n\t * @function Symbol\n\t * @param {string} description - A string to identify the symbol when debugging\n\t * @returns {Symbol|string} â€” A Symbol (in ES6 browsers) or unique string ID (in\n\t * ES5).\n\t */\n\texports.default = symbolFunction;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _set = function set(object, property, value, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent !== null) { set(parent, property, value, receiver); } } else if (\"value\" in desc && desc.writable) { desc.value = value; } else { var setter = desc.set; if (setter !== undefined) { setter.call(receiver, value); } } return value; };\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\texports.default = function (base) {\n\t\n\t  /**\n\t   * The class prototype added by the mixin.\n\t   */\n\t  var SelectionAria = function (_base) {\n\t    _inherits(SelectionAria, _base);\n\t\n\t    function SelectionAria() {\n\t      _classCallCheck(this, SelectionAria);\n\t\n\t      return _possibleConstructorReturn(this, (SelectionAria.__proto__ || Object.getPrototypeOf(SelectionAria)).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(SelectionAria, [{\n\t      key: 'connectedCallback',\n\t      value: function connectedCallback() {\n\t        if (_get(SelectionAria.prototype.__proto__ || Object.getPrototypeOf(SelectionAria.prototype), 'connectedCallback', this)) {\n\t          _get(SelectionAria.prototype.__proto__ || Object.getPrototypeOf(SelectionAria.prototype), 'connectedCallback', this).call(this);\n\t        }\n\t\n\t        // Set default ARIA role for the overall component.\n\t        if (this.getAttribute('role') == null && this[_symbols2.default.defaults].role) {\n\t          this.setAttribute('role', this[_symbols2.default.defaults].role);\n\t        }\n\t      }\n\t    }, {\n\t      key: _symbols2.default.itemAdded,\n\t      value: function value(item) {\n\t        if (_get(SelectionAria.prototype.__proto__ || Object.getPrototypeOf(SelectionAria.prototype), _symbols2.default.itemAdded, this)) {\n\t          _get(SelectionAria.prototype.__proto__ || Object.getPrototypeOf(SelectionAria.prototype), _symbols2.default.itemAdded, this).call(this, item);\n\t        }\n\t\n\t        if (!item.getAttribute('role')) {\n\t          // Assign a default ARIA role for an individual item.\n\t          item.setAttribute('role', this[_symbols2.default.defaults].itemRole);\n\t        }\n\t\n\t        // Ensure each item has an ID so we can set aria-activedescendant on the\n\t        // overall list whenever the selection changes.\n\t        //\n\t        // The ID will take the form of a base ID plus a unique integer. The base\n\t        // ID will be incorporate the component's own ID. E.g., if a component has\n\t        // ID \"foo\", then its items will have IDs that look like \"_fooOption1\". If\n\t        // the compnent has no ID itself, its items will get IDs that look like\n\t        // \"_option1\". Item IDs are prefixed with an underscore to differentiate\n\t        // them from manually-assigned IDs, and to minimize the potential for ID\n\t        // conflicts.\n\t        if (!item.id) {\n\t          var baseId = this.id ? \"_\" + this.id + \"Option\" : \"_option\";\n\t          item.id = baseId + idCount++;\n\t        }\n\t      }\n\t    }, {\n\t      key: _symbols2.default.itemSelected,\n\t      value: function value(item, selected) {\n\t        if (_get(SelectionAria.prototype.__proto__ || Object.getPrototypeOf(SelectionAria.prototype), _symbols2.default.itemSelected, this)) {\n\t          _get(SelectionAria.prototype.__proto__ || Object.getPrototypeOf(SelectionAria.prototype), _symbols2.default.itemSelected, this).call(this, item, selected);\n\t        }\n\t        item.setAttribute('aria-selected', selected);\n\t        var itemId = item.id;\n\t        if (itemId && selected) {\n\t          this.setAttribute('aria-activedescendant', itemId);\n\t        }\n\t      }\n\t    }, {\n\t      key: _symbols2.default.defaults,\n\t      get: function get() {\n\t        var defaults = _get(SelectionAria.prototype.__proto__ || Object.getPrototypeOf(SelectionAria.prototype), _symbols2.default.defaults, this) || {};\n\t        defaults.role = 'listbox';\n\t        defaults.itemRole = 'option';\n\t        return defaults;\n\t      }\n\t    }, {\n\t      key: 'selectedItem',\n\t      get: function get() {\n\t        return _get(SelectionAria.prototype.__proto__ || Object.getPrototypeOf(SelectionAria.prototype), 'selectedItem', this);\n\t      },\n\t      set: function set(item) {\n\t        if ('selectedItem' in base.prototype) {\n\t          _set(SelectionAria.prototype.__proto__ || Object.getPrototypeOf(SelectionAria.prototype), 'selectedItem', item, this);\n\t        }\n\t        if (item == null) {\n\t          // Selection was removed.\n\t          this.removeAttribute('aria-activedescendant');\n\t        }\n\t      }\n\t    }]);\n\t\n\t    return SelectionAria;\n\t  }(base);\n\t\n\t  return SelectionAria;\n\t};\n\t\n\tvar _symbols = __webpack_require__(3);\n\t\n\tvar _symbols2 = _interopRequireDefault(_symbols);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t// Used to assign unique IDs to item elements without IDs.\n\tvar idCount = 0;\n\t\n\t/**\n\t * Mixin which treats the selected item in a list as the active item in ARIA\n\t * accessibility terms.\n\t *\n\t * Handling ARIA selection state properly is actually quite complex:\n\t *\n\t * * The items in the list need to be indicated as possible items via an ARIA\n\t *   `role` attribute value such as \"option\".\n\t * * The selected item need to be marked as selected by setting the item's\n\t *   `aria-selected` attribute to true *and* the other items need be marked as\n\t *   *not* selected by setting `aria-selected` to false.\n\t * * The outermost element with the keyboard focus needs to have attributes\n\t *   set on it so that the selection is knowable at the list level via the\n\t *   `aria-activedescendant` attribute.\n\t * * Use of `aria-activedescendant` in turn requires that all items in the\n\t *   list have ID attributes assigned to them.\n\t *\n\t * This mixin tries to address all of the above requirements. To that end,\n\t * this mixin will assign generated IDs to any item that doesn't already have\n\t * an ID.\n\t *\n\t * ARIA relies on elements to provide `role` attributes. This mixin will apply\n\t * a default role of \"listbox\" on the outer list if it doesn't already have an\n\t * explicit role. Similarly, this mixin will apply a default role of \"option\"\n\t * to any list item that does not already have a role specified.\n\t *\n\t * This mixin expects a set of members that manage the state of the selection:\n\t * `[symbols.itemSelected]`, `[symbols.itemAdded]`, and `selectedItem`. You can\n\t * supply these yourself, or do so via\n\t * [SingleSelectionMixin](SingleSelectionMixin.md).\n\t *\n\t * @module\n\t * @param base {Class} the base class to extend\n\t * @returns {Class} the extended class\n\t */\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\texports.default = ShadowTemplateMixin;\n\t\n\tvar _symbols = __webpack_require__(3);\n\t\n\tvar _symbols2 = _interopRequireDefault(_symbols);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t// A cache of processed templates.\n\t//\n\t// We maintain this as a map keyed by element tag (localName). We could store\n\t// an element's processed template on its element prototype. One scenario that\n\t// wouldn't support would be registration of the same constructor under multiple\n\t// tag names, which was a (perhaps theoretical) use case for Custom Elements.\n\t//\n\tvar mapTagToTemplate = {};\n\t\n\t/**\n\t * Mixin which adds stamping a template into a Shadow DOM subtree upon component\n\t * instantiation.\n\t *\n\t * To use this mixin, define a `template` property as a string or HTML\n\t * `<template>` element:\n\t *\n\t *     class MyElement extends ShadowTemplateMixin(HTMLElement) {\n\t *       get [symbols.template]() {\n\t *         return `Hello, <em>world</em>.`;\n\t *       }\n\t *     }\n\t *\n\t * When your component class is instantiated, a shadow root will be created on\n\t * the instance, and the contents of the template will be cloned into the\n\t * shadow root. If your component does not define a `template` property, this\n\t * mixin has no effect.\n\t *\n\t * For the time being, this extension retains support for Shadow DOM v0. That\n\t * will eventually be deprecated as browsers (and the Shadow DOM polyfill)\n\t * implement Shadow DOM v1.\n\t *\n\t * @module ShadowTemplateMixin\n\t * @param base {Class} the base class to extend\n\t * @returns {Class} the extended class\n\t */\n\tfunction ShadowTemplateMixin(base) {\n\t\n\t  /**\n\t   * The class prototype added by the mixin.\n\t   */\n\t  var ShadowTemplate = function (_base) {\n\t    _inherits(ShadowTemplate, _base);\n\t\n\t    /*\n\t     * If the component defines a template, a shadow root will be created on the\n\t     * component instance, and the template stamped into it.\n\t     */\n\t    function ShadowTemplate() {\n\t      _classCallCheck(this, ShadowTemplate);\n\t\n\t      var _this = _possibleConstructorReturn(this, (ShadowTemplate.__proto__ || Object.getPrototypeOf(ShadowTemplate)).call(this));\n\t\n\t      var tag = _this.localName;\n\t      var template = mapTagToTemplate[tag];\n\t\n\t      // See if we've already processed a template for this tag.\n\t      if (!template) {\n\t        // This is the first time we've created an instance of this tag.\n\t\n\t        // Get the template and perform initial processing.\n\t        template = _this[_symbols2.default.template];\n\t        if (!template) {\n\t          console.warn('ShadowTemplateMixin expects a component to define a template property with [symbols.template].');\n\t          return _possibleConstructorReturn(_this);\n\t        }\n\t\n\t        if (typeof template === 'string') {\n\t          // Upgrade plain string to real template.\n\t          var templateText = template;\n\t          template = document.createElement('template');\n\t          template.innerHTML = templateText;\n\t        }\n\t\n\t        if (window.ShadyCSS) {\n\t          // Let the CSS polyfill do its own initialization.\n\t          window.ShadyCSS.prepareTemplate(template, tag);\n\t        }\n\t\n\t        // Store this for the next time we create the same type of element.\n\t        mapTagToTemplate[tag] = template;\n\t      }\n\t\n\t      // Stamp the template into a new shadow root.\n\t      var root = _this.attachShadow({ mode: 'open' });\n\t      var clone = document.importNode(template.content, true);\n\t      root.appendChild(clone);\n\t      return _this;\n\t    }\n\t\n\t    _createClass(ShadowTemplate, [{\n\t      key: 'connectedCallback',\n\t      value: function connectedCallback() {\n\t        if (_get(ShadowTemplate.prototype.__proto__ || Object.getPrototypeOf(ShadowTemplate.prototype), 'connectedCallback', this)) {\n\t          _get(ShadowTemplate.prototype.__proto__ || Object.getPrototypeOf(ShadowTemplate.prototype), 'connectedCallback', this).call(this);\n\t        }\n\t        if (window.ShadyCSS) {\n\t          window.ShadyCSS.applyStyle(this);\n\t        }\n\t      }\n\t    }]);\n\t\n\t    return ShadowTemplate;\n\t  }(base);\n\t\n\t  return ShadowTemplate;\n\t}\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tvar _set = function set(object, property, value, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent !== null) { set(parent, property, value, receiver); } } else if (\"value\" in desc && desc.writable) { desc.value = value; } else { var setter = desc.set; if (setter !== undefined) { setter.call(receiver, value); } } return value; };\n\t\n\texports.default = SingleSelectionMixin;\n\t\n\tvar _Symbol2 = __webpack_require__(4);\n\t\n\tvar _Symbol3 = _interopRequireDefault(_Symbol2);\n\t\n\tvar _symbols = __webpack_require__(3);\n\t\n\tvar _symbols2 = _interopRequireDefault(_symbols);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t// Symbols for private data members on an element.\n\tvar canSelectNextSymbol = (0, _Symbol3.default)('canSelectNext');\n\tvar canSelectPreviousSymbol = (0, _Symbol3.default)('canSelectPrevious');\n\tvar selectionRequiredSymbol = (0, _Symbol3.default)('selectionRequired');\n\tvar selectionWrapsSymbol = (0, _Symbol3.default)('selectionWraps');\n\t\n\t// We want to expose both selectedIndex and selectedItem as independent\n\t// properties but keep them in sync. This allows a component user to reference\n\t// the selection by whatever means is most natural for their situation.\n\t//\n\t// To efficiently keep these properties in sync, we track \"external\" and\n\t// \"internal\" references for each property:\n\t//\n\t// The external index or item is the one we report to the outside world when\n\t// asked for selection.  When handling a change to index or item, we update the\n\t// external reference as soon as possible, so that if anyone immediately asks\n\t// for the current selection, they will receive a stable answer.\n\t//\n\t// The internal index or item tracks whichever index or item last received the\n\t// full set of processing. Processing includes raising a change event for the\n\t// new value. Once we've begun that processing, we store the new value as the\n\t// internal value to indicate we've handled it.\n\t//\n\tvar externalSelectedIndexSymbol = (0, _Symbol3.default)('externalSelectedIndex');\n\tvar externalSelectedItemSymbol = (0, _Symbol3.default)('externalSelectedItem');\n\tvar internalSelectedIndexSymbol = (0, _Symbol3.default)('internalSelectedIndex');\n\tvar internalSelectedItemSymbol = (0, _Symbol3.default)('internalSelectedItem');\n\t\n\t/**\n\t * Mixin which adds single-selection semantics for items in a list.\n\t *\n\t * This mixin expects a component to provide an `items` Array or NodeList of\n\t * all elements in the list.\n\t *\n\t * This mixin tracks a single selected item in the list, and provides means to\n\t * get and set that state by item position (`selectedIndex`) or item identity\n\t * (`selectedItem`). The selection can be moved in the list via the methods\n\t * `selectFirst`, `selectLast`, `selectNext`, and `selectPrevious`.\n\t *\n\t * This mixin does not produce any user-visible effects to represent\n\t * selection.\n\t *\n\t * @module SingleSelectionMixin\n\t * @param base {Class} the base class to extend\n\t * @returns {Class} the extended class\n\t */\n\tfunction SingleSelectionMixin(base) {\n\t\n\t  /**\n\t   * The class prototype added by the mixin.\n\t   */\n\t  var SingleSelection = function (_base) {\n\t    _inherits(SingleSelection, _base);\n\t\n\t    function SingleSelection() {\n\t      _classCallCheck(this, SingleSelection);\n\t\n\t      // Set defaults.\n\t      var _this = _possibleConstructorReturn(this, (SingleSelection.__proto__ || Object.getPrototypeOf(SingleSelection)).call(this));\n\t\n\t      if (typeof _this.selectionRequired === 'undefined') {\n\t        _this.selectionRequired = _this[_symbols2.default.defaults].selectionRequired;\n\t      }\n\t      if (typeof _this.selectionWraps === 'undefined') {\n\t        _this.selectionWraps = _this[_symbols2.default.defaults].selectionWraps;\n\t      }\n\t      return _this;\n\t    }\n\t\n\t    /**\n\t     * True if the selection can be moved to the next item, false if not (the\n\t     * selected item is the last item in the list).\n\t     *\n\t     * @type {boolean}\n\t     */\n\t\n\t\n\t    _createClass(SingleSelection, [{\n\t      key: _symbols2.default.itemAdded,\n\t\n\t\n\t      /**\n\t       * Handle a new item being added to the list.\n\t       *\n\t       * The default implementation of this method simply sets the item's\n\t       * selection state to false.\n\t       *\n\t       * @param {HTMLElement} item - the item being added\n\t       */\n\t      value: function value(item) {\n\t        if (_get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), _symbols2.default.itemAdded, this)) {\n\t          _get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), _symbols2.default.itemAdded, this).call(this, item);\n\t        }\n\t        this[_symbols2.default.itemSelected](item, item === this.selectedItem);\n\t      }\n\t    }, {\n\t      key: _symbols2.default.itemsChanged,\n\t      value: function value() {\n\t        if (_get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), _symbols2.default.itemsChanged, this)) {\n\t          _get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), _symbols2.default.itemsChanged, this).call(this);\n\t        }\n\t\n\t        // In case selected item changed position or was removed.\n\t        trackSelectedItem(this);\n\t\n\t        // In case the change in items affected which navigations are possible.\n\t        updatePossibleNavigations(this);\n\t      }\n\t\n\t      /**\n\t       * Apply the indicate selection state to the item.\n\t       *\n\t       * The default implementation of this method does nothing. User-visible\n\t       * effects will typically be handled by other mixins.\n\t       *\n\t       * @param {HTMLElement} item - the item being selected/deselected\n\t       * @param {boolean} selected - true if the item is selected, false if not\n\t       */\n\t\n\t    }, {\n\t      key: _symbols2.default.itemSelected,\n\t      value: function value(item, selected) {\n\t        if (_get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), _symbols2.default.itemSelected, this)) {\n\t          _get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), _symbols2.default.itemSelected, this).call(this, item, selected);\n\t        }\n\t      }\n\t\n\t      /**\n\t       * The index of the item which is currently selected.\n\t       *\n\t       * The setter expects an integer or a string representing an integer.\n\t       *\n\t       * A `selectedIndex` of -1 indicates there is no selection. Setting this\n\t       * property to -1 will remove any existing selection.\n\t       *\n\t       * @type {number}\n\t       */\n\t\n\t    }, {\n\t      key: 'selectFirst',\n\t\n\t\n\t      /**\n\t       * Select the first item in the list.\n\t       *\n\t       * @returns {Boolean} True if the selection changed, false if not.\n\t       */\n\t      value: function selectFirst() {\n\t        if (_get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectFirst', this)) {\n\t          _get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectFirst', this).call(this);\n\t        }\n\t        return selectIndex(this, 0);\n\t      }\n\t\n\t      /**\n\t       * True if the list should always have a selection (if it has items).\n\t       *\n\t       * @type {boolean}\n\t       * @default false\n\t       */\n\t\n\t    }, {\n\t      key: 'selectLast',\n\t\n\t\n\t      /**\n\t       * Select the last item in the list.\n\t       *\n\t       * @returns {Boolean} True if the selection changed, false if not.\n\t       */\n\t      value: function selectLast() {\n\t        if (_get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectLast', this)) {\n\t          _get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectLast', this).call(this);\n\t        }\n\t        return selectIndex(this, this.items.length - 1);\n\t      }\n\t\n\t      /**\n\t       * Select the next item in the list.\n\t       *\n\t       * If the list has no selection, the first item will be selected.\n\t       *\n\t       * @returns {Boolean} True if the selection changed, false if not.\n\t       */\n\t\n\t    }, {\n\t      key: 'selectNext',\n\t      value: function selectNext() {\n\t        if (_get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectNext', this)) {\n\t          _get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectNext', this).call(this);\n\t        }\n\t        return selectIndex(this, this.selectedIndex + 1);\n\t      }\n\t\n\t      /**\n\t       * Select the previous item in the list.\n\t       *\n\t       * If the list has no selection, the last item will be selected.\n\t       *\n\t       * @returns {Boolean} True if the selection changed, false if not.\n\t       */\n\t\n\t    }, {\n\t      key: 'selectPrevious',\n\t      value: function selectPrevious() {\n\t        if (_get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectPrevious', this)) {\n\t          _get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectPrevious', this).call(this);\n\t        }\n\t        var newIndex = this.selectedIndex < 0 ? this.items.length - 1 : // No selection yet; select last item.\n\t        this.selectedIndex - 1;\n\t        return selectIndex(this, newIndex);\n\t      }\n\t\n\t      /**\n\t       * Fires when the canSelectNext property changes in response to internal\n\t       * component activity.\n\t       *\n\t       * @memberof SingleSelection\n\t       * @event can-select-next-changed\n\t       */\n\t\n\t      /**\n\t       * Fires when the canSelectPrevious property changes in response to internal\n\t       * component activity.\n\t       *\n\t       * @memberof SingleSelection\n\t       * @event can-select-previous-changed\n\t       */\n\t\n\t      /**\n\t       * Fires when the selectedIndex property changes in response to internal\n\t       * component activity.\n\t       *\n\t       * @memberof SingleSelection\n\t       * @event selected-index-changed\n\t       * @param {number} detail.selectedIndex The new selected index.\n\t       */\n\t\n\t      /**\n\t       * Fires when the selectedItem property changes in response to internal\n\t       * component activity.\n\t       *\n\t       * @memberof SingleSelection\n\t       * @event selected-item-changed\n\t       * @param {HTMLElement} detail.selectedItem The new selected item.\n\t       */\n\t\n\t    }, {\n\t      key: 'canSelectNext',\n\t      get: function get() {\n\t        return this[canSelectNextSymbol];\n\t      },\n\t      set: function set(canSelectNext) {\n\t        var changed = canSelectNext !== this[canSelectNextSymbol];\n\t        this[canSelectNextSymbol] = canSelectNext;\n\t        if ('canSelectNext' in base.prototype) {\n\t          _set(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'canSelectNext', canSelectNext, this);\n\t        }\n\t        if (this[_symbols2.default.raiseChangeEvents] && changed) {\n\t          this.dispatchEvent(new CustomEvent('can-select-next-changed'));\n\t        }\n\t      }\n\t\n\t      /**\n\t       * True if the selection can be moved to the previous item, false if not\n\t       * (the selected item is the first one in the list).\n\t       *\n\t       * @type {boolean}\n\t       */\n\t\n\t    }, {\n\t      key: 'canSelectPrevious',\n\t      get: function get() {\n\t        return this[canSelectPreviousSymbol];\n\t      },\n\t      set: function set(canSelectPrevious) {\n\t        var changed = canSelectPrevious !== this[canSelectPreviousSymbol];\n\t        this[canSelectPreviousSymbol] = canSelectPrevious;\n\t        if ('canSelectPrevious' in base.prototype) {\n\t          _set(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'canSelectPrevious', canSelectPrevious, this);\n\t        }\n\t        if (this[_symbols2.default.raiseChangeEvents] && changed) {\n\t          this.dispatchEvent(new CustomEvent('can-select-previous-changed'));\n\t        }\n\t      }\n\t    }, {\n\t      key: _symbols2.default.defaults,\n\t      get: function get() {\n\t        var defaults = _get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), _symbols2.default.defaults, this) || {};\n\t        defaults.selectionRequired = false;\n\t        defaults.selectionWraps = false;\n\t        return defaults;\n\t      }\n\t    }, {\n\t      key: 'selectedIndex',\n\t      get: function get() {\n\t        return this[externalSelectedIndexSymbol] != null ? this[externalSelectedIndexSymbol] : -1;\n\t      },\n\t      set: function set(index) {\n\t        // See notes at top about internal vs. external copies of this property.\n\t        var changed = index !== this[internalSelectedIndexSymbol];\n\t        var item = void 0;\n\t        var parsedIndex = parseInt(index);\n\t        if (parsedIndex !== this[externalSelectedIndexSymbol]) {\n\t          // Store the new index and the corresponding item.\n\t          var items = this.items;\n\t          var hasItems = items && items.length > 0;\n\t          if (!(hasItems && parsedIndex >= 0 && parsedIndex < items.length)) {\n\t            parsedIndex = -1; // No item at that index.\n\t          }\n\t          this[externalSelectedIndexSymbol] = parsedIndex;\n\t          item = hasItems && parsedIndex >= 0 ? items[parsedIndex] : null;\n\t          this[externalSelectedItemSymbol] = item;\n\t        } else {\n\t          item = this[externalSelectedItemSymbol];\n\t        }\n\t\n\t        // Now let super do any work.\n\t        if ('selectedIndex' in base.prototype) {\n\t          _set(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectedIndex', index, this);\n\t        }\n\t\n\t        if (changed) {\n\t          // The selected index changed.\n\t          this[internalSelectedIndexSymbol] = parsedIndex;\n\t\n\t          if (this[_symbols2.default.raiseChangeEvents]) {\n\t            var event = new CustomEvent('selected-index-changed', {\n\t              detail: {\n\t                selectedIndex: parsedIndex,\n\t                value: parsedIndex // for Polymer binding. TODO: Verify still necessary\n\t              }\n\t            });\n\t            this.dispatchEvent(event);\n\t          }\n\t        }\n\t\n\t        if (this[internalSelectedItemSymbol] !== item) {\n\t          // Update selectedItem property so it can have its own effects.\n\t          this.selectedItem = item;\n\t        }\n\t      }\n\t\n\t      /**\n\t       * The currently selected item, or null if there is no selection.\n\t       *\n\t       * Setting this property to null deselects any currently-selected item.\n\t       * Setting this property to an object that is not in the list has no effect.\n\t       *\n\t       * TODO: Even if selectionRequired, can still explicitly set selectedItem to null.\n\t       * TODO: If selectionRequired, leave selection alone?\n\t       *\n\t       * @type {object}\n\t       */\n\t\n\t    }, {\n\t      key: 'selectedItem',\n\t      get: function get() {\n\t        return this[externalSelectedItemSymbol] || null;\n\t      },\n\t      set: function set(item) {\n\t        // See notes at top about internal vs. external copies of this property.\n\t        var previousSelectedItem = this[internalSelectedItemSymbol];\n\t        var changed = item !== previousSelectedItem;\n\t        var index = void 0;\n\t        if (item !== this[externalSelectedItemSymbol]) {\n\t          // Store item and look up corresponding index.\n\t          var items = this.items;\n\t          var hasItems = items && items.length > 0;\n\t          index = hasItems ? Array.prototype.indexOf.call(items, item) : -1;\n\t          this[externalSelectedIndexSymbol] = index;\n\t          if (index < 0) {\n\t            item = null; // The indicated item isn't actually in `items`.\n\t          }\n\t          this[externalSelectedItemSymbol] = item;\n\t        } else {\n\t          index = this[externalSelectedIndexSymbol];\n\t        }\n\t\n\t        // Now let super do any work.\n\t        if ('selectedItem' in base.prototype) {\n\t          _set(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectedItem', item, this);\n\t        }\n\t\n\t        if (changed) {\n\t          // The selected item changed.\n\t          this[internalSelectedItemSymbol] = item;\n\t\n\t          if (previousSelectedItem) {\n\t            // Update selection state of old item.\n\t            this[_symbols2.default.itemSelected](previousSelectedItem, false);\n\t          }\n\t          if (item) {\n\t            // Update selection state to new item.\n\t            this[_symbols2.default.itemSelected](item, true);\n\t          }\n\t\n\t          updatePossibleNavigations(this);\n\t\n\t          if (this[_symbols2.default.raiseChangeEvents]) {\n\t            var event = new CustomEvent('selected-item-changed', {\n\t              detail: {\n\t                selectedItem: item,\n\t                value: item // for Polymer binding\n\t              }\n\t            });\n\t            this.dispatchEvent(event);\n\t          }\n\t        }\n\t\n\t        if (this[internalSelectedIndexSymbol] !== index) {\n\t          // Update selectedIndex property so it can have its own effects.\n\t          this.selectedIndex = index;\n\t        }\n\t      }\n\t    }, {\n\t      key: 'selectionRequired',\n\t      get: function get() {\n\t        return this[selectionRequiredSymbol];\n\t      },\n\t      set: function set(selectionRequired) {\n\t        var parsed = String(selectionRequired) === 'true';\n\t        var changed = parsed !== this[selectionRequiredSymbol];\n\t        this[selectionRequiredSymbol] = parsed;\n\t        if ('selectionRequired' in base.prototype) {\n\t          _set(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectionRequired', selectionRequired, this);\n\t        }\n\t        if (changed) {\n\t          if (this[_symbols2.default.raiseChangeEvents]) {\n\t            var event = new CustomEvent('selection-required-changed');\n\t            this.dispatchEvent(event);\n\t          }\n\t          if (selectionRequired) {\n\t            trackSelectedItem(this);\n\t          }\n\t        }\n\t      }\n\t\n\t      /**\n\t       * True if selection navigations wrap from last to first, and vice versa.\n\t       *\n\t       * @type {boolean}\n\t       * @default false\n\t       */\n\t\n\t    }, {\n\t      key: 'selectionWraps',\n\t      get: function get() {\n\t        return this[selectionWrapsSymbol];\n\t      },\n\t      set: function set(selectionWraps) {\n\t        var parsed = String(selectionWraps) === 'true';\n\t        var changed = parsed !== this[selectionWrapsSymbol];\n\t        this[selectionWrapsSymbol] = parsed;\n\t        if ('selectionWraps' in base.prototype) {\n\t          _set(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectionWraps', selectionWraps, this);\n\t        }\n\t        if (changed) {\n\t          if (this[_symbols2.default.raiseChangeEvents]) {\n\t            var event = new CustomEvent('selection-wraps-changed');\n\t            this.dispatchEvent(event);\n\t          }\n\t          updatePossibleNavigations(this);\n\t        }\n\t      }\n\t    }]);\n\t\n\t    return SingleSelection;\n\t  }(base);\n\t\n\t  return SingleSelection;\n\t}\n\t\n\t// Ensure the given index is within bounds, and select it if it's not already\n\t// selected.\n\tfunction selectIndex(element, index) {\n\t\n\t  var items = element.items;\n\t  if (items == null) {\n\t    // Nothing to select.\n\t    return false;\n\t  }\n\t\n\t  var count = items.length;\n\t  var boundedIndex = element.selectionWraps ?\n\t  // JavaScript mod doesn't handle negative numbers the way we want to wrap.\n\t  // See http://stackoverflow.com/a/18618250/76472\n\t  (index % count + count) % count :\n\t\n\t  // Keep index within bounds of array.\n\t  Math.max(Math.min(index, count - 1), 0);\n\t\n\t  var previousIndex = element.selectedIndex;\n\t  if (previousIndex !== boundedIndex) {\n\t    element.selectedIndex = boundedIndex;\n\t    return true;\n\t  } else {\n\t    return false;\n\t  }\n\t}\n\t\n\t// Following a change in the set of items, or in the value of the\n\t// `selectionRequired` property, reacquire the selected item. If it's moved,\n\t// update `selectedIndex`. If it's been removed, and a selection is required,\n\t// try to select another item.\n\tfunction trackSelectedItem(element) {\n\t\n\t  var items = element.items;\n\t  var itemCount = items ? items.length : 0;\n\t\n\t  var previousSelectedItem = element.selectedItem;\n\t  if (!previousSelectedItem) {\n\t    // No item was previously selected.\n\t    if (element.selectionRequired) {\n\t      // Select the first item by default.\n\t      element.selectedIndex = 0;\n\t    }\n\t  } else if (itemCount === 0) {\n\t    // We've lost the selection, and there's nothing left to select.\n\t    element.selectedItem = null;\n\t  } else {\n\t    // Try to find the previously-selected item in the current set of items.\n\t    var indexInCurrentItems = Array.prototype.indexOf.call(items, previousSelectedItem);\n\t    var previousSelectedIndex = element.selectedIndex;\n\t    if (indexInCurrentItems < 0) {\n\t      // Previously-selected item was removed from the items.\n\t      // Select the item at the same index (if it exists) or as close as possible.\n\t      var newSelectedIndex = Math.min(previousSelectedIndex, itemCount - 1);\n\t      // Select by item, since index may be the same, and we want to raise the\n\t      // selected-item-changed event.\n\t      element.selectedItem = items[newSelectedIndex];\n\t    } else if (indexInCurrentItems !== previousSelectedIndex) {\n\t      // Previously-selected item still there, but changed position.\n\t      element.selectedIndex = indexInCurrentItems;\n\t    }\n\t  }\n\t}\n\t\n\t// Following a change in selection, report whether it's now possible to\n\t// go next/previous from the given index.\n\tfunction updatePossibleNavigations(element) {\n\t  var canSelectNext = void 0;\n\t  var canSelectPrevious = void 0;\n\t  var items = element.items;\n\t  if (items == null || items.length === 0) {\n\t    // No items to select.\n\t    canSelectNext = false;\n\t    canSelectPrevious = false;\n\t  } else if (element.selectionWraps) {\n\t    // Since there are items, can always go next/previous.\n\t    canSelectNext = true;\n\t    canSelectPrevious = true;\n\t  } else {\n\t    var index = element.selectedIndex;\n\t    if (index < 0 && items.length > 0) {\n\t      // Special case. If there are items but no selection, declare that it's\n\t      // always possible to go next/previous to create a selection.\n\t      canSelectNext = true;\n\t      canSelectPrevious = true;\n\t    } else {\n\t      // Normal case: we have an index in a list that has items.\n\t      canSelectPrevious = index > 0;\n\t      canSelectNext = index < items.length - 1;\n\t    }\n\t  }\n\t  if (element.canSelectNext !== canSelectNext) {\n\t    element.canSelectNext = canSelectNext;\n\t  }\n\t  if (element.canSelectPrevious !== canSelectPrevious) {\n\t    element.canSelectPrevious = canSelectPrevious;\n\t  }\n\t}\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tvar _SingleSelectionMixin2 = __webpack_require__(7);\n\t\n\tvar _SingleSelectionMixin3 = _interopRequireDefault(_SingleSelectionMixin2);\n\t\n\tvar _symbols = __webpack_require__(3);\n\t\n\tvar _symbols2 = _interopRequireDefault(_symbols);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t/*\n\t * A very simple component to show the application of SingleSelectionMixin.\n\t *\n\t * For a more complete demo using SingleSelectionMixin, see the ListBox demo.\n\t */\n\tvar SingleSelectionDemo = function (_SingleSelectionMixin) {\n\t  _inherits(SingleSelectionDemo, _SingleSelectionMixin);\n\t\n\t  function SingleSelectionDemo() {\n\t    _classCallCheck(this, SingleSelectionDemo);\n\t\n\t    var _this = _possibleConstructorReturn(this, (SingleSelectionDemo.__proto__ || Object.getPrototypeOf(SingleSelectionDemo)).call(this));\n\t\n\t    _this.addEventListener('mousedown', function (event) {\n\t      _this[_symbols2.default.raiseChangeEvents] = true;\n\t      _this.selectedItem = event.target;\n\t      event.stopPropagation();\n\t      _this[_symbols2.default.raiseChangeEvents] = false;\n\t    });\n\t    return _this;\n\t  }\n\t\n\t  _createClass(SingleSelectionDemo, [{\n\t    key: 'attributeChangedCallback',\n\t    value: function attributeChangedCallback(attributeName, oldValue, newValue) {\n\t      if (_get(SingleSelectionDemo.prototype.__proto__ || Object.getPrototypeOf(SingleSelectionDemo.prototype), 'attributeChangedCallback', this)) {\n\t        _get(SingleSelectionDemo.prototype.__proto__ || Object.getPrototypeOf(SingleSelectionDemo.prototype), 'attributeChangedCallback', this).call(this, attributeName, oldValue, newValue);\n\t      }\n\t      if (attributeName === 'selected-index') {\n\t        this.selectedIndex = newValue;\n\t      }\n\t    }\n\t\n\t    // Map item selection to a `selected` CSS class.\n\t\n\t  }, {\n\t    key: _symbols2.default.itemSelected,\n\t    value: function value(item, selected) {\n\t      if (_get(SingleSelectionDemo.prototype.__proto__ || Object.getPrototypeOf(SingleSelectionDemo.prototype), _symbols2.default.itemSelected, this)) {\n\t        _get(SingleSelectionDemo.prototype.__proto__ || Object.getPrototypeOf(SingleSelectionDemo.prototype), _symbols2.default.itemSelected, this).call(this, item, selected);\n\t      }\n\t      item.classList.toggle('selected', selected);\n\t    }\n\t\n\t    // Simplistic implementation of items property â€”Â doesn't handle redistribution.\n\t\n\t  }, {\n\t    key: 'items',\n\t    get: function get() {\n\t      return this.children;\n\t    }\n\t  }], [{\n\t    key: 'observedAttributes',\n\t    get: function get() {\n\t      return ['selected-index'];\n\t    }\n\t  }]);\n\t\n\t  return SingleSelectionDemo;\n\t}((0, _SingleSelectionMixin3.default)(HTMLElement));\n\t\n\texports.default = SingleSelectionDemo;\n\t\n\t\n\tcustomElements.define('single-selection-demo', SingleSelectionDemo);\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// demos.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 4d6ffcd0cb8944024b16","/*\n * This is currently a demo of how multiple mixins cooperate to perform useful\n * functions.\n *\n * * The component uses ShadowTemplateMixin to populate its shadow root.\n * * A user can click on a child item, and ClickSelectionMixin will set the\n *   selected item.\n * * The SingleSelectionMixin will track the selected item, and map that to\n *   changes in the selection state of the selected/deselected items.\n * * The SelectionAriaMixin will reflect an item's selection state using ARIA\n *   attributes to support assistive devices like screen readers.\n *\n * This demo will eventually evolve into a complete list box component, but\n * at the moment omits many features, including support for Page Up/Page Down\n * keys, keeping the selected item in view, the ability to select an item\n * by typing its initial characters, and support for slot elements as children.\n */\n\n\nimport ClickSelectionMixin from '../../elix-mixins/src/ClickSelectionMixin';\nimport SelectionAriaMixin from '../../elix-mixins/src/SelectionAriaMixin';\nimport ShadowTemplateMixin from '../../elix-mixins/src/ShadowTemplateMixin';\nimport SingleSelectionMixin from '../../elix-mixins/src/SingleSelectionMixin';\nimport symbols from '../../elix-mixins/src/symbols';\n\n\n// We want to apply a number of mixin functions to HTMLElement.\nconst mixins = [\n  ClickSelectionMixin,\n  SelectionAriaMixin,\n  ShadowTemplateMixin,\n  SingleSelectionMixin\n];\n\n// The mixins are functions, so an efficient way to apply them all is with\n// reduce. This is just function composition. We end up with a base class we\n// can extend below.\nconst base = mixins.reduce((cls, mixin) => mixin(cls), HTMLElement);\n\n\n/**\n * A simple single-selection list box.\n *\n * This uses the base class we just created above, and adds in the behavior\n * unique to this list box element. As it turns out, much of this behavior is\n * also interesting to other components, and will eventually get factored into\n * other mixins.\n *\n * @extends HTMLElement\n * @mixes ClickSelectionMixin\n * @mixes SelectionAriaMixin\n * @mixes ShadowTemplateMixin\n * @mixes SingleSelectionMixin\n */\nclass ListBox extends base {\n\n  constructor() {\n    super();\n\n    // Simplistic keyboard handling for Left/Right and Up/Down keys.\n    this.addEventListener('keydown', event => {\n      this[symbols.raiseChangeEvents] = true;\n      let handled = false;\n      switch(event.keyCode) {\n        case 37: // Left\n        case 38: // Up\n          handled = this.selectPrevious();\n          break;\n        case 39: // Right\n        case 40: // Down\n          handled = this.selectNext();\n          break;\n      }\n      if (handled) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n      this[symbols.raiseChangeEvents] = false;\n    });\n\n    // The list needs to initialize any items it starts with by invoking the\n    // itemsChanged method. Mixins like the ARIA mixin will then use that signal\n    // to apply attributes to each item, as well as to the list element itself.\n    // For now, we invoke the method manually, but eventually we'll want a mixin\n    // to handle this common need. Because the Custom Element spec prevents an\n    // element from modifying itself in its own constructor, we do so in\n    // timeout.\n    setTimeout(() => {\n      this[symbols.itemsChanged]();\n    });\n  }\n\n  // Map attribute changes to the corresponding property.\n  attributeChangedCallback(attributeName, oldValue, newValue) {\n    if (super.attributeChangedCallback) { super.attributeChangedCallback(attributeName, oldValue, newValue); }\n    if (attributeName === 'selected-index') {\n      this.selectedIndex = parseInt(newValue);\n    }\n  }\n\n  connectedCallback() {\n    if (super.connectedCallback) { super.connectedCallback(); }\n    // Set a default tabindex so that the element can receive focus. That lets\n    // us support keyboard selection. We take care to avoid ovewritting any\n    // tabindex that's explicitly set on the list element.\n    if (this.getAttribute('tabindex') == null && this[symbols.defaults].tabindex !== null) {\n      this.setAttribute('tabindex', this[symbols.defaults].tabindex);\n    }\n  }\n\n  // We define a collection of default property values which can be set in\n  // the constructor or connectedCallback. Defining the actual default values\n  // in those calls would complicate things if a subclass someday wants to\n  // define its own default value.\n  get [symbols.defaults]() {\n    const defaults = super[symbols.defaults] || {};\n    // The default tab index is 0 (document order).\n    defaults.tabindex = 0;\n    return defaults;\n  }\n\n  // Map item selection to a `selected` CSS class.\n  [symbols.itemSelected](item, selected) {\n    if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    item.classList.toggle('selected', selected);\n  }\n\n  // Simplistic implementation of an items property so that SingleSelectionMixin\n  // has items to work with. This doesn't handle Shadow DOM redistribution, so\n  // if someone puts a slot element inside the list, it won't behave as\n  // expected.\n  get items() {\n    return this.children;\n  }\n\n  // A simplistic implementation of itemsChanged. A real implementation\n  // would also need to track changes in the set of children, and invoke\n  // itemAdded for new children.\n  [symbols.itemsChanged]() {\n    Array.prototype.forEach.call(this.items, child => {\n      this[symbols.itemAdded](child);\n    });\n  }\n\n  // Tell the browser which attributes we want to handle.\n  static get observedAttributes() {\n    return ['selected-index'];\n  }\n\n  // Define a template that will be stamped into the Shadow DOM by the\n  // ShadowTemplateMixin.\n  get [symbols.template]() {\n    return `\n      <style>\n      :host {\n        border: 1px solid gray;\n        box-sizing: border-box;\n        cursor: default;\n        display: flex;\n        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n      }\n\n      #itemsContainer {\n        flex: 1;\n        -webkit-overflow-scrolling: touch;\n        overflow-y: scroll; /* for momentum scrolling */\n      }\n\n      #itemsContainer ::slotted(*) {\n        cursor: default;\n        padding: 0.25em;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        user-select: none;\n      }\n\n      #itemsContainer ::slotted(.selected) {\n        background: var(--elix-selected-background, highlight);\n        color: var(--elix-selected-color, highlighttext);\n      }\n      </style>\n\n      <div id=\"itemsContainer\" role=\"none\">\n        <slot></slot>\n      </div>\n    `;\n  }\n\n}\n\n\ncustomElements.define('sample-list-box', ListBox);\nexport default ListBox;\n\n\n\n// WEBPACK FOOTER //\n// ./elements/demos/src/ListBox.js","import symbols from './symbols';\n\n\n/**\n * Mixin which maps a click (actually, a mousedown) to a selection.\n *\n * This simple mixin is useful in list box-like elements, where a click on a\n * list item implicitly selects it.\n *\n * The standard use for this mixin is in list-like elements. Native list\n * boxes don't appear to be consistent with regard to whether they select\n * on mousedown or click/mouseup. This mixin assumes the use of mousedown.\n * On touch devices, that event appears to trigger when the touch is *released*.\n *\n * Much has been written about how to ensure \"fast tap\" behavior on mobile\n * devices. This mixin makes a very straightforward use of a standard event, and\n * this appears to perform well on mobile devices when, e.g., the viewport is\n * configured with `width=device-width`.\n *\n * This mixin expects the component to provide an `items` property. It also\n * expects the component to define a `selectedItem` property; you can provide\n * that yourself, or use [SingleSelectionMixin](SingleSelectionMixin.md).\n *\n * If the component receives a clicks that doesn't correspond to an item (e.g.,\n * the user clicks on the element background visible between items), the\n * selection will be removed. However, if the component defines a\n * `selectionRequired` and this is true, a background click will *not* remove\n * the selection.\n *\n * @module ClickSelectionMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function ClickSelectionMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class ClickSelection extends base {\n\n    constructor() {\n      super();\n      this.addEventListener('mousedown', event => {\n\n        this[symbols.raiseChangeEvents] = true;\n\n        // If the item clicked on is a button, the event seems to be raised in\n        // phase 2 (AT_TARGET) â€” but the event target will be the component, not\n        // the item that was clicked on.\n        const target = event.target === this ?\n          event.path[0] : // Event target isn't the item, so get it from path.\n          event.target;\n\n        // Find which item was clicked on and, if found, select it. For elements\n        // which don't require a selection, a background click will determine\n        // the item was null, in which we case we'll remove the selection.\n        const item = itemForTarget(this, target);\n        if (item || !this.selectionRequired) {\n\n          if (!('selectedItem' in this)) {\n            console.warn(`ClickSelectionMixin expects a component to define a \"selectedItem\" property.`);\n          } else {\n            this.selectedItem = item;\n          }\n\n          // We don't call preventDefault here. The default behavior for\n          // mousedown includes setting keyboard focus if the element doesn't\n          // already have the focus, and we want to preserve that behavior.\n          event.stopPropagation();\n        }\n\n        this[symbols.raiseChangeEvents] = false;\n      });\n    }\n\n  }\n\n  return ClickSelection;\n}\n\n\n/*\n * Return the list item that is, or contains, the indicated target element.\n * Return null if not found.\n */\nfunction itemForTarget(listElement, target) {\n  const items = listElement.items;\n  const itemCount = items ? items.length : 0;\n  for (let i = 0; i < itemCount; i++) {\n    let item = items[i];\n    if (item === target || item.contains(target)) {\n      return item;\n    }\n  }\n  return null;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/ClickSelectionMixin.js","import Symbol from './Symbol';\n\n\n/**\n * A collection of (potentially polyfilled) Symbol objects for standard\n * component properties and methods.\n *\n * These Symbol objects are used to allow mixins and a component to internally\n * communicate, without exposing these properties and methods in the component's\n * public API.\n *\n * To use these Symbol objects in your own component, include this module and\n * then create a property or method whose key is the desired Symbol.\n *\n *     import 'SingleSelectionMixin' from 'elix-mixins/src/SingleSelectionMixin';\n *     import 'symbols' from 'elix-mixins/src/symbols';\n *\n *     class MyElement extends SingleSelectionMixin(HTMLElement) {\n *       [symbols.itemSelected](item, selected) {\n *         // This will be invoked whenever an item is selected/deselected.\n *       }\n *     }\n *\n * @module symbols\n */\nconst symbols = {\n\n  /**\n   * Symbol for the `defaults` property.\n   *\n   * This property can be used to set or override defaults that will be applied\n   * to a new component instance. When implementing this property, take care to\n   * first acquire any defaults defined by the superclass. The standard idiom is\n   * as follows:\n   *\n   *     get [symbols.defaults]() {\n   *       const defaults = super[symbols.defaults] || {};\n   *       // Set or override default values here\n   *       defaults.customProperty = false;\n   *       return defaults;\n   *     }\n   *\n   * @var {object} defaults\n   */\n  defaults: Symbol('defaults'),\n\n  /**\n   * Symbol for the `raiseChangeEvents` property.\n   *\n   * This property is used by mixins to determine whether they should raise\n   * property change events. The standard HTML pattern is to only raise such\n   * events in response to direct user interactions. For a detailed discussion\n   * of this point, see the Gold Standard checklist item for\n   * [Propery Change Events](https://github.com/webcomponents/gold-standard/wiki/Property%20Change%20Events).\n   *\n   * The above article describes a pattern for using a flag to track whether\n   * work is being performed in response to internal component activity, and\n   * whether the component should therefore raise property change events.\n   * This `raiseChangeEvents` symbol is a shared flag used for that purpose by\n   * all Elix mixins and components. Sharing this flag ensures that internal\n   * activity (e.g., a UI event listener) in one mixin can signal other mixins\n   * handling affected properties to raise change events.\n   *\n   * All UI event listeners (and other forms of internal handlers, such as\n   * timeouts and async network handlers) should set `raiseChangeEvents` to\n   * `true` at the start of the event handler, then `false` at the end:\n   *\n   *     this.addEventListener('click', event => {\n   *       this[symbols.raiseChangeEvents] = true;\n   *       // Do work here, possibly setting properties, like:\n   *       this.foo = 'Hello';\n   *       this[symbols.raiseChangeEvents] = false;\n   *     });\n   *\n   * Elsewhere, property setters that raise change events should only do so it\n   * this property is `true`:\n   *\n   *     set foo(value) {\n   *       // Save foo value here, do any other work.\n   *       if (this[symbols.raiseChangeEvents]) {\n   *         const event = new CustomEvent('foo-changed');\n   *         this.dispatchEvent(event);\n   *       }\n   *     }\n   *\n   * In this way, programmatic attempts to set the `foo` property will not\n   * trigger the `foo-changed` event, but UI interactions that update that\n   * property will cause those events to be raised.\n   *\n   * @var {boolean} raiseChangeEvents\n   */\n  raiseChangeEvents: Symbol('raiseChangeEvents'),\n\n  /**\n   * Symbol for the `itemAdded` method.\n   *\n   * This method is invoked when a new item is added to a list.\n   *\n   * @function itemAdded\n   * @param {HTMLElement} item - the item being selected/deselected\n   */\n  itemAdded: Symbol('itemAdded'),\n\n  /**\n   * Symbol for the `itemsChanged` method.\n   *\n   * This method is invoked when the underlying contents change. It is also\n   * invoked on component initialization â€“ since the items have \"changed\" from\n   * being nothing.\n   *\n   * @function itemsChanged\n   */\n  itemsChanged: Symbol('itemsChanged'),\n\n  /**\n   * Symbol for the `itemSelected` method.\n   *\n   * This method is invoked when an item becomes selected or deselected.\n   *\n   * @function itemSelected\n   * @param {HTMLElement} item - the item being selected/deselected\n   * @param {boolean} selected - true if the item is selected, false if not\n   */\n  itemSelected: Symbol('itemSelected'),\n\n  /**\n   * Symbol for the `template` property.\n   *\n   * This property returns a component's template.\n   *\n   * @type {string|HTMLTemplateElement}\n   */\n  template: Symbol('template')\n};\n\nexport default symbols;\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/symbols.js","/* The number of fake symbols we've served up */\nlet count = 0;\n\nfunction uniqueString(description) {\n  return `_${description}${count++}`;\n}\n\nconst symbolFunction = typeof window.Symbol === 'function' ?\n  window.Symbol :\n  uniqueString;\n\n/**\n * Polyfill for ES6 symbol class.\n *\n * Mixins and component classes often want to associate private data with an\n * element instance, but JavaScript does not have direct support for true\n * private properties. One approach is to use the\n * [Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)\n * data type to set and retrieve data on an element.\n *\n * Unfortunately, the Symbol type is not available in Internet Explorer 11. In\n * lieu of returning a true Symbol, this polyfill returns a different string\n * each time it is called.\n *\n * Usage:\n *\n *     const fooSymbol = Symbol('foo');\n *\n *     class MyElement extends HTMLElement {\n *       get foo() {\n *         return this[fooSymbol];\n *       }\n *       set foo(value) {\n *         this[fooSymbol] = value;\n *       }\n *     }\n *\n * In IE 11, this sample will \"hide\" data behind an instance property that looks\n * like this._foo0. The underscore is meant to reduce (not eliminate) potential\n * accidental access, and the unique number at the end is mean to avoid (not\n * eliminate) naming conflicts.\n *\n * @function Symbol\n * @param {string} description - A string to identify the symbol when debugging\n * @returns {Symbol|string} â€” A Symbol (in ES6 browsers) or unique string ID (in\n * ES5).\n */\nexport default symbolFunction;\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/Symbol.js","import symbols from './symbols';\n\n\n// Used to assign unique IDs to item elements without IDs.\nlet idCount = 0;\n\n\n/**\n * Mixin which treats the selected item in a list as the active item in ARIA\n * accessibility terms.\n *\n * Handling ARIA selection state properly is actually quite complex:\n *\n * * The items in the list need to be indicated as possible items via an ARIA\n *   `role` attribute value such as \"option\".\n * * The selected item need to be marked as selected by setting the item's\n *   `aria-selected` attribute to true *and* the other items need be marked as\n *   *not* selected by setting `aria-selected` to false.\n * * The outermost element with the keyboard focus needs to have attributes\n *   set on it so that the selection is knowable at the list level via the\n *   `aria-activedescendant` attribute.\n * * Use of `aria-activedescendant` in turn requires that all items in the\n *   list have ID attributes assigned to them.\n *\n * This mixin tries to address all of the above requirements. To that end,\n * this mixin will assign generated IDs to any item that doesn't already have\n * an ID.\n *\n * ARIA relies on elements to provide `role` attributes. This mixin will apply\n * a default role of \"listbox\" on the outer list if it doesn't already have an\n * explicit role. Similarly, this mixin will apply a default role of \"option\"\n * to any list item that does not already have a role specified.\n *\n * This mixin expects a set of members that manage the state of the selection:\n * `[symbols.itemSelected]`, `[symbols.itemAdded]`, and `selectedItem`. You can\n * supply these yourself, or do so via\n * [SingleSelectionMixin](SingleSelectionMixin.md).\n *\n * @module\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function (base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class SelectionAria extends base {\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n\n      // Set default ARIA role for the overall component.\n      if (this.getAttribute('role') == null && this[symbols.defaults].role) {\n        this.setAttribute('role', this[symbols.defaults].role);\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.role = 'listbox';\n      defaults.itemRole = 'option';\n      return defaults;\n    }\n\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n\n      if (!item.getAttribute('role')) {\n        // Assign a default ARIA role for an individual item.\n        item.setAttribute('role', this[symbols.defaults].itemRole);\n      }\n\n      // Ensure each item has an ID so we can set aria-activedescendant on the\n      // overall list whenever the selection changes.\n      //\n      // The ID will take the form of a base ID plus a unique integer. The base\n      // ID will be incorporate the component's own ID. E.g., if a component has\n      // ID \"foo\", then its items will have IDs that look like \"_fooOption1\". If\n      // the compnent has no ID itself, its items will get IDs that look like\n      // \"_option1\". Item IDs are prefixed with an underscore to differentiate\n      // them from manually-assigned IDs, and to minimize the potential for ID\n      // conflicts.\n      if (!item.id) {\n        const baseId = this.id ?\n            \"_\" + this.id + \"Option\" :\n            \"_option\";\n        item.id = baseId + idCount++;\n      }\n    }\n\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n      item.setAttribute('aria-selected', selected);\n      const itemId = item.id;\n      if (itemId && selected) {\n        this.setAttribute('aria-activedescendant', itemId);\n      }\n    }\n\n    get selectedItem() {\n      return super.selectedItem;\n    }\n    set selectedItem(item) {\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n      if (item == null) {\n        // Selection was removed.\n        this.removeAttribute('aria-activedescendant');\n      }\n    }\n\n  }\n\n  return SelectionAria;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/SelectionAriaMixin.js","import symbols from '../src/symbols';\n\n\n// A cache of processed templates.\n//\n// We maintain this as a map keyed by element tag (localName). We could store\n// an element's processed template on its element prototype. One scenario that\n// wouldn't support would be registration of the same constructor under multiple\n// tag names, which was a (perhaps theoretical) use case for Custom Elements.\n//\nconst mapTagToTemplate = {};\n\n\n/**\n * Mixin which adds stamping a template into a Shadow DOM subtree upon component\n * instantiation.\n *\n * To use this mixin, define a `template` property as a string or HTML\n * `<template>` element:\n *\n *     class MyElement extends ShadowTemplateMixin(HTMLElement) {\n *       get [symbols.template]() {\n *         return `Hello, <em>world</em>.`;\n *       }\n *     }\n *\n * When your component class is instantiated, a shadow root will be created on\n * the instance, and the contents of the template will be cloned into the\n * shadow root. If your component does not define a `template` property, this\n * mixin has no effect.\n *\n * For the time being, this extension retains support for Shadow DOM v0. That\n * will eventually be deprecated as browsers (and the Shadow DOM polyfill)\n * implement Shadow DOM v1.\n *\n * @module ShadowTemplateMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function ShadowTemplateMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class ShadowTemplate extends base {\n\n    /*\n     * If the component defines a template, a shadow root will be created on the\n     * component instance, and the template stamped into it.\n     */\n    constructor() {\n      super();\n\n      const tag = this.localName;\n      let template = mapTagToTemplate[tag];\n\n      // See if we've already processed a template for this tag.\n      if (!template) {\n        // This is the first time we've created an instance of this tag.\n\n        // Get the template and perform initial processing.\n        template = this[symbols.template];\n        if (!template) {\n          console.warn(`ShadowTemplateMixin expects a component to define a template property with [symbols.template].`);\n          return;\n        }\n\n        if (typeof template === 'string') {\n          // Upgrade plain string to real template.\n          const templateText = template;\n          template = document.createElement('template');\n          template.innerHTML = templateText;\n        }\n\n        if (window.ShadyCSS) {\n          // Let the CSS polyfill do its own initialization.\n          window.ShadyCSS.prepareTemplate(template, tag);\n        }\n\n        // Store this for the next time we create the same type of element.\n        mapTagToTemplate[tag] = template;\n      }\n\n      // Stamp the template into a new shadow root.\n      const root = this.attachShadow({ mode: 'open' });\n      const clone = document.importNode(template.content, true);\n      root.appendChild(clone);\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      if (window.ShadyCSS) {\n        window.ShadyCSS.applyStyle(this);\n      }\n    }\n\n  }\n\n  return ShadowTemplate;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/ShadowTemplateMixin.js","import Symbol from './Symbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst canSelectNextSymbol = Symbol('canSelectNext');\nconst canSelectPreviousSymbol = Symbol('canSelectPrevious');\nconst selectionRequiredSymbol = Symbol('selectionRequired');\nconst selectionWrapsSymbol = Symbol('selectionWraps');\n\n// We want to expose both selectedIndex and selectedItem as independent\n// properties but keep them in sync. This allows a component user to reference\n// the selection by whatever means is most natural for their situation.\n//\n// To efficiently keep these properties in sync, we track \"external\" and\n// \"internal\" references for each property:\n//\n// The external index or item is the one we report to the outside world when\n// asked for selection.  When handling a change to index or item, we update the\n// external reference as soon as possible, so that if anyone immediately asks\n// for the current selection, they will receive a stable answer.\n//\n// The internal index or item tracks whichever index or item last received the\n// full set of processing. Processing includes raising a change event for the\n// new value. Once we've begun that processing, we store the new value as the\n// internal value to indicate we've handled it.\n//\nconst externalSelectedIndexSymbol = Symbol('externalSelectedIndex');\nconst externalSelectedItemSymbol = Symbol('externalSelectedItem');\nconst internalSelectedIndexSymbol = Symbol('internalSelectedIndex');\nconst internalSelectedItemSymbol = Symbol('internalSelectedItem');\n\n\n/**\n * Mixin which adds single-selection semantics for items in a list.\n *\n * This mixin expects a component to provide an `items` Array or NodeList of\n * all elements in the list.\n *\n * This mixin tracks a single selected item in the list, and provides means to\n * get and set that state by item position (`selectedIndex`) or item identity\n * (`selectedItem`). The selection can be moved in the list via the methods\n * `selectFirst`, `selectLast`, `selectNext`, and `selectPrevious`.\n *\n * This mixin does not produce any user-visible effects to represent\n * selection.\n *\n * @module SingleSelectionMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function SingleSelectionMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class SingleSelection extends base {\n\n    constructor() {\n      super();\n      // Set defaults.\n      if (typeof this.selectionRequired === 'undefined') {\n        this.selectionRequired = this[symbols.defaults].selectionRequired;\n      }\n      if (typeof this.selectionWraps === 'undefined') {\n        this.selectionWraps = this[symbols.defaults].selectionWraps;\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the next item, false if not (the\n     * selected item is the last item in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectNext() {\n      return this[canSelectNextSymbol];\n    }\n    set canSelectNext(canSelectNext) {\n      const changed = canSelectNext !== this[canSelectNextSymbol];\n      this[canSelectNextSymbol] = canSelectNext;\n      if ('canSelectNext' in base.prototype) { super.canSelectNext = canSelectNext; }\n      if (this[symbols.raiseChangeEvents] && changed) {\n        this.dispatchEvent(new CustomEvent('can-select-next-changed'));\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the previous item, false if not\n     * (the selected item is the first one in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectPrevious() {\n      return this[canSelectPreviousSymbol];\n    }\n    set canSelectPrevious(canSelectPrevious) {\n      const changed = canSelectPrevious !== this[canSelectPreviousSymbol];\n      this[canSelectPreviousSymbol] = canSelectPrevious;\n      if ('canSelectPrevious' in base.prototype) { super.canSelectPrevious = canSelectPrevious; }\n      if (this[symbols.raiseChangeEvents] && changed) {\n        this.dispatchEvent(new CustomEvent('can-select-previous-changed'));\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.selectionRequired = false;\n      defaults.selectionWraps = false;\n      return defaults;\n    }\n\n    /**\n     * Handle a new item being added to the list.\n     *\n     * The default implementation of this method simply sets the item's\n     * selection state to false.\n     *\n     * @param {HTMLElement} item - the item being added\n     */\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n      this[symbols.itemSelected](item, item === this.selectedItem);\n    }\n\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      // In case selected item changed position or was removed.\n      trackSelectedItem(this);\n\n      // In case the change in items affected which navigations are possible.\n      updatePossibleNavigations(this);\n    }\n\n    /**\n     * Apply the indicate selection state to the item.\n     *\n     * The default implementation of this method does nothing. User-visible\n     * effects will typically be handled by other mixins.\n     *\n     * @param {HTMLElement} item - the item being selected/deselected\n     * @param {boolean} selected - true if the item is selected, false if not\n     */\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    }\n\n    /**\n     * The index of the item which is currently selected.\n     *\n     * The setter expects an integer or a string representing an integer.\n     *\n     * A `selectedIndex` of -1 indicates there is no selection. Setting this\n     * property to -1 will remove any existing selection.\n     *\n     * @type {number}\n     */\n    get selectedIndex() {\n      return this[externalSelectedIndexSymbol] != null ?\n        this[externalSelectedIndexSymbol] :\n        -1;\n    }\n    set selectedIndex(index) {\n      // See notes at top about internal vs. external copies of this property.\n      const changed = index !== this[internalSelectedIndexSymbol];\n      let item;\n      let parsedIndex = parseInt(index);\n      if (parsedIndex !== this[externalSelectedIndexSymbol]) {\n        // Store the new index and the corresponding item.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        if (!(hasItems && parsedIndex >= 0 && parsedIndex < items.length)) {\n          parsedIndex = -1; // No item at that index.\n        }\n        this[externalSelectedIndexSymbol] = parsedIndex;\n        item = hasItems && parsedIndex >= 0 ? items[parsedIndex] : null;\n        this[externalSelectedItemSymbol] = item;\n      } else {\n        item = this[externalSelectedItemSymbol];\n      }\n\n      // Now let super do any work.\n      if ('selectedIndex' in base.prototype) { super.selectedIndex = index; }\n\n      if (changed) {\n        // The selected index changed.\n        this[internalSelectedIndexSymbol] = parsedIndex;\n\n        if (this[symbols.raiseChangeEvents]) {\n          const event = new CustomEvent('selected-index-changed', {\n            detail: {\n              selectedIndex: parsedIndex,\n              value: parsedIndex // for Polymer binding. TODO: Verify still necessary\n            }\n          });\n          this.dispatchEvent(event);\n        }\n      }\n\n      if (this[internalSelectedItemSymbol] !== item) {\n        // Update selectedItem property so it can have its own effects.\n        this.selectedItem = item;\n      }\n    }\n\n    /**\n     * The currently selected item, or null if there is no selection.\n     *\n     * Setting this property to null deselects any currently-selected item.\n     * Setting this property to an object that is not in the list has no effect.\n     *\n     * TODO: Even if selectionRequired, can still explicitly set selectedItem to null.\n     * TODO: If selectionRequired, leave selection alone?\n     *\n     * @type {object}\n     */\n    get selectedItem() {\n      return this[externalSelectedItemSymbol] || null;\n    }\n    set selectedItem(item) {\n      // See notes at top about internal vs. external copies of this property.\n      const previousSelectedItem = this[internalSelectedItemSymbol];\n      const changed = item !== previousSelectedItem;\n      let index;\n      if (item !== this[externalSelectedItemSymbol]) {\n        // Store item and look up corresponding index.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        index = hasItems ? Array.prototype.indexOf.call(items, item) : -1;\n        this[externalSelectedIndexSymbol] = index;\n        if (index < 0) {\n          item = null; // The indicated item isn't actually in `items`.\n        }\n        this[externalSelectedItemSymbol] = item;\n      } else {\n        index = this[externalSelectedIndexSymbol];\n      }\n\n      // Now let super do any work.\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n\n      if (changed) {\n        // The selected item changed.\n        this[internalSelectedItemSymbol] = item;\n\n        if (previousSelectedItem) {\n          // Update selection state of old item.\n          this[symbols.itemSelected](previousSelectedItem, false);\n        }\n        if (item) {\n          // Update selection state to new item.\n          this[symbols.itemSelected](item, true);\n        }\n\n        updatePossibleNavigations(this);\n\n        if (this[symbols.raiseChangeEvents]) {\n          const event = new CustomEvent('selected-item-changed', {\n            detail: {\n              selectedItem: item,\n              value: item // for Polymer binding\n            }\n          });\n          this.dispatchEvent(event);\n        }\n      }\n\n      if (this[internalSelectedIndexSymbol] !== index) {\n        // Update selectedIndex property so it can have its own effects.\n        this.selectedIndex = index;\n      }\n    }\n\n    /**\n     * Select the first item in the list.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectFirst() {\n      if (super.selectFirst) { super.selectFirst(); }\n      return selectIndex(this, 0);\n    }\n\n    /**\n     * True if the list should always have a selection (if it has items).\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionRequired() {\n      return this[selectionRequiredSymbol];\n    }\n    set selectionRequired(selectionRequired) {\n      const parsed = String(selectionRequired) === 'true';\n      const changed = parsed !== this[selectionRequiredSymbol];\n      this[selectionRequiredSymbol] = parsed;\n      if ('selectionRequired' in base.prototype) { super.selectionRequired = selectionRequired; }\n      if (changed) {\n        if (this[symbols.raiseChangeEvents]) {\n          const event = new CustomEvent('selection-required-changed');\n          this.dispatchEvent(event);\n        }\n        if (selectionRequired) {\n          trackSelectedItem(this);\n        }\n      }\n    }\n\n    /**\n     * True if selection navigations wrap from last to first, and vice versa.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionWraps() {\n      return this[selectionWrapsSymbol];\n    }\n    set selectionWraps(selectionWraps) {\n      const parsed = String(selectionWraps) === 'true';\n      const changed = parsed !== this[selectionWrapsSymbol];\n      this[selectionWrapsSymbol] = parsed;\n      if ('selectionWraps' in base.prototype) { super.selectionWraps = selectionWraps; }\n      if (changed) {\n        if (this[symbols.raiseChangeEvents]) {\n          const event = new CustomEvent('selection-wraps-changed');\n          this.dispatchEvent(event);\n        }\n        updatePossibleNavigations(this);\n      }\n    }\n\n    /**\n     * Select the last item in the list.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectLast() {\n      if (super.selectLast) { super.selectLast(); }\n      return selectIndex(this, this.items.length - 1);\n    }\n\n    /**\n     * Select the next item in the list.\n     *\n     * If the list has no selection, the first item will be selected.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectNext() {\n      if (super.selectNext) { super.selectNext(); }\n      return selectIndex(this, this.selectedIndex + 1);\n    }\n\n    /**\n     * Select the previous item in the list.\n     *\n     * If the list has no selection, the last item will be selected.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectPrevious() {\n      if (super.selectPrevious) { super.selectPrevious(); }\n      const newIndex = this.selectedIndex < 0 ?\n        this.items.length - 1 :     // No selection yet; select last item.\n        this.selectedIndex - 1;\n      return selectIndex(this, newIndex);\n    }\n\n    /**\n     * Fires when the canSelectNext property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event can-select-next-changed\n     */\n\n    /**\n     * Fires when the canSelectPrevious property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event can-select-previous-changed\n     */\n\n    /**\n     * Fires when the selectedIndex property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event selected-index-changed\n     * @param {number} detail.selectedIndex The new selected index.\n     */\n\n    /**\n     * Fires when the selectedItem property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event selected-item-changed\n     * @param {HTMLElement} detail.selectedItem The new selected item.\n     */\n\n  }\n\n  return SingleSelection;\n}\n\n\n// Ensure the given index is within bounds, and select it if it's not already\n// selected.\nfunction selectIndex(element, index) {\n\n  const items = element.items;\n  if (items == null) {\n    // Nothing to select.\n    return false;\n  }\n\n  const count = items.length;\n  const boundedIndex = element.selectionWraps ?\n    // JavaScript mod doesn't handle negative numbers the way we want to wrap.\n    // See http://stackoverflow.com/a/18618250/76472\n    ((index % count) + count) % count :\n\n    // Keep index within bounds of array.\n    Math.max(Math.min(index, count - 1), 0);\n\n  const previousIndex = element.selectedIndex;\n  if (previousIndex !== boundedIndex) {\n    element.selectedIndex = boundedIndex;\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// Following a change in the set of items, or in the value of the\n// `selectionRequired` property, reacquire the selected item. If it's moved,\n// update `selectedIndex`. If it's been removed, and a selection is required,\n// try to select another item.\nfunction trackSelectedItem(element) {\n\n  const items = element.items;\n  const itemCount = items ? items.length : 0;\n\n  const previousSelectedItem = element.selectedItem;\n  if (!previousSelectedItem) {\n    // No item was previously selected.\n    if (element.selectionRequired) {\n      // Select the first item by default.\n      element.selectedIndex = 0;\n    }\n  } else if (itemCount === 0) {\n    // We've lost the selection, and there's nothing left to select.\n    element.selectedItem = null;\n  } else {\n    // Try to find the previously-selected item in the current set of items.\n    const indexInCurrentItems = Array.prototype.indexOf.call(items, previousSelectedItem);\n    const previousSelectedIndex = element.selectedIndex;\n    if (indexInCurrentItems < 0) {\n      // Previously-selected item was removed from the items.\n      // Select the item at the same index (if it exists) or as close as possible.\n      const newSelectedIndex = Math.min(previousSelectedIndex, itemCount - 1);\n      // Select by item, since index may be the same, and we want to raise the\n      // selected-item-changed event.\n      element.selectedItem = items[newSelectedIndex];\n    } else if (indexInCurrentItems !== previousSelectedIndex) {\n      // Previously-selected item still there, but changed position.\n      element.selectedIndex = indexInCurrentItems;\n    }\n  }\n}\n\n// Following a change in selection, report whether it's now possible to\n// go next/previous from the given index.\nfunction updatePossibleNavigations(element) {\n  let canSelectNext;\n  let canSelectPrevious;\n  const items = element.items;\n  if (items == null || items.length === 0) {\n    // No items to select.\n    canSelectNext = false;\n    canSelectPrevious = false;\n  } else if (element.selectionWraps) {\n    // Since there are items, can always go next/previous.\n    canSelectNext = true;\n    canSelectPrevious = true;\n  } else {\n    const index = element.selectedIndex;\n    if (index < 0 && items.length > 0) {\n      // Special case. If there are items but no selection, declare that it's\n      // always possible to go next/previous to create a selection.\n      canSelectNext = true;\n      canSelectPrevious = true;\n    } else {\n      // Normal case: we have an index in a list that has items.\n      canSelectPrevious = (index > 0);\n      canSelectNext = (index < items.length - 1);\n    }\n  }\n  if (element.canSelectNext !== canSelectNext) {\n    element.canSelectNext = canSelectNext;\n  }\n  if (element.canSelectPrevious !== canSelectPrevious) {\n    element.canSelectPrevious = canSelectPrevious;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/SingleSelectionMixin.js","import SingleSelectionMixin from '../../elix-mixins/src/SingleSelectionMixin';\nimport symbols from '../../elix-mixins/src/symbols';\n\n\n/*\n * A very simple component to show the application of SingleSelectionMixin.\n *\n * For a more complete demo using SingleSelectionMixin, see the ListBox demo.\n */\nexport default class SingleSelectionDemo extends SingleSelectionMixin(HTMLElement) {\n\n  constructor() {\n    super();\n    this.addEventListener('mousedown', event => {\n      this[symbols.raiseChangeEvents] = true;\n      this.selectedItem = event.target;\n      event.stopPropagation();\n      this[symbols.raiseChangeEvents] = false;\n    });\n  }\n\n  attributeChangedCallback(attributeName, oldValue, newValue) {\n    if (super.attributeChangedCallback) { super.attributeChangedCallback(attributeName, oldValue, newValue); }\n    if (attributeName === 'selected-index') {\n      this.selectedIndex = newValue;\n    }\n  }\n\n  // Map item selection to a `selected` CSS class.\n  [symbols.itemSelected](item, selected) {\n    if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    item.classList.toggle('selected', selected);\n  }\n\n  // Simplistic implementation of items property â€”Â doesn't handle redistribution.\n  get items() {\n    return this.children;\n  }\n\n  static get observedAttributes() {\n    return ['selected-index'];\n  }\n\n}\n\n\ncustomElements.define('single-selection-demo', SingleSelectionDemo);\n\n\n\n// WEBPACK FOOTER //\n// ./elements/demos/src/SingleSelectionDemo.js"],"sourceRoot":""}