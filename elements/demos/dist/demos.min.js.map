{"version":3,"sources":["webpack:///demos.min.js","webpack:///webpack/bootstrap 36937516cb41fc4ca729","webpack:///./elements/demos/src/ListBox.js","webpack:///./elements/elix-mixins/src/ChildrenContentMixin.js","webpack:///./elements/elix-mixins/src/content.js","webpack:///./elements/elix-mixins/src/microtask.js","webpack:///./elements/elix-mixins/src/symbols.js","webpack:///./elements/elix-mixins/src/Symbol.js","webpack:///./elements/elix-mixins/src/ClickSelectionMixin.js","webpack:///./elements/elix-mixins/src/ContentItemsMixin.js","webpack:///./elements/elix-mixins/src/DirectionSelectionMixin.js","webpack:///./elements/elix-mixins/src/KeyboardDirectionMixin.js","webpack:///./elements/elix-mixins/src/KeyboardMixin.js","webpack:///./elements/elix-mixins/src/KeyboardPagedSelectionMixin.js","webpack:///./elements/elix-mixins/src/defaultScrollTarget.js","webpack:///./elements/elix-mixins/src/KeyboardPrefixSelectionMixin.js","webpack:///./elements/elix-mixins/src/constants.js","webpack:///./elements/elix-mixins/src/SelectionAriaMixin.js","webpack:///./elements/elix-mixins/src/SelectionInViewMixin.js","webpack:///./elements/elix-mixins/src/ShadowTemplateMixin.js","webpack:///./elements/elix-mixins/src/SingleSelectionMixin.js","webpack:///./elements/demos/src/SingleSelectionDemo.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","defineProperty","_createClass","defineProperties","target","props","i","length","descriptor","key","protoProps","staticProps","_set","set","object","property","receiver","desc","getOwnPropertyDescriptor","undefined","parent","getPrototypeOf","setter","_get","get","Function","getter","_ChildrenContentMixin","_ChildrenContentMixin2","_ClickSelectionMixin","_ClickSelectionMixin2","_ContentItemsMixin","_ContentItemsMixin2","_DirectionSelectionMixin","_DirectionSelectionMixin2","_KeyboardDirectionMixin","_KeyboardDirectionMixin2","_KeyboardMixin","_KeyboardMixin2","_KeyboardPagedSelectionMixin","_KeyboardPagedSelectionMixin2","_KeyboardPrefixSelectionMixin","_KeyboardPrefixSelectionMixin2","_SelectionAriaMixin","_SelectionAriaMixin2","_SelectionInViewMixin","_SelectionInViewMixin2","_ShadowTemplateMixin","_ShadowTemplateMixin2","_SingleSelectionMixin","_SingleSelectionMixin2","_symbols","_symbols2","mixins","base","reduce","cls","mixin","HTMLElement","ListBox","_base","this","apply","arguments","attributeName","oldValue","newValue","mapAttributeToProperty","selected-index","propertyName","itemSelected","item","selected","classList","toggle","defaults","orientation","changed","getAttribute","setAttribute","raiseChangeEvents","event","CustomEvent","dispatchEvent","template","customElements","define","ChildrenContentMixin","ChildrenContent","_this","_microtask2","contentChanged","shadowCreated","_this2","slots","shadowRoot","querySelectorAll","forEach","slot","addEventListener","content","_content","assignedChildren","_microtask","_toConsumableArray","arr","Array","isArray","arr2","from","element","expandAssignedNodes","children","assignedChildNodes","childNodes","assignedTextContent","strings","map","child","textContent","join","filterAuxiliaryElements","elements","auxiliaryTags","filter","Element","localName","indexOf","nodes","ElementsOnly","_ref","expanded","node","isSlot","HTMLSlotElement","assignedNodes","flatten","flattened","concat","result","microtask","callback","callbacks","push","counter","executeCallbacks","shift","document","createTextNode","observer","MutationObserver","observe","characterData","_Symbol2","_Symbol3","symbols","getItemText","goDown","goEnd","goLeft","goRight","goStart","goUp","itemAdded","itemsChanged","keydown","uniqueString","description","count","symbolFunction","window","Symbol","ClickSelectionMixin","ClickSelection","button","path","itemForTarget","selectionRequired","selectedItem","console","warn","stopPropagation","listElement","items","itemCount","contains","_interopRequireWildcard","newObj","hasOwnProperty","ContentItemsMixin","ContentItems","itemsSymbol","itemInitializedSymbol","DirectionSelectionMixin","DirectionSelection","selectNext","selectLast","selectPrevious","selectFirst","KeyboardDirectionMixin","KeyboardDirection","handled","horizontal","vertical","keyCode","metaKey","altKey","KeyboardMixin","Keyboard","preventDefault","tabindex","KeyboardPagedSelectionMixin","KeyboardPagedSelection","pageUp","pageDown","scrollOnePage","scrollTarget","_defaultScrollTarget2","getIndexOfItemAtY","y","downward","start","end","step","topOfClientArea","offsetTop","clientTop","itemIndex","itemTop","found","itemBottom","offsetHeight","itemStyle","getComputedStyle","itemPaddingTop","parseFloat","paddingTop","itemPaddingBottom","paddingBottom","contentTop","contentBottom","clientHeight","edge","scrollTop","indexOfItemAtEdge","selectedIndex","newIndex","delta","_defaultScrollTarget","defaultScrollTarget","querySelector","getScrollingParent","root","overflowY","parentNode","KeyboardPrefixSelectionMixin","KeyboardPrefixSelection","itemTextContentsSymbol","resetTypedPrefix","resetPrefix","handleBackspace","ctrlKey","which","handlePlainCharacter","String","fromCharCode","prefix","index","getIndexOfItemWithTextPrefix","settingSelectionSymbol","itemTextContents","getItemTextContents","prefixLength","itemTextContent","substr","text","toLowerCase","typedPrefixSymbol","selectItemWithTextPrefix","setPrefixTimeout","char","resetPrefixTimeout","prefixTimeoutSymbol","clearTimeout","setTimeout","_constants2","TYPING_TIMEOUT_DURATION","_constants","constants","SelectionAria","role","itemRole","baseId","idCount","itemId","removeAttribute","SelectionInView","scrollItemIntoView","scrollTargetRect","getBoundingClientRect","itemRect","bottomDelta","bottom","topDelta","top","leftDelta","left","rightDelta","right","Math","ceil","scrollLeft","ShadowTemplateMixin","ShadowTemplate","tag","mapTagToTemplate","templateText","createElement","innerHTML","ShadyCSS","prepareTemplate","attachShadow","mode","clone","importNode","appendChild","applyStyle","SingleSelectionMixin","SingleSelection","selectionWraps","trackSelectedItem","updatePossibleNavigations","selectIndex","canSelectNextSymbol","canSelectNext","canSelectPreviousSymbol","canSelectPrevious","externalSelectedIndexSymbol","internalSelectedIndexSymbol","parsedIndex","parseInt","hasItems","externalSelectedItemSymbol","detail","internalSelectedItemSymbol","previousSelectedItem","selectionRequiredSymbol","parsed","selectionWrapsSymbol","boundedIndex","max","min","previousIndex","indexInCurrentItems","previousSelectedIndex","newSelectedIndex","_SingleSelectionMixin3","SingleSelectionDemo"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAE,WACAE,GAAAJ,EACAK,QAAA,EAUA,OANAP,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,QAAA,EAGAF,EAAAD,QAvBA,GAAAD,KAqCA,OATAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,GAGAV,EAAA,KDMM,SAASI,EAAQD,EAASH,GAE/BA,EAAoB,GACpBI,EAAOD,QAAUH,EAAoB,KAKhC,SAASI,EAAQD,EAASH,GAE/B,YAgEA,SAASW,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GAEvF,QAASG,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAEhH,QAASC,GAA2BC,EAAMb,GAAQ,IAAKa,EAAQ,KAAM,IAAIC,gBAAe,4DAAgE,QAAOd,GAAyB,gBAATA,IAAqC,kBAATA,GAA8Ba,EAAPb,EAElO,QAASe,GAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAIN,WAAU,iEAAoEM,GAAeD,GAASE,UAAYC,OAAOC,OAAOH,GAAcA,EAAWC,WAAaG,aAAeC,MAAON,EAAUO,YAAY,EAAOC,UAAU,EAAMC,cAAc,KAAeR,IAAYE,OAAOO,eAAiBP,OAAOO,eAAeV,EAAUC,GAAcD,EAASW,UAAYV,GApEjeE,OAAOS,eAAehC,EAAS,cAC7B0B,OAAO,GAGT,IAAIO,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWZ,WAAaY,EAAWZ,aAAc,EAAOY,EAAWV,cAAe,EAAU,SAAWU,KAAYA,EAAWX,UAAW,GAAML,OAAOS,eAAeG,EAAQI,EAAWC,IAAKD,IAAiB,MAAO,UAAUzB,EAAa2B,EAAYC,GAAiJ,MAA9HD,IAAYP,EAAiBpB,EAAYQ,UAAWmB,GAAiBC,GAAaR,EAAiBpB,EAAa4B,GAAqB5B,MAE5hB6B,EAAO,QAASC,GAAIC,EAAQC,EAAUpB,EAAOqB,GAAY,GAAIC,GAAOzB,OAAO0B,yBAAyBJ,EAAQC,EAAW,IAAaI,SAATF,EAAoB,CAAE,GAAIG,GAAS5B,OAAO6B,eAAeP,EAAwB,QAAXM,GAAmBP,EAAIO,EAAQL,EAAUpB,EAAOqB,OAAoB,IAAI,SAAWC,IAAQA,EAAKpB,SAAYoB,EAAKtB,MAAQA,MAAc,CAAE,GAAI2B,GAASL,EAAKJ,GAAoBM,UAAXG,GAAwBA,EAAOjD,KAAK2C,EAAUrB,GAAY,MAAOA,IAEta4B,EAAO,QAASC,GAAIV,EAAQC,EAAUC,GAA2B,OAAXF,IAAiBA,EAASW,SAASlC,UAAW,IAAI0B,GAAOzB,OAAO0B,yBAAyBJ,EAAQC,EAAW,IAAaI,SAATF,EAAoB,CAAE,GAAIG,GAAS5B,OAAO6B,eAAeP,EAAS,OAAe,QAAXM,EAAmB,OAAkCI,EAAIJ,EAAQL,EAAUC,GAAoB,GAAI,SAAWC,GAAQ,MAAOA,GAAKtB,KAAgB,IAAI+B,GAAST,EAAKO,GAAK,IAAeL,SAAXO,EAA4C,MAAOA,GAAOrD,KAAK2C,IE7C7dW,EAAA7D,EAAA,GFiDK8D,EAAyBnD,EAAuBkD,GEhDrDE,EAAA/D,EAAA,GFoDKgE,EAAwBrD,EAAuBoD,GEnDpDE,EAAAjE,EAAA,GFuDKkE,EAAsBvD,EAAuBsD,GEtDlDE,EAAAnE,EAAA,GF0DKoE,EAA4BzD,EAAuBwD,GEzDxDE,EAAArE,EAAA,IF6DKsE,EAA2B3D,EAAuB0D,GE5DvDE,EAAAvE,EAAA,IFgEKwE,EAAkB7D,EAAuB4D,GE/D9CE,EAAAzE,EAAA,IFmEK0E,EAAgC/D,EAAuB8D,GElE5DE,EAAA3E,EAAA,IFsEK4E,EAAiCjE,EAAuBgE,GErE7DE,EAAA7E,EAAA,IFyEK8E,EAAuBnE,EAAuBkE,GExEnDE,EAAA/E,EAAA,IF4EKgF,EAAyBrE,EAAuBoE,GE3ErDE,EAAAjF,EAAA,IF+EKkF,EAAwBvE,EAAuBsE,GE9EpDE,EAAAnF,EAAA,IFkFKoF,EAAyBzE,EAAuBwE,GEjFrDE,EAAArF,EAAA,GFqFKsF,EAAY3E,EAAuB0E,GEjFlCE,GAASzB,EAAAhD,QAAAkD,EAAAlD,QAAAoD,EAAApD,QAAAsD,EAAAtD,QAAAwD,EAAAxD,QAAA0D,EAAA1D,QAAA4D,EAAA5D,QAAA8D,EAAA9D,QAAAgE,EAAAhE,QAAAkE,EAAAlE,QAAAoE,EAAApE,QAAAsE,EAAAtE,SAkBT0E,EAAOD,EAAOE,OAAO,SAACC,EAAKC,GAAN,MAAgBA,GAAMD,IAAME,aAyBjDC,EFiGS,SAAUC,GAGtB,QAASD,KAGP,MAFA9E,GAAgBgF,KAAMF,GAEf1E,EAA2B4E,MAAOF,EAAQ3D,WAAaR,OAAO6B,eAAesC,IAAUG,MAAMD,KAAME,YAoG5G,MAzGA3E,GAAUuE,EAASC,GAQnB1D,EAAayD,IACXlD,IAAK,2BAILd,MAAO,SE5GeqE,EAAeC,EAAUC,GAChD3C,EAAAoC,EAAApE,UAAAS,WAAAR,OAAA6B,eAAAsC,EAAApE,WAAA,2BAAAsE,OAAsCtC,EAAAoC,EAAApE,UAAAS,WAAAR,OAAA6B,eAAAsC,EAAApE,WAAA,2BAAAsE,MAAAxF,KAAAwF,KAA+BG,EAAeC,EAAUC,EAC9F,IAAMC,IACJC,iBAAkB,iBAEdC,EAAeF,EAAuBH,IAAkBA,CAC9DH,MAAKQ,GAAgBH,KFuHpBzD,IExGF2C,EAAAxE,QAAQ0F,aF4GN3E,MAAO,SE5Ga4E,EAAMC,GAC3BjD,EAAAoC,EAAApE,UAAAS,WAAAR,OAAA6B,eAAAsC,EAAApE,WAAU6D,EAAAxE,QAAQ0F,aAAlBT,OAAmCtC,EAAAoC,EAAApE,UAAAS,WAAAR,OAAA6B,eAAAsC,EAAApE,WAAM6D,EAAAxE,QAAQ0F,aAAdT,MAAAxF,KAAAwF,KAA4BU,EAAMC,GACrED,EAAKE,UAAUC,OAAO,WAAYF,MFoHjC/D,IE9HE2C,EAAAxE,QAAQ+F,SF+HVnD,IAAK,WE9HN,GAAMmD,GAAWpD,EAAAoC,EAAApE,UAAAS,WAAAR,OAAA6B,eAAAsC,EAAApE,WAAM6D,EAAAxE,QAAQ+F,SAAdd,SAGjB,OADAc,GAASC,YAAc,WAChBD,KFkINlE,IAAK,cAULe,IAAK,WEtHN,MAAOqC,MAAKT,EAAAxE,QAAQgG,cAAgBf,KAAKT,EAAAxE,QAAQ+F,UAAUC,aFyH1D/D,IAAK,SEvHQlB,GACd,GAAMkF,GAAUlF,IAAUkE,KAAKT,EAAAxE,QAAQgG,YAOvC,IANAf,KAAKT,EAAAxE,QAAQgG,aAAejF,EACxB,eAAiB2D,IAAQ1C,EAAA+C,EAAApE,UAAAS,WAAAR,OAAA6B,eAAAsC,EAAApE,WAAA,cAAoBI,EAApBkE,MAEzBA,KAAKiB,aAAa,iBAAmBnF,GACvCkE,KAAKkB,aAAa,cAAepF,GAE/BkF,GAAWhB,KAAKT,EAAAxE,QAAQoG,mBAAoB,CAC9C,GAAMC,GAAQ,GAAIC,aAAY,sBAC9BrB,MAAKsB,cAAcF,OFiIpBxE,IE3HE2C,EAAAxE,QAAQwG,SF4HV5D,IAAK,WE3HN,qjCFwICf,IAAK,qBACLe,IAAK,WEvKN,OAAQ,cAAe,sBF4KjBmC,GE3MYL,EAkHtB+B,gBAAeC,OAAO,kBAAmB3B,GF6FxC1F,EAAQW,QE5FM+E,GFgGT,SAASzF,EAAQD,EAASH,GAE/B,YAsBA,SAASW,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GAEvF,QAASG,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAEhH,QAASC,GAA2BC,EAAMb,GAAQ,IAAKa,EAAQ,KAAM,IAAIC,gBAAe,4DAAgE,QAAOd,GAAyB,gBAATA,IAAqC,kBAATA,GAA8Ba,EAAPb,EAElO,QAASe,GAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAIN,WAAU,iEAAoEM,GAAeD,GAASE,UAAYC,OAAOC,OAAOH,GAAcA,EAAWC,WAAaG,aAAeC,MAAON,EAAUO,YAAY,EAAOC,UAAU,EAAMC,cAAc,KAAeR,IAAYE,OAAOO,eAAiBP,OAAOO,eAAeV,EAAUC,GAAcD,EAASW,UAAYV,GG/Pnd,QAASiG,GAAqBjC,GAAM,GAK3CkC,GAL2C,SAAA5B,GAO/C,QAAA4B,KAAc3G,EAAAgF,KAAA2B,EAAA,IAAAC,GAAAxG,EAAA4E,MAAA2B,EAAAxF,WAAAR,OAAA6B,eAAAmE,IAAAnH,KAAAwF,MAAA,QASZ,EAAA6B,EAAA9G,SAAU,WACJ6G,EAAKrC,EAAAxE,QAAQ+G,iBACfF,EAAKrC,EAAAxE,QAAQ+G,oBAXLF,EAPiC,MAAArG,GAAAoG,EAAA5B,GAAA1D,EAAAsF,IAAA/E,IAoC9C2C,EAAAxE,QAAQgH,cApCsCjG,MAAA,WAoCrB,GAAAkG,GAAAhC,IACxBtC,GAAAiE,EAAAjG,UAAAS,WAAAR,OAAA6B,eAAAmE,EAAAjG,WAAU6D,EAAAxE,QAAQgH,cAAlB/B,OAAoCtC,EAAAiE,EAAAjG,UAAAS,WAAAR,OAAA6B,eAAAmE,EAAAjG,WAAM6D,EAAAxE,QAAQgH,cAAd/B,MAAAxF,KAAAwF,KAEpC,IAAMiC,GAAQjC,KAAKkC,WAAWC,iBAAiB,OAC/CF,GAAMG,QAAQ,SAAAC,GAAA,MAAQA,GAAKC,iBAAiB,aAAc,SAAAlB,GACpDY,EAAKzC,EAAAxE,QAAQ+G,iBACfE,EAAKzC,EAAAxE,QAAQ+G,yBA1C4BlF,IAgC1C2C,EAAAxE,QAAQwH,QAhCkC5E,IAAA,WAiC7C,OAAO,EAAA6E,EAAAC,kBAAiBzC,UAjCqB2B,GAKnBlC,EA2C9B,OAAOkC,GHqLRhG,OAAOS,eAAehC,EAAS,cAC7B0B,OAAO,GAGT,IAAIO,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWZ,WAAaY,EAAWZ,aAAc,EAAOY,EAAWV,cAAe,EAAU,SAAWU,KAAYA,EAAWX,UAAW,GAAML,OAAOS,eAAeG,EAAQI,EAAWC,IAAKD,IAAiB,MAAO,UAAUzB,EAAa2B,EAAYC,GAAiJ,MAA9HD,IAAYP,EAAiBpB,EAAYQ,UAAWmB,GAAiBC,GAAaR,EAAiBpB,EAAa4B,GAAqB5B,MAE5hBwC,EAAO,QAASC,GAAIV,EAAQC,EAAUC,GAA2B,OAAXF,IAAiBA,EAASW,SAASlC,UAAW,IAAI0B,GAAOzB,OAAO0B,yBAAyBJ,EAAQC,EAAW,IAAaI,SAATF,EAAoB,CAAE,GAAIG,GAAS5B,OAAO6B,eAAeP,EAAS,OAAe,QAAXM,EAAmB,OAAkCI,EAAIJ,EAAQL,EAAUC,GAAoB,GAAI,SAAWC,GAAQ,MAAOA,GAAKtB,KAAgB,IAAI+B,GAAST,EAAKO,GAAK,IAAeL,SAAXO,EAA4C,MAAOA,GAAOrD,KAAK2C,GAE5d/C,GAAQW,QG7Oe2G,CAhExB,IAAAc,GAAAvI,EAAA,GACAyI,EAAAzI,EAAA,GHkTK4H,EAAcjH,EAAuB8H,GGjT1CpD,EAAArF,EAAA,GHqTKsF,EAAY3E,EAAuB0E,IA4IlC,SAASjF,EAAQD,GAEtB,YAUA,SAASuI,GAAmBC,GAAO,GAAIC,MAAMC,QAAQF,GAAM,CAAE,IAAK,GAAInG,GAAI,EAAGsG,EAAOF,MAAMD,EAAIlG,QAASD,EAAImG,EAAIlG,OAAQD,IAAOsG,EAAKtG,GAAKmG,EAAInG,EAAM,OAAOsG,GAAe,MAAOF,OAAMG,KAAKJ,GI/ZpL,QAASH,GAAiBQ,GAC/B,MAAOC,GAAoBD,EAAQE,UAAU,GAWxC,QAASC,GAAmBH,GACjC,MAAOC,GAAoBD,EAAQI,YAAY,GAU1C,QAASC,GAAoBL,GAClC,GAAMM,GAAUH,EAAmBH,GAASO,IAC1C,SAAAC,GAAA,MAASA,GAAMC,aAEjB,OAAOH,GAAQI,KAAK,IAaf,QAASC,GAAwBC,GAKtC,GAAMC,IACJ,SACA,WACA,QACA,OACA,QACA,WACA,UACA,SACA,OACA,WACA,SACA,WACA,SACA,QACA,SACA,QACA,WACA,UAGF,UAAUC,OAAOvJ,KAAKqJ,EACpB,SAAAZ,GAAA,MAAWA,aAAmBe,YACxBf,EAAQgB,WAAaH,EAAcI,QAAQjB,EAAQgB,WAAa,KAgB1E,QAASf,GAAoBiB,EAAOC,GAAc,GAAAC,GAC1CC,EAAWzB,MAAMnH,UAAU8H,IAAIhJ,KAAK2J,EAAO,SAAAI,GAM/C,GAAMC,GAAoC,mBAApBC,iBACpBF,YAAgBE,iBACG,SAAnBF,EAAKN,SAEP,OAAOO,GACLD,EAAKG,eAAgBC,SAAS,KAC7BJ,KAECK,GAAYP,MAAGQ,OAAH5E,MAAAoE,EAAA1B,EAAa2B,IACzBQ,EAASV,EACbQ,EAAUb,OAAO,SAAAQ,GAAA,MAAQA,aAAgBP,WACzCY,CACF,OAAOE,GJgTRnJ,OAAOS,eAAehC,EAAS,cAC7B0B,OAAO,IAET1B,EI1ZeqI,mBJ2ZfrI,EI/YegJ,qBJgZfhJ,EIrYekJ,sBJsYflJ,EIrXewJ,2BJygBV,SAASvJ,EAAQD,GAEtB,YK/jBc,SAAS2K,GAAUC,GAChCC,EAAUC,KAAKF,GAEf/B,EAAQS,cAAgByB,EAK1B,QAASC,KACP,KAAOH,EAAUvI,OAAS,GAAG,CAC3B,GAAMsI,GAAWC,EAAUI,OAC3BL,MLsjBHrJ,OAAOS,eAAehC,EAAS,cAC7B0B,OAAO,IAET1B,EAAQW,QKpkBegK,CApBxB,IAAME,MAGAhC,EAAUqC,SAASC,eAAe,IAGpCJ,EAAU,EA+BRK,EAAW,GAAIC,kBAAiBL,EACtCI,GAASE,QAAQzC,GACf0C,eAAe,KL0mBX,SAAStL,EAAQD,EAASH,GAE/B,YAUA,SAASW,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GARvFc,OAAOS,eAAehC,EAAS,cAC7B0B,OAAO,GMtqBV,IAAA8J,GAAA3L,EAAA,GN2qBK4L,EAAWjL,EAAuBgL,GMlpBjCE,GAWJvD,SAAS,EAAAsD,EAAA9K,SAAO,WAUhB+G,gBAAgB,EAAA+D,EAAA9K,SAAO,kBAmBvB+F,UAAU,EAAA+E,EAAA9K,SAAO,YAWjBgL,aAAa,EAAAF,EAAA9K,SAAO,WASpBiL,QAAQ,EAAAH,EAAA9K,SAAO,UAUfkL,OAAO,EAAAJ,EAAA9K,SAAO,SASdmL,QAAQ,EAAAL,EAAA9K,SAAO,UASfoL,SAAS,EAAAN,EAAA9K,SAAO,WAUhBqL,SAAS,EAAAP,EAAA9K,SAAO,WAShBsL,MAAM,EAAAR,EAAA9K,SAAO,QAUbuL,WAAW,EAAAT,EAAA9K,SAAO,aAWlBwL,cAAc,EAAAV,EAAA9K,SAAO,gBAWrB0F,cAAc,EAAAoF,EAAA9K,SAAO,gBAUrByL,SAAS,EAAAX,EAAA9K,SAAO,WAWhBgG,aAAa,EAAA8E,EAAA9K,SAAO,eA+CpBoG,mBAAmB,EAAA0E,EAAA9K,SAAO,qBAW1BgH,eAAe,EAAA8D,EAAA9K,SAAO,iBAStBwG,UAAU,EAAAsE,EAAA9K,SAAO,YN+qBlBX,GAAQW,QM5qBM+K,GNgrBT,SAASzL,EAAQD,GAEtB,YO96BD,SAASqM,GAAaC,GACpB,UAAWA,EAAcC,IP+6B1BhL,OAAOS,eAAehC,EAAS,cAC7B0B,OAAO,GOn7BV,IAAI6K,GAAQ,EAMNC,EAA0C,kBAAlBC,QAAOC,OACnCD,OAAOC,OACPL,CP09BDrM,GAAQW,QOp7BM6L,GPw7BT,SAASvM,EAAQD,EAASH,GAE/B,YAWA,SAASW,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GAEvF,QAASG,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAEhH,QAASC,GAA2BC,EAAMb,GAAQ,IAAKa,EAAQ,KAAM,IAAIC,gBAAe,4DAAgE,QAAOd,GAAyB,gBAATA,IAAqC,kBAATA,GAA8Ba,EAAPb,EAElO,QAASe,GAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAIN,WAAU,iEAAoEM,GAAeD,GAASE,UAAYC,OAAOC,OAAOH,GAAcA,EAAWC,WAAaG,aAAeC,MAAON,EAAUO,YAAY,EAAOC,UAAU,EAAMC,cAAc,KAAeR,IAAYE,OAAOO,eAAiBP,OAAOO,eAAeV,EAAUC,GAAcD,EAASW,UAAYV,GQr9Bnd,QAASsL,GAAoBtH,GAAM,GAK1CuH,GAL0C,SAAAjH,GAO9C,QAAAiH,KAAchM,EAAAgF,KAAAgH,EAAA,IAAApF,GAAAxG,EAAA4E,MAAAgH,EAAA7K,WAAAR,OAAA6B,eAAAwJ,IAAAxM,KAAAwF,MAAA,OAEZ4B,GAAKU,iBAAiB,YAAa,SAAAlB,GAGjC,GAAqB,IAAjBA,EAAM6F,OAAV,CAIArF,EAAKrC,EAAAxE,QAAQoG,oBAAqB,CAKlC,IAAM5E,GAAS6E,EAAM7E,SAANqF,EACbR,EAAM8F,KAAK,GACX9F,EAAM7E,OAKFmE,EAAOyG,IAAoB5K,IAC7BmE,GAASkB,EAAKwF,oBAEV,gBAAAxF,GAGJA,EAAKyF,aAAe3G,EAFpB4G,QAAQC,KAAR,gFAQFnG,EAAMoG,mBAGR5F,EAAKrC,EAAAxE,QAAQoG,oBAAqB,KApCxBS,EAPgC,MAAArG,GAAAyL,EAAAjH,GAAAiH,GAKnBvH,EA4C7B,OAAOuH,GAQT,QAASG,GAAcM,EAAalL,GAGlC,IAAK,GAFCmL,GAAQD,EAAYC,MACpBC,EAAYD,EAAQA,EAAMhL,OAAS,EAChCD,EAAI,EAAGA,EAAIkL,EAAWlL,IAAK,CAClC,GAAIiE,GAAOgH,EAAMjL,EACjB,IAAIiE,IAASnE,GAAUmE,EAAKkH,SAASrL,GACnC,MAAOmE,GAGX,MAAO,MRo4BR/E,OAAOS,eAAehC,EAAS,cAC7B0B,OAAO,IAET1B,EAAQW,QQz8BegM,CArCxB,IAAAzH,GAAArF,EAAA,GRk/BKsF,EAAY3E,EAAuB0E,IAuHlC,SAASjF,EAAQD,EAASH,GAE/B,YAwBA,SAASW,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GAEvF,QAASgN,GAAwBhN,GAAO,GAAIA,GAAOA,EAAIC,WAAc,MAAOD,EAAc,IAAIiN,KAAa,IAAW,MAAPjN,EAAe,IAAK,GAAI+B,KAAO/B,GAAWc,OAAOD,UAAUqM,eAAevN,KAAKK,EAAK+B,KAAMkL,EAAOlL,GAAO/B,EAAI+B,GAAgC,OAAtBkL,GAAO/M,QAAUF,EAAYiN,EAElQ,QAAS9M,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAEhH,QAASC,GAA2BC,EAAMb,GAAQ,IAAKa,EAAQ,KAAM,IAAIC,gBAAe,4DAAgE,QAAOd,GAAyB,gBAATA,IAAqC,kBAATA,GAA8Ba,EAAPb,EAElO,QAASe,GAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAIN,WAAU,iEAAoEM,GAAeD,GAASE,UAAYC,OAAOC,OAAOH,GAAcA,EAAWC,WAAaG,aAAeC,MAAON,EAAUO,YAAY,EAAOC,UAAU,EAAMC,cAAc,KAAeR,IAAYE,OAAOO,eAAiBP,OAAOO,eAAeV,EAAUC,GAAcD,EAASW,UAAYV,GShmCnd,QAASuM,GAAkBvI,GAAM,GAKxCwI,GALwC,SAAAlI,GAAA,QAAAkI,KAAA,MAAAjN,GAAAgF,KAAAiI,GAAA7M,EAAA4E,MAAAiI,EAAA9L,WAAAR,OAAA6B,eAAAyK,IAAAhI,MAAAD,KAAAE,YAAA,MAAA3E,GAAA0M,EAAAlI,GAAA1D,EAAA4L,IAAArL,IAO3C2C,EAAAxE,QAAQ+G,eAPmChG,MAAA,WAQ1C4B,EAAAuK,EAAAvM,UAAAS,WAAAR,OAAA6B,eAAAyK,EAAAvM,WAAU6D,EAAAxE,QAAQ+G,eAAlB9B,OAAqCtC,EAAAuK,EAAAvM,UAAAS,WAAAR,OAAA6B,eAAAyK,EAAAvM,WAAM6D,EAAAxE,QAAQ+G,eAAd9B,MAAAxF,KAAAwF,MAMrCA,KAAKkI,GAAe,KAEpBlI,KAAKT,EAAAxE,QAAQwL,mBAhB6B3J,IA+C3C2C,EAAAxE,QAAQwL,aA/CmCzK,MAAA,WA+CnB,GAAAkG,GAAAhC,IACvBtC,GAAAuK,EAAAvM,UAAAS,WAAAR,OAAA6B,eAAAyK,EAAAvM,WAAU6D,EAAAxE,QAAQwL,aAAlBvG,OAAmCtC,EAAAuK,EAAAvM,UAAAS,WAAAR,OAAA6B,eAAAyK,EAAAvM,WAAM6D,EAAAxE,QAAQwL,aAAdvG,MAAAxF,KAAAwF,MAG/BA,KAAKT,EAAAxE,QAAQuL,YACfzD,MAAMnH,UAAU0G,QAAQ5H,KAAKwF,KAAK0H,MAAO,SAAAhH,GAClCA,EAAKyH,KACRnG,EAAKzC,EAAAxE,QAAQuL,WAAW5F,GACxBA,EAAKyH,IAAyB,KAKhCnI,KAAKT,EAAAxE,QAAQoG,oBACfnB,KAAKsB,cAAc,GAAID,aAAY,qBA7DKzE,IAAA,QAAAe,IAAA,WA0B1C,GAAI+J,SAaJ,OAZyB,OAArB1H,KAAKkI,IACPR,EAAQnF,EAAQqB,wBAAwB5D,KAAKT,EAAAxE,QAAQwH,UAG3B,OAAtBvC,KAAKkI,KAEPlI,KAAKkI,GAAeR,IAItBA,EAAQ1H,KAAKkI,GAERR,MAvCmCO,GAKnBxI,EAoE3B,OAAOwI,GTy/BRtM,OAAOS,eAAehC,EAAS,cAC7B0B,OAAO,GAGT,IAAIO,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWZ,WAAaY,EAAWZ,aAAc,EAAOY,EAAWV,cAAe,EAAU,SAAWU,KAAYA,EAAWX,UAAW,GAAML,OAAOS,eAAeG,EAAQI,EAAWC,IAAKD,IAAiB,MAAO,UAAUzB,EAAa2B,EAAYC,GAAiJ,MAA9HD,IAAYP,EAAiBpB,EAAYQ,UAAWmB,GAAiBC,GAAaR,EAAiBpB,EAAa4B,GAAqB5B,MAE5hBwC,EAAO,QAASC,GAAIV,EAAQC,EAAUC,GAA2B,OAAXF,IAAiBA,EAASW,SAASlC,UAAW,IAAI0B,GAAOzB,OAAO0B,yBAAyBJ,EAAQC,EAAW,IAAaI,SAATF,EAAoB,CAAE,GAAIG,GAAS5B,OAAO6B,eAAeP,EAAS,OAAe,QAAXM,EAAmB,OAAkCI,EAAIJ,EAAQL,EAAUC,GAAoB,GAAI,SAAWC,GAAQ,MAAOA,GAAKtB,KAAgB,IAAI+B,GAAST,EAAKO,GAAK,IAAeL,SAAXO,EAA4C,MAAOA,GAAOrD,KAAK2C,GAE5d/C,GAAQW,QS1kCeiN,CA3CxB,IAAAxF,GAAAvI,EAAA,GAAYsI,ETynCGsF,EAAwBrF,GSxnCvCoD,EAAA3L,EAAA,GT4nCK4L,EAAWjL,EAAuBgL,GS3nCvCtG,EAAArF,EAAA,GT+nCKsF,EAAY3E,EAAuB0E,GS3nClC4I,GAAc,EAAArC,EAAA9K,SAAO,SACrBoN,GAAwB,EAAAtC,EAAA9K,SAAO,oBTkxC/B,SAASV,EAAQD,EAASH,GAE/B,YAgBA,SAASW,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GAEvF,QAASG,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAEhH,QAASC,GAA2BC,EAAMb,GAAQ,IAAKa,EAAQ,KAAM,IAAIC,gBAAe,4DAAgE,QAAOd,GAAyB,gBAATA,IAAqC,kBAATA,GAA8Ba,EAAPb,EAElO,QAASe,GAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAIN,WAAU,iEAAoEM,GAAeD,GAASE,UAAYC,OAAOC,OAAOH,GAAcA,EAAWC,WAAaG,aAAeC,MAAON,EAAUO,YAAY,EAAOC,UAAU,EAAMC,cAAc,KAAeR,IAAYE,OAAOO,eAAiBP,OAAOO,eAAeV,EAAUC,GAAcD,EAASW,UAAYV,GUjyCnd,QAAS2M,GAAwB3I,GAAM,GAK9C4I,GAL8C,SAAAtI,GAAA,QAAAsI,KAAA,MAAArN,GAAAgF,KAAAqI,GAAAjN,EAAA4E,MAAAqI,EAAAlM,WAAAR,OAAA6B,eAAA6K,IAAApI,MAAAD,KAAAE,YAAA,MAAA3E,GAAA8M,EAAAtI,GAAA1D,EAAAgM,IAAAzL,IAOjD2C,EAAAxE,QAAQiL,OAPyClK,MAAA,WAShD,MADA4B,GAAA2K,EAAA3M,UAAAS,WAAAR,OAAA6B,eAAA6K,EAAA3M,WAAU6D,EAAAxE,QAAQiL,OAAlBhG,OAA6BtC,EAAA2K,EAAA3M,UAAAS,WAAAR,OAAA6B,eAAA6K,EAAA3M,WAAM6D,EAAAxE,QAAQiL,OAAdhG,MAAAxF,KAAAwF,MACxBA,KAAKsI,WAGDtI,KAAKsI,iBAFZhB,SAAQC,KAAR,mFAV8C3K,IAgBjD2C,EAAAxE,QAAQkL,MAhByCnK,MAAA,WAkBhD,MADA4B,GAAA2K,EAAA3M,UAAAS,WAAAR,OAAA6B,eAAA6K,EAAA3M,WAAU6D,EAAAxE,QAAQkL,MAAlBjG,OAA4BtC,EAAA2K,EAAA3M,UAAAS,WAAAR,OAAA6B,eAAA6K,EAAA3M,WAAM6D,EAAAxE,QAAQkL,MAAdjG,MAAAxF,KAAAwF,MACvBA,KAAKuI,WAGDvI,KAAKuI,iBAFZjB,SAAQC,KAAR,mFAnB8C3K,IAyBjD2C,EAAAxE,QAAQmL,OAzByCpK,MAAA,WA2BhD,MADA4B,GAAA2K,EAAA3M,UAAAS,WAAAR,OAAA6B,eAAA6K,EAAA3M,WAAU6D,EAAAxE,QAAQmL,OAAlBlG,OAA6BtC,EAAA2K,EAAA3M,UAAAS,WAAAR,OAAA6B,eAAA6K,EAAA3M,WAAM6D,EAAAxE,QAAQmL,OAAdlG,MAAAxF,KAAAwF,MACxBA,KAAKwI,eAGDxI,KAAKwI,qBAFZlB,SAAQC,KAAR,uFA5B8C3K,IAkCjD2C,EAAAxE,QAAQoL,QAlCyCrK,MAAA,WAoChD,MADA4B,GAAA2K,EAAA3M,UAAAS,WAAAR,OAAA6B,eAAA6K,EAAA3M,WAAU6D,EAAAxE,QAAQoL,QAAlBnG,OAA8BtC,EAAA2K,EAAA3M,UAAAS,WAAAR,OAAA6B,eAAA6K,EAAA3M,WAAM6D,EAAAxE,QAAQoL,QAAdnG,MAAAxF,KAAAwF,MACzBA,KAAKsI,WAGDtI,KAAKsI,iBAFZhB,SAAQC,KAAR,mFArC8C3K,IA2CjD2C,EAAAxE,QAAQqL,QA3CyCtK,MAAA,WA6ChD,MADA4B,GAAA2K,EAAA3M,UAAAS,WAAAR,OAAA6B,eAAA6K,EAAA3M,WAAU6D,EAAAxE,QAAQqL,QAAlBpG,OAA8BtC,EAAA2K,EAAA3M,UAAAS,WAAAR,OAAA6B,eAAA6K,EAAA3M,WAAM6D,EAAAxE,QAAQqL,QAAdpG,MAAAxF,KAAAwF,MACzBA,KAAKyI,YAGDzI,KAAKyI,kBAFZnB,SAAQC,KAAR,oFA9C8C3K,IAoDjD2C,EAAAxE,QAAQsL,KApDyCvK,MAAA,WAsDhD,MADA4B,GAAA2K,EAAA3M,UAAAS,WAAAR,OAAA6B,eAAA6K,EAAA3M,WAAU6D,EAAAxE,QAAQsL,KAAlBrG,OAA2BtC,EAAA2K,EAAA3M,UAAAS,WAAAR,OAAA6B,eAAA6K,EAAA3M,WAAM6D,EAAAxE,QAAQsL,KAAdrG,MAAAxF,KAAAwF,MACtBA,KAAKwI,eAGDxI,KAAKwI,qBAFZlB,SAAQC,KAAR,wFAvD8Cc,GAKnB5I,EA0DjC,OAAO4I,GV8sCR1M,OAAOS,eAAehC,EAAS,cAC7B0B,OAAO,GAGT,IAAIO,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWZ,WAAaY,EAAWZ,aAAc,EAAOY,EAAWV,cAAe,EAAU,SAAWU,KAAYA,EAAWX,UAAW,GAAML,OAAOS,eAAeG,EAAQI,EAAWC,IAAKD,IAAiB,MAAO,UAAUzB,EAAa2B,EAAYC,GAAiJ,MAA9HD,IAAYP,EAAiBpB,EAAYQ,UAAWmB,GAAiBC,GAAaR,EAAiBpB,EAAa4B,GAAqB5B,MAE5hBwC,EAAO,QAASC,GAAIV,EAAQC,EAAUC,GAA2B,OAAXF,IAAiBA,EAASW,SAASlC,UAAW,IAAI0B,GAAOzB,OAAO0B,yBAAyBJ,EAAQC,EAAW,IAAaI,SAATF,EAAoB,CAAE,GAAIG,GAAS5B,OAAO6B,eAAeP,EAAS,OAAe,QAAXM,EAAmB,OAAkCI,EAAIJ,EAAQL,EAAUC,GAAoB,GAAI,SAAWC,GAAQ,MAAOA,GAAKtB,KAAgB,IAAI+B,GAAST,EAAKO,GAAK,IAAeL,SAAXO,EAA4C,MAAOA,GAAOrD,KAAK2C,GAE5d/C,GAAQW,QUrxCeqN,CAhBxB,IAAA9I,GAAArF,EAAA,GVyyCKsF,EAAY3E,EAAuB0E,IAuHlC,SAASjF,EAAQD,EAASH,GAE/B,YAgBA,SAASW,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GAEvF,QAASG,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAEhH,QAASC,GAA2BC,EAAMb,GAAQ,IAAKa,EAAQ,KAAM,IAAIC,gBAAe,4DAAgE,QAAOd,GAAyB,gBAATA,IAAqC,kBAATA,GAA8Ba,EAAPb,EAElO,QAASe,GAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAIN,WAAU,iEAAoEM,GAAeD,GAASE,UAAYC,OAAOC,OAAOH,GAAcA,EAAWC,WAAaG,aAAeC,MAAON,EAAUO,YAAY,EAAOC,UAAU,EAAMC,cAAc,KAAeR,IAAYE,OAAOO,eAAiBP,OAAOO,eAAeV,EAAUC,GAAcD,EAASW,UAAYV,GWj6Cnd,QAASiN,GAAuBjJ,GAAM,GAK7CkJ,GAL6C,SAAA5I,GAAA,QAAA4I,KAAA,MAAA3N,GAAAgF,KAAA2I,GAAAvN,EAAA4E,MAAA2I,EAAAxM,WAAAR,OAAA6B,eAAAmL,IAAA1I,MAAAD,KAAAE,YAAA,MAAA3E,GAAAoN,EAAA5I,GAAA1D,EAAAsM,IAAA/L,IAWhD2C,EAAAxE,QAAQiL,OAXwClK,MAAA,WAY/C,GAAA4B,EAAAiL,EAAAjN,UAAAS,WAAAR,OAAA6B,eAAAmL,EAAAjN,WAAU6D,EAAAxE,QAAQiL,OAAlBhG,MAA6B,MAAAtC,GAAAiL,EAAAjN,UAAAS,WAAAR,OAAA6B,eAAAmL,EAAAjN,WAAa6D,EAAAxE,QAAQiL,OAArBhG,MAAAxF,KAAAwF,SAZkBpD,IAmBhD2C,EAAAxE,QAAQkL,MAnBwCnK,MAAA,WAoB/C,GAAA4B,EAAAiL,EAAAjN,UAAAS,WAAAR,OAAA6B,eAAAmL,EAAAjN,WAAU6D,EAAAxE,QAAQkL,MAAlBjG,MAA4B,MAAAtC,GAAAiL,EAAAjN,UAAAS,WAAAR,OAAA6B,eAAAmL,EAAAjN,WAAa6D,EAAAxE,QAAQkL,MAArBjG,MAAAxF,KAAAwF,SApBmBpD,IA2BhD2C,EAAAxE,QAAQmL,OA3BwCpK,MAAA,WA4B/C,GAAA4B,EAAAiL,EAAAjN,UAAAS,WAAAR,OAAA6B,eAAAmL,EAAAjN,WAAU6D,EAAAxE,QAAQmL,OAAlBlG,MAA6B,MAAAtC,GAAAiL,EAAAjN,UAAAS,WAAAR,OAAA6B,eAAAmL,EAAAjN,WAAa6D,EAAAxE,QAAQmL,OAArBlG,MAAAxF,KAAAwF,SA5BkBpD,IAmChD2C,EAAAxE,QAAQoL,QAnCwCrK,MAAA,WAoC/C,GAAA4B,EAAAiL,EAAAjN,UAAAS,WAAAR,OAAA6B,eAAAmL,EAAAjN,WAAU6D,EAAAxE,QAAQoL,QAAlBnG,MAA8B,MAAAtC,GAAAiL,EAAAjN,UAAAS,WAAAR,OAAA6B,eAAAmL,EAAAjN,WAAa6D,EAAAxE,QAAQoL,QAArBnG,MAAAxF,KAAAwF,SApCiBpD,IA2ChD2C,EAAAxE,QAAQqL,QA3CwCtK,MAAA,WA4C/C,GAAA4B,EAAAiL,EAAAjN,UAAAS,WAAAR,OAAA6B,eAAAmL,EAAAjN,WAAU6D,EAAAxE,QAAQqL,QAAlBpG,MAA8B,MAAAtC,GAAAiL,EAAAjN,UAAAS,WAAAR,OAAA6B,eAAAmL,EAAAjN,WAAa6D,EAAAxE,QAAQqL,QAArBpG,MAAAxF,KAAAwF,SA5CiBpD,IAmDhD2C,EAAAxE,QAAQsL,KAnDwCvK,MAAA,WAoD/C,GAAA4B,EAAAiL,EAAAjN,UAAAS,WAAAR,OAAA6B,eAAAmL,EAAAjN,WAAU6D,EAAAxE,QAAQsL,KAAlBrG,MAA2B,MAAAtC,GAAAiL,EAAAjN,UAAAS,WAAAR,OAAA6B,eAAAmL,EAAAjN,WAAa6D,EAAAxE,QAAQsL,KAArBrG,MAAAxF,KAAAwF,SApDoBpD,IAuDhD2C,EAAAxE,QAAQyL,QAvDwC1K,MAAA,SAuD/BsF,GAChB,GAAIwH,IAAU,EAER7H,EAAcf,KAAKT,EAAAxE,QAAQgG,cAAgB,OAC3C8H,EAA8B,eAAhB9H,GAAgD,SAAhBA,EAC9C+H,EAA4B,aAAhB/H,GAA8C,SAAhBA,CAIhD,QAAQK,EAAM2H,SACZ,IAAK,IACHH,EAAU5I,KAAKT,EAAAxE,QAAQkL,QACvB,MACF,KAAK,IACH2C,EAAU5I,KAAKT,EAAAxE,QAAQqL,UACvB,MACF,KAAK,KACCyC,GAAezH,EAAM4H,SAAY5H,EAAM6H,SACzCL,EAAU5I,KAAKT,EAAAxE,QAAQmL,UAEzB,MACF,KAAK,IACC4C,IACFF,EAAUxH,EAAM6H,OAASjJ,KAAKT,EAAAxE,QAAQqL,WAAapG,KAAKT,EAAAxE,QAAQsL,QAElE,MACF,KAAK,KACCwC,GAAezH,EAAM4H,SAAY5H,EAAM6H,SACzCL,EAAU5I,KAAKT,EAAAxE,QAAQoL,WAEzB,MACF,KAAK,IACC2C,IACFF,EAAUxH,EAAM6H,OAASjJ,KAAKT,EAAAxE,QAAQkL,SAAWjG,KAAKT,EAAAxE,QAAQiL,WAKpE,MAAO4C,IAAYlL,EAAAiL,EAAAjN,UAAAS,WAAAR,OAAA6B,eAAAmL,EAAAjN,WAAM6D,EAAAxE,QAAQyL,QAAdxG,OAAAtC,EAAAiL,EAAAjN,UAAAS,WAAAR,OAAA6B,eAAAmL,EAAAjN,WAAgC6D,EAAAxE,QAAQyL,QAAxCxG,MAAAxF,KAAAwF,KAAiDoB,KAAW,MA7FhCuH,GAKnBlJ,EA6FhC,OAAOkJ,GX2yCRhN,OAAOS,eAAehC,EAAS,cAC7B0B,OAAO,GAGT,IAAIO,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWZ,WAAaY,EAAWZ,aAAc,EAAOY,EAAWV,cAAe,EAAU,SAAWU,KAAYA,EAAWX,UAAW,GAAML,OAAOS,eAAeG,EAAQI,EAAWC,IAAKD,IAAiB,MAAO,UAAUzB,EAAa2B,EAAYC,GAAiJ,MAA9HD,IAAYP,EAAiBpB,EAAYQ,UAAWmB,GAAiBC,GAAaR,EAAiBpB,EAAa4B,GAAqB5B,MAE5hBwC,EAAO,QAASC,GAAIV,EAAQC,EAAUC,GAA2B,OAAXF,IAAiBA,EAASW,SAASlC,UAAW,IAAI0B,GAAOzB,OAAO0B,yBAAyBJ,EAAQC,EAAW,IAAaI,SAATF,EAAoB,CAAE,GAAIG,GAAS5B,OAAO6B,eAAeP,EAAS,OAAe,QAAXM,EAAmB,OAAkCI,EAAIJ,EAAQL,EAAUC,GAAoB,GAAI,SAAWC,GAAQ,MAAOA,GAAKtB,KAAgB,IAAI+B,GAAST,EAAKO,GAAK,IAAeL,SAAXO,EAA4C,MAAOA,GAAOrD,KAAK2C,GAE5d/C,GAAQW,QWr5Ce2N,CAvBxB,IAAApJ,GAAArF,EAAA,GXg7CKsF,EAAY3E,EAAuB0E,IAoLlC,SAASjF,EAAQD,EAASH,GAE/B,YAgBA,SAASW,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GAEvF,QAASG,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAEhH,QAASC,GAA2BC,EAAMb,GAAQ,IAAKa,EAAQ,KAAM,IAAIC,gBAAe,4DAAgE,QAAOd,GAAyB,gBAATA,IAAqC,kBAATA,GAA8Ba,EAAPb,EAElO,QAASe,GAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAIN,WAAU,iEAAoEM,GAAeD,GAASE,UAAYC,OAAOC,OAAOH,GAAcA,EAAWC,WAAaG,aAAeC,MAAON,EAAUO,YAAY,EAAOC,UAAU,EAAMC,cAAc,KAAeR,IAAYE,OAAOO,eAAiBP,OAAOO,eAAeV,EAAUC,GAAcD,EAASW,UAAYV,GYhlDnd,QAASyN,GAAczJ,GAAM,GAKpC0J,GALoC,SAAApJ,GAOxC,QAAAoJ,KAAcnO,EAAAgF,KAAAmJ,EAAA,IAAAvH,GAAAxG,EAAA4E,MAAAmJ,EAAAhN,WAAAR,OAAA6B,eAAA2L,IAAA3O,KAAAwF,MAAA,OAEZ4B,GAAKU,iBAAiB,UAAW,SAAAlB,GAC/BQ,EAAKrC,EAAAxE,QAAQoG,oBAAqB,CAClC,IAAMyH,GAAUhH,EAAKrC,EAAAxE,QAAQyL,SAASpF,EAClCwH,KACFxH,EAAMgI,iBACNhI,EAAMoG,mBAER5F,EAAKrC,EAAAxE,QAAQoG,oBAAqB,IATxBS,EAP0B,MAAArG,GAAA4N,EAAApJ,GAAA1D,EAAA8M,IAAAvM,IAAA,oBAAAd,MAAA,WAqBtC4B,EAAAyL,EAAAzN,UAAAS,WAAAR,OAAA6B,eAAA2L,EAAAzN,WAAA,oBAAAsE,OAA+BtC,EAAAyL,EAAAzN,UAAAS,WAAAR,OAAA6B,eAAA2L,EAAAzN,WAAA,oBAAAsE,MAAAxF,KAAAwF,MACM,MAAjCA,KAAKiB,aAAa,aAA2D,OAApCjB,KAAKT,EAAAxE,QAAQ+F,UAAUuI,UAClErJ,KAAKkB,aAAa,WAAYlB,KAAKT,EAAAxE,QAAQ+F,UAAUuI,aAvBjBzM,IA2CvC2C,EAAAxE,QAAQyL,QA3C+B1K,MAAA,SA2CtBsF,GAChB,GAAA1D,EAAAyL,EAAAzN,UAAAS,WAAAR,OAAA6B,eAAA2L,EAAAzN,WAAU6D,EAAAxE,QAAQyL,QAAlBxG,MAA8B,MAAAtC,GAAAyL,EAAAzN,UAAAS,WAAAR,OAAA6B,eAAA2L,EAAAzN,WAAa6D,EAAAxE,QAAQyL,QAArBxG,MAAAxF,KAAAwF,KAA8BoB,MA5CtBxE,IA2BnC2C,EAAAxE,QAAQ+F,SA3B2BnD,IAAA,WA4BtC,GAAMmD,GAAWpD,EAAAyL,EAAAzN,UAAAS,WAAAR,OAAA6B,eAAA2L,EAAAzN,WAAM6D,EAAAxE,QAAQ+F,SAAdd,SAGjB,OADAc,GAASuI,SAAW,EACbvI,MA/B+BqI,GAKnB1J,EA4CvB,OAAO0J,GZ2gDRxN,OAAOS,eAAehC,EAAS,cAC7B0B,OAAO,GAGT,IAAIO,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWZ,WAAaY,EAAWZ,aAAc,EAAOY,EAAWV,cAAe,EAAU,SAAWU,KAAYA,EAAWX,UAAW,GAAML,OAAOS,eAAeG,EAAQI,EAAWC,IAAKD,IAAiB,MAAO,UAAUzB,EAAa2B,EAAYC,GAAiJ,MAA9HD,IAAYP,EAAiBpB,EAAYQ,UAAWmB,GAAiBC,GAAaR,EAAiBpB,EAAa4B,GAAqB5B,MAE5hBwC,EAAO,QAASC,GAAIV,EAAQC,EAAUC,GAA2B,OAAXF,IAAiBA,EAASW,SAASlC,UAAW,IAAI0B,GAAOzB,OAAO0B,yBAAyBJ,EAAQC,EAAW,IAAaI,SAATF,EAAoB,CAAE,GAAIG,GAAS5B,OAAO6B,eAAeP,EAAS,OAAe,QAAXM,EAAmB,OAAkCI,EAAIJ,EAAQL,EAAUC,GAAoB,GAAI,SAAWC,GAAQ,MAAOA,GAAKtB,KAAgB,IAAI+B,GAAST,EAAKO,GAAK,IAAeL,SAAXO,EAA4C,MAAOA,GAAOrD,KAAK2C,GAE5d/C,GAAQW,QYpkDemO,CA5CxB,IAAA5J,GAAArF,EAAA,GZonDKsF,EAAY3E,EAAuB0E,IA0HlC,SAASjF,EAAQD,EAASH,GAE/B,YAoBA,SAASW,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GAEvF,QAASG,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAEhH,QAASC,GAA2BC,EAAMb,GAAQ,IAAKa,EAAQ,KAAM,IAAIC,gBAAe,4DAAgE,QAAOd,GAAyB,gBAATA,IAAqC,kBAATA,GAA8Ba,EAAPb,EAElO,QAASe,GAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAIN,WAAU,iEAAoEM,GAAeD,GAASE,UAAYC,OAAOC,OAAOH,GAAcA,EAAWC,WAAaG,aAAeC,MAAON,EAAUO,YAAY,EAAOC,UAAU,EAAMC,cAAc,KAAeR,IAAYE,OAAOO,eAAiBP,OAAOO,eAAeV,EAAUC,GAAcD,EAASW,UAAYV,GaxuDnd,QAAS6N,GAA4B7J,GAAM,GAKlD8J,GALkD,SAAAxJ,GAAA,QAAAwJ,KAAA,MAAAvO,GAAAgF,KAAAuJ,GAAAnO,EAAA4E,MAAAuJ,EAAApN,WAAAR,OAAA6B,eAAA+L,IAAAtJ,MAAAD,KAAAE,YAAA,MAAA3E,GAAAgO,EAAAxJ,GAAA1D,EAAAkN,IAAA3M,IAOrD2C,EAAAxE,QAAQyL,QAP6C1K,MAAA,SAOpCsF,GAChB,GAAIwH,IAAU,EACR7H,EAAcf,KAAKT,EAAAxE,QAAQgG,YACjC,IAAoB,eAAhBA,EACF,OAAQK,EAAM2H,SACZ,IAAK,IACLH,EAAU5I,KAAKwJ,QACf,MACA,KAAK,IACLZ,EAAU5I,KAAKyJ,WAKnB,MAAOb,IAAYlL,EAAA6L,EAAA7N,UAAAS,WAAAR,OAAA6B,eAAA+L,EAAA7N,WAAM6D,EAAAxE,QAAQyL,QAAdxG,OAAAtC,EAAA6L,EAAA7N,UAAAS,WAAAR,OAAA6B,eAAA+L,EAAA7N,WAAgC6D,EAAAxE,QAAQyL,QAAxCxG,MAAAxF,KAAAwF,KAAiDoB,MArBhBxE,IAAA,WAAAd,MAAA,WA6BpD,MADA4B,GAAA6L,EAAA7N,UAAAS,WAAAR,OAAA6B,eAAA+L,EAAA7N,WAAA,WAAAsE,OAAsBtC,EAAA6L,EAAA7N,UAAAS,WAAAR,OAAA6B,eAAA+L,EAAA7N,WAAA,WAAAsE,MAAAxF,KAAAwF,MACf0J,EAAc1J,MAAM,MA7ByBpD,IAAA,SAAAd,MAAA,WAqCpD,MADA4B,GAAA6L,EAAA7N,UAAAS,WAAAR,OAAA6B,eAAA+L,EAAA7N,WAAA,SAAAsE,OAAoBtC,EAAA6L,EAAA7N,UAAAS,WAAAR,OAAA6B,eAAA+L,EAAA7N,WAAA,SAAAsE,MAAAxF,KAAAwF,MACb0J,EAAc1J,MAAM,MArCyBpD,IAyCjD2C,EAAAxE,QAAQ4O,aAzCyChM,IAAA,WA0CpD,MAAOD,GAAA6L,EAAA7N,UAAAS,WAAAR,OAAA6B,eAAA+L,EAAA7N,WAAM6D,EAAAxE,QAAQ4O,aAAd3J,QAA+B,EAAA4J,EAAA7O,SAAoBiF,UA1CNuJ,GAKnB9J,EA0CrC,OAAO8J,GAUT,QAASM,GAAkB5G,EAAS0G,EAAcG,EAAGC,GAcnD,IAZA,GAAMrC,GAAQzE,EAAQyE,MAChBsC,EAAQD,EAAW,EAAIrC,EAAMhL,OAAS,EACtCuN,EAAMF,EAAWrC,EAAMhL,OAAS,EAChCwN,EAAOH,EAAW,GAAI,EAEtBI,EAAkBR,EAAaS,UAAYT,EAAaU,UAG1D3J,SACA4J,EAAYN,EACZO,SACAC,GAAQ,EACLF,IAAcL,GAAK,CACxBvJ,EAAOgH,EAAM4C,GACbC,EAAU7J,EAAK0J,UAAYD,CAC3B,IAAMM,GAAaF,EAAU7J,EAAKgK,YAClC,IAAIH,GAAWT,GAAKW,GAAcX,EAAG,CAEnCU,GAAQ,CACR,OAEFF,GAAaJ,EAGf,IAAKM,EACH,MAAO,KAOT,IAAMG,GAAYC,iBAAiBlK,GAC7BmK,EAAiBC,WAAWH,EAAUI,YACtCC,EAAoBF,WAAWH,EAAUM,eACzCC,EAAaX,EAAU7J,EAAK2J,UAAYQ,EACxCM,EAAgBD,EAAaxK,EAAK0K,aAAeP,EAAiBG,CACxE,OAAIjB,IAAYmB,GAAcpB,IAAMC,GAAYoB,GAAiBrB,EAExDQ,EAKAA,EAAYJ,EAMvB,QAASR,GAAczG,EAAS8G,GAI9B,GAAMJ,GAAe1G,EAAQ1D,EAAAxE,QAAQ4O,cAC/B0B,EAAO1B,EAAa2B,WAAavB,EAAWJ,EAAayB,aAAe,GACxEG,EAAoB1B,EAAkB5G,EAAS0G,EAAc0B,EAAMtB,GAEnEyB,EAAgBvI,EAAQuI,cAC1BC,QACJ,IAAIF,GAAqBC,IAAkBD,EAAmB,CAG5D,GAAMG,IAAS3B,EAAW,GAAI,GAAMJ,EAAayB,YACjDK,GAAW5B,EAAkB5G,EAAS0G,EAAc0B,EAAOK,EAAO3B,OAMlE0B,GAAWF,CASb,OANKE,KAGHA,EAAY1B,EAAW9G,EAAQyE,MAAMhL,OAAS,EAAI,GAGhD+O,IAAaD,IACfvI,EAAQuI,cAAgBC,GACjB,GbokDV9P,OAAOS,eAAehC,EAAS,cAC7B0B,OAAO,GAGT,IAAIO,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWZ,WAAaY,EAAWZ,aAAc,EAAOY,EAAWV,cAAe,EAAU,SAAWU,KAAYA,EAAWX,UAAW,GAAML,OAAOS,eAAeG,EAAQI,EAAWC,IAAKD,IAAiB,MAAO,UAAUzB,EAAa2B,EAAYC,GAAiJ,MAA9HD,IAAYP,EAAiBpB,EAAYQ,UAAWmB,GAAiBC,GAAaR,EAAiBpB,EAAa4B,GAAqB5B,MAE5hBwC,EAAO,QAASC,GAAIV,EAAQC,EAAUC,GAA2B,OAAXF,IAAiBA,EAASW,SAASlC,UAAW,IAAI0B,GAAOzB,OAAO0B,yBAAyBJ,EAAQC,EAAW,IAAaI,SAATF,EAAoB,CAAE,GAAIG,GAAS5B,OAAO6B,eAAeP,EAAS,OAAe,QAAXM,EAAmB,OAAkCI,EAAIJ,EAAQL,EAAUC,GAAoB,GAAI,SAAWC,GAAQ,MAAOA,GAAKtB,KAAgB,IAAI+B,GAAST,EAAKO,GAAK,IAAeL,SAAXO,EAA4C,MAAOA,GAAOrD,KAAK2C,GAE5d/C,GAAQW,QaxtDeuO,CAlCxB,IAAAqC,GAAA1R,EAAA,Ib8vDK2P,EAAwBhP,EAAuB+Q,Ga7vDpDrM,EAAArF,EAAA,GbiwDKsF,EAAY3E,EAAuB0E,IAmNlC,SAASjF,EAAQD,GAEtB,Yc38Dc,SAASwR,GAAoB3I,GAC1C,GAAMZ,GAAOY,EAAQf,YAAce,EAAQf,WAAW2J,cAAc,mBACpE,OAAOxJ,GACLyJ,EAAmBzJ,EAAMY,GACzBA,EAMJ,QAAS6I,GAAmB7I,EAAS8I,GACnC,GAAgB,OAAZ9I,GAAoBA,IAAY8I,EAElC,MAAOA,EAET,IAAMC,GAAYpB,iBAAiB3H,GAAS+I,SAC5C,OAAkB,WAAdA,GAAwC,SAAdA,EAErB/I,EAGF6I,EAAmB7I,EAAQgJ,WAAYF,Gdw7D/CpQ,OAAOS,eAAehC,EAAS,cAC7B0B,OAAO,IAET1B,EAAQW,Qch9De6Q,Gdo/DlB,SAASvR,EAAQD,EAASH,GAE/B,YA0BA,SAASW,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GAEvF,QAASG,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAEhH,QAASC,GAA2BC,EAAMb,GAAQ,IAAKa,EAAQ,KAAM,IAAIC,gBAAe,4DAAgE,QAAOd,GAAyB,gBAATA,IAAqC,kBAATA,GAA8Ba,EAAPb,EAElO,QAASe,GAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAIN,WAAU,iEAAoEM,GAAeD,GAASE,UAAYC,OAAOC,OAAOH,GAAcA,EAAWC,WAAaG,aAAeC,MAAON,EAAUO,YAAY,EAAOC,UAAU,EAAMC,cAAc,KAAeR,IAAYE,OAAOO,eAAiBP,OAAOO,eAAeV,EAAUC,GAAcD,EAASW,UAAYV,Ge9+Dnd,QAASyQ,GAA6BzM,GAAM,GAKnD0M,GALmD,SAAApM,GAAA,QAAAoM,KAAA,MAAAnR,GAAAgF,KAAAmM,GAAA/Q,EAAA4E,MAAAmM,EAAAhQ,WAAAR,OAAA6B,eAAA2O,IAAAlM,MAAAD,KAAAE,YAAA,MAAA3E,GAAA4Q,EAAApM,GAAA1D,EAAA8P,IAAAvP,IAStD2C,EAAAxE,QAAQgL,YAT8CjK,MAAA,SASjC4E,GACpB,MAAOA,GAAKO,aAAa,QAAUP,EAAKgD,eAVa9G,IAetD2C,EAAAxE,QAAQwL,aAf8CzK,MAAA,WAgBrD4B,EAAAyO,EAAAzQ,UAAAS,WAAAR,OAAA6B,eAAA2O,EAAAzQ,WAAU6D,EAAAxE,QAAQwL,aAAlBvG,OAAmCtC,EAAAyO,EAAAzQ,UAAAS,WAAAR,OAAA6B,eAAA2O,EAAAzQ,WAAM6D,EAAAxE,QAAQwL,aAAdvG,MAAAxF,KAAAwF,MACnCA,KAAKoM,GAA0B,KAC/BC,EAAiBrM,SAlBoCpD,IAqBtD2C,EAAAxE,QAAQyL,QArB8C1K,MAAA,SAqBrCsF,GAChB,GAAIwH,UACA0D,GAAc,CAElB,QAAQlL,EAAM2H,SACZ,IAAK,GACHwD,EAAgBvM,MAChB4I,GAAU,EACV0D,GAAc,CACd,MACF,KAAK,IACH1D,GAAU,CACV,MACF,SACOxH,EAAMoL,SAAYpL,EAAM4H,SAAY5H,EAAM6H,QAC3B,KAAhB7H,EAAMqL,OACRC,EAAqB1M,KAAM2M,OAAOC,aAAaxL,EAAM2H,UAEvDuD,GAAc,EAQlB,MALIA,IACFD,EAAiBrM,MAIZ4I,GAAYlL,EAAAyO,EAAAzQ,UAAAS,WAAAR,OAAA6B,eAAA2O,EAAAzQ,WAAM6D,EAAAxE,QAAQyL,QAAdxG,OAAAtC,EAAAyO,EAAAzQ,UAAAS,WAAAR,OAAA6B,eAAA2O,EAAAzQ,WAAgC6D,EAAAxE,QAAQyL,QAAxCxG,MAAAxF,KAAAwF,KAAiDoB,MA/CfxE,IAAA,2BAAAd,MAAA,SAmE9B+Q,GAEvB,GADAnP,EAAAyO,EAAAzQ,UAAAS,WAAAR,OAAA6B,eAAA2O,EAAAzQ,WAAA,2BAAAsE,OAAsCtC,EAAAyO,EAAAzQ,UAAAS,WAAAR,OAAA6B,eAAA2O,EAAAzQ,WAAA,2BAAAsE,MAAAxF,KAAAwF,KAA+B6M,GACvD,MAAVA,GAAoC,IAAlBA,EAAOnQ,OAA7B,CAGA,GAAMoQ,GAAQC,EAA6B/M,KAAM6M,EAC7CC,IAAS,IAIX9M,KAAKgN,IAA0B,EAC/BhN,KAAKwL,cAAgBsB,EACrB9M,KAAKgN,IAA0B,OA/EoBpQ,IAAA,gBAAAe,IAAA,WAmDrD,MAAAD,GAAAyO,EAAAzQ,UAAAS,WAAAR,OAAA6B,eAAA2O,EAAAzQ,WAAA,gBAAAsE,OAnDqDhD,IAAA,SAqDrC8P,GACZ,iBAAmBrN,GAAK/D,WAAaqB,EAAAoP,EAAAzQ,UAAAS,WAAAR,OAAA6B,eAAA2O,EAAAzQ,WAAA,gBAAsBoR,EAAtB9M,MACpCA,KAAKgN,IAGRX,EAAiBrM,UA1DkCmM,GAKnB1M,EAgFtC,OAAO0M,GAKT,QAASY,GAA6B9J,EAAS4J,GAG7C,IAAK,GAFCI,GAAmBC,EAAoBjK,GACvCkK,EAAeN,EAAOnQ,OACnBD,EAAI,EAAGA,EAAIwQ,EAAiBvQ,OAAQD,IAAK,CAChD,GAAM2Q,GAAkBH,EAAiBxQ,EACzC,IAAI2Q,EAAgBC,OAAO,EAAGF,KAAkBN,EAC9C,MAAOpQ,GAGX,OAAO,EAKT,QAASyQ,GAAoBjK,GAC3B,IAAKA,EAAQmJ,GAAyB,CACpC,GAAM1E,GAAQzE,EAAQyE,KACtBzE,GAAQmJ,GAA0BvJ,MAAMnH,UAAU8H,IAAIhJ,KAAKkN,EAAO,SAAAhH,GAChE,GAAM4M,GAAOrK,EAAQ1D,EAAAxE,QAAQgL,aAAarF,EAC1C,OAAO4M,GAAKC,gBAGhB,MAAOtK,GAAQmJ,GAIjB,QAASG,GAAgBtJ,GACvB,GAAMvG,GAASuG,EAAQuK,GAAqBvK,EAAQuK,GAAmB9Q,OAAS,CAC5EA,GAAS,IACXuG,EAAQuK,GAAqBvK,EAAQuK,GAAmBH,OAAO,EAAG3Q,EAAS,IAE7EuG,EAAQwK,yBAAyBxK,EAAQuK,IACzCE,EAAiBzK,GAInB,QAASyJ,GAAqBzJ,EAAS0K,GACrC,GAAMd,GAAS5J,EAAQuK,IAAsB,EAC7CvK,GAAQuK,GAAqBX,EAASc,EAAKJ,cAC3CtK,EAAQwK,yBAAyBxK,EAAQuK,IACzCE,EAAiBzK,GAInB,QAAS2K,GAAmB3K,GACtBA,EAAQ4K,KACVC,aAAa7K,EAAQ4K,IACrB5K,EAAQ4K,IAAuB,GAKnC,QAASxB,GAAiBpJ,GACxBA,EAAQuK,GAAqB,GAC7BI,EAAmB3K,GAIrB,QAASyK,GAAiBzK,GACxB2K,EAAmB3K,GACnBA,EAAQ4K,GAAuBE,WAAW,WACxC1B,EAAiBpJ,IAChB+K,EAAAjT,QAAUkT,yBfwzDdtS,OAAOS,eAAehC,EAAS,cAC7B0B,OAAO,GAGT,IAAIO,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWZ,WAAaY,EAAWZ,aAAc,EAAOY,EAAWV,cAAe,EAAU,SAAWU,KAAYA,EAAWX,UAAW,GAAML,OAAOS,eAAeG,EAAQI,EAAWC,IAAKD,IAAiB,MAAO,UAAUzB,EAAa2B,EAAYC,GAAiJ,MAA9HD,IAAYP,EAAiBpB,EAAYQ,UAAWmB,GAAiBC,GAAaR,EAAiBpB,EAAa4B,GAAqB5B,MAE5hB6B,EAAO,QAASC,GAAIC,EAAQC,EAAUpB,EAAOqB,GAAY,GAAIC,GAAOzB,OAAO0B,yBAAyBJ,EAAQC,EAAW,IAAaI,SAATF,EAAoB,CAAE,GAAIG,GAAS5B,OAAO6B,eAAeP,EAAwB,QAAXM,GAAmBP,EAAIO,EAAQL,EAAUpB,EAAOqB,OAAoB,IAAI,SAAWC,IAAQA,EAAKpB,SAAYoB,EAAKtB,MAAQA,MAAc,CAAE,GAAI2B,GAASL,EAAKJ,GAAoBM,UAAXG,GAAwBA,EAAOjD,KAAK2C,EAAUrB,GAAY,MAAOA,IAEta4B,EAAO,QAASC,GAAIV,EAAQC,EAAUC,GAA2B,OAAXF,IAAiBA,EAASW,SAASlC,UAAW,IAAI0B,GAAOzB,OAAO0B,yBAAyBJ,EAAQC,EAAW,IAAaI,SAATF,EAAoB,CAAE,GAAIG,GAAS5B,OAAO6B,eAAeP,EAAS,OAAe,QAAXM,EAAmB,OAAkCI,EAAIJ,EAAQL,EAAUC,GAAoB,GAAI,SAAWC,GAAQ,MAAOA,GAAKtB,KAAgB,IAAI+B,GAAST,EAAKO,GAAK,IAAeL,SAAXO,EAA4C,MAAOA,GAAOrD,KAAK2C,GAE5d/C,GAAQW,Qe19DemR,CApDxB,IAAAgC,GAAAjU,EAAA,IfkhEK+T,EAAcpT,EAAuBsT,GejhE1CtI,EAAA3L,EAAA,GfqhEK4L,EAAWjL,EAAuBgL,GephEvCtG,EAAArF,EAAA,GfwhEKsF,EAAY3E,EAAuB0E,GephElC8M,GAAyB,EAAAvG,EAAA9K,SAAO,oBAChCyS,GAAoB,EAAA3H,EAAA9K,SAAO,eAC3B8S,GAAsB,EAAAhI,EAAA9K,SAAO,iBAC7BiS,GAAyB,EAAAnH,EAAA9K,SAAO,qBfiwEhC,SAASV,EAAQD,GAEtB,YAEAuB,QAAOS,eAAehC,EAAS,cAC7B0B,OAAO,GgBzwEV,IAAMqS,IAQJF,wBAAyB,IhBqxE1B7T,GAAQW,QgBhxEMoT,GhBoxET,SAAS9T,EAAQD,EAASH,GAE/B,YA+GA,SAASW,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GAEvF,QAASG,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAEhH,QAASC,GAA2BC,EAAMb,GAAQ,IAAKa,EAAQ,KAAM,IAAIC,gBAAe,4DAAgE,QAAOd,GAAyB,gBAATA,IAAqC,kBAATA,GAA8Ba,EAAPb,EAElO,QAASe,GAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAIN,WAAU,iEAAoEM,GAAeD,GAASE,UAAYC,OAAOC,OAAOH,GAAcA,EAAWC,WAAaG,aAAeC,MAAON,EAAUO,YAAY,EAAOC,UAAU,EAAMC,cAAc,KAAeR,IAAYE,OAAOO,eAAiBP,OAAOO,eAAeV,EAAUC,GAAcD,EAASW,UAAYV,GAnHjeE,OAAOS,eAAehC,EAAS,cAC7B0B,OAAO,GAGT,IAAIO,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWZ,WAAaY,EAAWZ,aAAc,EAAOY,EAAWV,cAAe,EAAU,SAAWU,KAAYA,EAAWX,UAAW,GAAML,OAAOS,eAAeG,EAAQI,EAAWC,IAAKD,IAAiB,MAAO,UAAUzB,EAAa2B,EAAYC,GAAiJ,MAA9HD,IAAYP,EAAiBpB,EAAYQ,UAAWmB,GAAiBC,GAAaR,EAAiBpB,EAAa4B,GAAqB5B,MAE5hB6B,EAAO,QAASC,GAAIC,EAAQC,EAAUpB,EAAOqB,GAAY,GAAIC,GAAOzB,OAAO0B,yBAAyBJ,EAAQC,EAAW,IAAaI,SAATF,EAAoB,CAAE,GAAIG,GAAS5B,OAAO6B,eAAeP,EAAwB,QAAXM,GAAmBP,EAAIO,EAAQL,EAAUpB,EAAOqB,OAAoB,IAAI,SAAWC,IAAQA,EAAKpB,SAAYoB,EAAKtB,MAAQA,MAAc,CAAE,GAAI2B,GAASL,EAAKJ,GAAoBM,UAAXG,GAAwBA,EAAOjD,KAAK2C,EAAUrB,GAAY,MAAOA,IAEta4B,EAAO,QAASC,GAAIV,EAAQC,EAAUC,GAA2B,OAAXF,IAAiBA,EAASW,SAASlC,UAAW,IAAI0B,GAAOzB,OAAO0B,yBAAyBJ,EAAQC,EAAW,IAAaI,SAATF,EAAoB,CAAE,GAAIG,GAAS5B,OAAO6B,eAAeP,EAAS,OAAe,QAAXM,EAAmB,OAAkCI,EAAIJ,EAAQL,EAAUC,GAAoB,GAAI,SAAWC,GAAQ,MAAOA,GAAKtB,KAAgB,IAAI+B,GAAST,EAAKO,GAAK,IAAeL,SAAXO,EAA4C,MAAOA,GAAOrD,KAAK2C,GAE5d/C,GAAQW,QiB3wEM,SAAU0E,GAAM,GAKvB2O,GALuB,SAAArO,GAAA,QAAAqO,KAAA,MAAApT,GAAAgF,KAAAoO,GAAAhT,EAAA4E,MAAAoO,EAAAjS,WAAAR,OAAA6B,eAAA4Q,IAAAnO,MAAAD,KAAAE,YAAA,MAAA3E,GAAA6S,EAAArO,GAAA1D,EAAA+R,IAAAxR,IAAA,oBAAAd,MAAA,WAQzB4B,EAAA0Q,EAAA1S,UAAAS,WAAAR,OAAA6B,eAAA4Q,EAAA1S,WAAA,oBAAAsE,OAA+BtC,EAAA0Q,EAAA1S,UAAAS,WAAAR,OAAA6B,eAAA4Q,EAAA1S,WAAA,oBAAAsE,MAAAxF,KAAAwF,MAGE,MAA7BA,KAAKiB,aAAa,SAAmBjB,KAAKT,EAAAxE,QAAQ+F,UAAUuN,MAC9DrO,KAAKkB,aAAa,OAAQlB,KAAKT,EAAAxE,QAAQ+F,UAAUuN,SAZ1BzR,IAuB1B2C,EAAAxE,QAAQuL,UAvBkBxK,MAAA,SAuBP4E,GAkBlB,GAjBAhD,EAAA0Q,EAAA1S,UAAAS,WAAAR,OAAA6B,eAAA4Q,EAAA1S,WAAU6D,EAAAxE,QAAQuL,UAAlBtG,OAAgCtC,EAAA0Q,EAAA1S,UAAAS,WAAAR,OAAA6B,eAAA4Q,EAAA1S,WAAM6D,EAAAxE,QAAQuL,UAAdtG,MAAAxF,KAAAwF,KAAyBU,GAEpDA,EAAKO,aAAa,SAErBP,EAAKQ,aAAa,OAAQlB,KAAKT,EAAAxE,QAAQ+F,UAAUwN,WAa9C5N,EAAKpG,GAAI,CACZ,GAAMiU,GAASvO,KAAK1F,GAChB,IAAM0F,KAAK1F,GAAK,SAChB,SACJoG,GAAKpG,GAAKiU,EAASC,QA7CI5R,IAiD1B2C,EAAAxE,QAAQ0F,aAjDkB3E,MAAA,SAiDJ4E,EAAMC,GAC3BjD,EAAA0Q,EAAA1S,UAAAS,WAAAR,OAAA6B,eAAA4Q,EAAA1S,WAAU6D,EAAAxE,QAAQ0F,aAAlBT,OAAmCtC,EAAA0Q,EAAA1S,UAAAS,WAAAR,OAAA6B,eAAA4Q,EAAA1S,WAAM6D,EAAAxE,QAAQ0F,aAAdT,MAAAxF,KAAAwF,KAA4BU,EAAMC;AACrED,EAAKQ,aAAa,gBAAiBP,EACnC,IAAM8N,GAAS/N,EAAKpG,EAChBmU,IAAU9N,GACZX,KAAKkB,aAAa,wBAAyBuN,MAtDpB7R,IAgBtB2C,EAAAxE,QAAQ+F,SAhBcnD,IAAA,WAiBzB,GAAMmD,GAAWpD,EAAA0Q,EAAA1S,UAAAS,WAAAR,OAAA6B,eAAA4Q,EAAA1S,WAAM6D,EAAAxE,QAAQ+F,SAAdd,SAGjB,OAFAc,GAASuN,KAAO,UAChBvN,EAASwN,SAAW,SACbxN,KApBkBlE,IAAA,eAAAe,IAAA,WA2DzB,MAAAD,GAAA0Q,EAAA1S,UAAAS,WAAAR,OAAA6B,eAAA4Q,EAAA1S,WAAA,eAAAsE,OA3DyBhD,IAAA,SA6DV0D,GACX,gBAAkBjB,GAAK/D,WAAaqB,EAAAqR,EAAA1S,UAAAS,WAAAR,OAAA6B,eAAA4Q,EAAA1S,WAAA,eAAqBgF,EAArBV,MAC5B,MAARU,GAEFV,KAAK0O,gBAAgB,6BAjEEN,GAKD3O,EAkE5B,OAAO2O,GAjHT,IAAA9O,GAAArF,EAAA,GjBs5EKsF,EAAY3E,EAAuB0E,GiBl5EpCkP,EAAU,GjBq8ER,SAASnU,EAAQD,EAASH,GAE/B,YAoBA,SAASW,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GAEvF,QAASG,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAEhH,QAASC,GAA2BC,EAAMb,GAAQ,IAAKa,EAAQ,KAAM,IAAIC,gBAAe,4DAAgE,QAAOd,GAAyB,gBAATA,IAAqC,kBAATA,GAA8Ba,EAAPb,EAElO,QAASe,GAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAIN,WAAU,iEAAoEM,GAAeD,GAASE,UAAYC,OAAOC,OAAOH,GAAcA,EAAWC,WAAaG,aAAeC,MAAON,EAAUO,YAAY,EAAOC,UAAU,EAAMC,cAAc,KAAeR,IAAYE,OAAOO,eAAiBP,OAAOO,eAAeV,EAAUC,GAAcD,EAASW,UAAYV,GAxBjeE,OAAOS,eAAehC,EAAS,cAC7B0B,OAAO,GAGT,IAAIO,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWZ,WAAaY,EAAWZ,aAAc,EAAOY,EAAWV,cAAe,EAAU,SAAWU,KAAYA,EAAWX,UAAW,GAAML,OAAOS,eAAeG,EAAQI,EAAWC,IAAKD,IAAiB,MAAO,UAAUzB,EAAa2B,EAAYC,GAAiJ,MAA9HD,IAAYP,EAAiBpB,EAAYQ,UAAWmB,GAAiBC,GAAaR,EAAiBpB,EAAa4B,GAAqB5B,MAE5hB6B,EAAO,QAASC,GAAIC,EAAQC,EAAUpB,EAAOqB,GAAY,GAAIC,GAAOzB,OAAO0B,yBAAyBJ,EAAQC,EAAW,IAAaI,SAATF,EAAoB,CAAE,GAAIG,GAAS5B,OAAO6B,eAAeP,EAAwB,QAAXM,GAAmBP,EAAIO,EAAQL,EAAUpB,EAAOqB,OAAoB,IAAI,SAAWC,IAAQA,EAAKpB,SAAYoB,EAAKtB,MAAQA,MAAc,CAAE,GAAI2B,GAASL,EAAKJ,GAAoBM,UAAXG,GAAwBA,EAAOjD,KAAK2C,EAAUrB,GAAY,MAAOA,IAEta4B,EAAO,QAASC,GAAIV,EAAQC,EAAUC,GAA2B,OAAXF,IAAiBA,EAASW,SAASlC,UAAW,IAAI0B,GAAOzB,OAAO0B,yBAAyBJ,EAAQC,EAAW,IAAaI,SAATF,EAAoB,CAAE,GAAIG,GAAS5B,OAAO6B,eAAeP,EAAS,OAAe,QAAXM,EAAmB,OAAkCI,EAAIJ,EAAQL,EAAUC,GAAoB,GAAI,SAAWC,GAAQ,MAAOA,GAAKtB,KAAgB,IAAI+B,GAAST,EAAKO,GAAK,IAAeL,SAAXO,EAA4C,MAAOA,GAAOrD,KAAK2C,IkBr9E7dwO,EAAA1R,EAAA,IlBy9EK2P,EAAwBhP,EAAuB+Q,GkBx9EpDrM,EAAArF,EAAA,GlB49EKsF,EAAY3E,EAAuB0E,EAyBvClF,GAAQW,QkBn+EM,SAAC0E,GAAS,GAKjBkP,GALiB,SAAA5O,GAAA,QAAA4O,KAAA,MAAA3T,GAAAgF,KAAA2O,GAAAvT,EAAA4E,MAAA2O,EAAAxS,WAAAR,OAAA6B,eAAAmR,IAAA1O,MAAAD,KAAAE,YAAA,MAAA3E,GAAAoT,EAAA5O,GAAA1D,EAAAsS,IAAA/R,IAAA,oBAAAd,MAAA,WAQnB4B,EAAAiR,EAAAjT,UAAAS,WAAAR,OAAA6B,eAAAmR,EAAAjT,WAAA,oBAAAsE,OAA+BtC,EAAAiR,EAAAjT,UAAAS,WAAAR,OAAA6B,eAAAmR,EAAAjT,WAAA,oBAAAsE,MAAAxF,KAAAwF,KAC/B,IAAMqH,GAAerH,KAAKqH,YACtBA,IACFrH,KAAK4O,mBAAmBvH,MAXPzK,IAAA,qBAAAd,MAAA,SA6BF4E,GACjBhD,EAAAiR,EAAAjT,UAAAS,WAAAR,OAAA6B,eAAAmR,EAAAjT,WAAA,qBAAAsE,OAAgCtC,EAAAiR,EAAAjT,UAAAS,WAAAR,OAAA6B,eAAAmR,EAAAjT,WAAA,qBAAAsE,MAAAxF,KAAAwF,KAEhC,IAAM2J,GAAe3J,KAAKT,EAAAxE,QAAQ4O,cAK5BkF,EAAmBlF,EAAamF,wBAChCC,EAAWrO,EAAKoO,wBAGhBE,EAAcD,EAASE,OAASJ,EAAiBI,OACjDC,EAAWH,EAASI,IAAMN,EAAiBM,IAC3CC,EAAYL,EAASM,KAAOR,EAAiBQ,KAC7CC,EAAaP,EAASQ,MAAQV,EAAiBU,KAGjDP,GAAc,EAChBrF,EAAa2B,WAAa0D,EACjBE,EAAW,IACpBvF,EAAa2B,WAAakE,KAAKC,KAAKP,IAElCI,EAAa,EACf3F,EAAa+F,YAAcJ,EAClBF,EAAY,IACrBzF,EAAa+F,YAAcF,KAAKC,KAAKL,OAvDpBxS,IA4DhB2C,EAAAxE,QAAQ4O,aA5DQhM,IAAA,WA6DnB,MAAOD,GAAAiR,EAAAjT,UAAAS,WAAAR,OAAA6B,eAAAmR,EAAAjT,WAAM6D,EAAAxE,QAAQ4O,aAAd3J,QAA+B,EAAA4J,EAAA7O,SAAoBiF,SA7DvCpD,IAAA,eAAAe,IAAA,WAiEnB,MAAAD,GAAAiR,EAAAjT,UAAAS,WAAAR,OAAA6B,eAAAmR,EAAAjT,WAAA,eAAAsE,OAjEmBhD,IAAA,SAmEJ0D,GACX,gBAAkBjB,GAAK/D,WAAaqB,EAAA4R,EAAAjT,UAAAS,WAAAR,OAAA6B,eAAAmR,EAAAjT,WAAA,eAAqBgF,EAArBV,MACpCU,GAEFV,KAAK4O,mBAAmBlO,OAvEPiO,GAKOlP,EAuE9B,OAAOkP,KlBigFH,SAAStU,EAAQD,EAASH,GAE/B,YAgBA,SAASW,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GAEvF,QAASG,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAEhH,QAASC,GAA2BC,EAAMb,GAAQ,IAAKa,EAAQ,KAAM,IAAIC,gBAAe,4DAAgE,QAAOd,GAAyB,gBAATA,IAAqC,kBAATA,GAA8Ba,EAAPb,EAElO,QAASe,GAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAIN,WAAU,iEAAoEM,GAAeD,GAASE,UAAYC,OAAOC,OAAOH,GAAcA,EAAWC,WAAaG,aAAeC,MAAON,EAAUO,YAAY,EAAOC,UAAU,EAAMC,cAAc,KAAeR,IAAYE,OAAOO,eAAiBP,OAAOO,eAAeV,EAAUC,GAAcD,EAASW,UAAYV,GmBjlFnd,QAASkU,GAAoBlQ,GAAM,GAK1CmQ,GAL0C,SAAA7P,GAW9C,QAAA6P,KAAc5U,EAAAgF,KAAA4P,EAAA,IAAAhO,GAAAxG,EAAA4E,MAAA4P,EAAAzT,WAAAR,OAAA6B,eAAAoS,IAAApV,KAAAwF,OAGN6P,EAAMjO,EAAKqC,UACb1C,EAAWuO,EAAiBD,EAGhC,KAAKtO,EAAU,CAKb,GADAA,EAAWK,EAAKrC,EAAAxE,QAAQwG,WACnBA,EAEH,MADA+F,SAAQC,KAAR,2FACAnM,EAAAwG,EAGF,IAAwB,gBAAbL,GAAuB,CAEhC,GAAMwO,GAAexO,CACrBA,GAAW+D,SAAS0K,cAAc,YAClCzO,EAAS0O,UAAYF,EAGnBlJ,OAAOqJ,UAETrJ,OAAOqJ,SAASC,gBAAgB5O,EAAUsO,GAI5CC,EAAiBD,GAAOtO,EAI1B,GAAMwK,GAAOnK,EAAKwO,cAAeC,KAAM,SACjCC,EAAQhL,SAASiL,WAAWhP,EAASgB,SAAS,EAnCxC,OAoCZwJ,GAAKyE,YAAYF,GAGb1O,EAAKrC,EAAAxE,QAAQgH,gBACfH,EAAKrC,EAAAxE,QAAQgH,iBAxCHH,EAXgC,MAAArG,GAAAqU,EAAA7P,GAAA1D,EAAAuT,IAAAhT,IAAA,oBAAAd,MAAA,WAwD5C4B,EAAAkS,EAAAlU,UAAAS,WAAAR,OAAA6B,eAAAoS,EAAAlU,WAAA,oBAAAsE,OAA+BtC,EAAAkS,EAAAlU,UAAAS,WAAAR,OAAA6B,eAAAoS,EAAAlU,WAAA,oBAAAsE,MAAAxF,KAAAwF,MAC3B6G,OAAOqJ,UACTrJ,OAAOqJ,SAASO,WAAWzQ,UA1De4P,GAKnBnQ,EA2D7B,OAAOmQ,GnB6/ERjU,OAAOS,eAAehC,EAAS,cAC7B0B,OAAO,GAGT,IAAIO,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWZ,WAAaY,EAAWZ,aAAc,EAAOY,EAAWV,cAAe,EAAU,SAAWU,KAAYA,EAAWX,UAAW,GAAML,OAAOS,eAAeG,EAAQI,EAAWC,IAAKD,IAAiB,MAAO,UAAUzB,EAAa2B,EAAYC,GAAiJ,MAA9HD,IAAYP,EAAiBpB,EAAYQ,UAAWmB,GAAiBC,GAAaR,EAAiBpB,EAAa4B,GAAqB5B,MAE5hBwC,EAAO,QAASC,GAAIV,EAAQC,EAAUC,GAA2B,OAAXF,IAAiBA,EAASW,SAASlC,UAAW,IAAI0B,GAAOzB,OAAO0B,yBAAyBJ,EAAQC,EAAW,IAAaI,SAATF,EAAoB,CAAE,GAAIG,GAAS5B,OAAO6B,eAAeP,EAAS,OAAe,QAAXM,EAAmB,OAAkCI,EAAIJ,EAAQL,EAAUC,GAAoB,GAAI,SAAWC,GAAQ,MAAOA,GAAKtB,KAAgB,IAAI+B,GAAST,EAAKO,GAAK,IAAeL,SAAXO,EAA4C,MAAOA,GAAOrD,KAAK2C,GAE5d/C,GAAQW,QmBrkFe4U,CAvCxB,IAAArQ,GAAArF,EAAA,GnBgnFKsF,EAAY3E,EAAuB0E,GmBtmFlCwQ,MnBkuFA,SAASzV,EAAQD,EAASH,GAE/B,YAsBA,SAASW,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GAEvF,QAASG,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAEhH,QAASC,GAA2BC,EAAMb,GAAQ,IAAKa,EAAQ,KAAM,IAAIC,gBAAe,4DAAgE,QAAOd,GAAyB,gBAATA,IAAqC,kBAATA,GAA8Ba,EAAPb,EAElO,QAASe,GAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAIN,WAAU,iEAAoEM,GAAeD,GAASE,UAAYC,OAAOC,OAAOH,GAAcA,EAAWC,WAAaG,aAAeC,MAAON,EAAUO,YAAY,EAAOC,UAAU,EAAMC,cAAc,KAAeR,IAAYE,OAAOO,eAAiBP,OAAOO,eAAeV,EAAUC,GAAcD,EAASW,UAAYV,GoBvtFnd,QAASiV,GAAqBjR,GAAM,GAK3CkR,GAL2C,SAAA5Q,GAO/C,QAAA4Q,KAAc3V,EAAAgF,KAAA2Q,EAAA,IAAA/O,GAAAxG,EAAA4E,MAAA2Q,EAAAxU,WAAAR,OAAA6B,eAAAmT,IAAAnW,KAAAwF,MAAA,OAG0B,mBAA3B4B,GAAKwF,oBACdxF,EAAKwF,kBAAoBxF,EAAKrC,EAAAxE,QAAQ+F,UAAUsG,mBAEf,mBAAxBxF,GAAKgP,iBACdhP,EAAKgP,eAAiBhP,EAAKrC,EAAAxE,QAAQ+F,UAAU8P,gBAPnChP,EAPiC,MAAArG,GAAAoV,EAAA5Q,GAAA1D,EAAAsU,IAAA/T,IAqE9C2C,EAAAxE,QAAQuL,UArEsCxK,MAAA,SAqE3B4E,GAClBhD,EAAAiT,EAAAjV,UAAAS,WAAAR,OAAA6B,eAAAmT,EAAAjV,WAAU6D,EAAAxE,QAAQuL,UAAlBtG,OAAgCtC,EAAAiT,EAAAjV,UAAAS,WAAAR,OAAA6B,eAAAmT,EAAAjV,WAAM6D,EAAAxE,QAAQuL,UAAdtG,MAAAxF,KAAAwF,KAAyBU,GACzDV,KAAKT,EAAAxE,QAAQ0F,cAAcC,EAAMA,IAASV,KAAKqH,iBAvEFzK,IA0E9C2C,EAAAxE,QAAQwL,aA1EsCzK,MAAA,WA2E7C4B,EAAAiT,EAAAjV,UAAAS,WAAAR,OAAA6B,eAAAmT,EAAAjV,WAAU6D,EAAAxE,QAAQwL,aAAlBvG,OAAmCtC,EAAAiT,EAAAjV,UAAAS,WAAAR,OAAA6B,eAAAmT,EAAAjV,WAAM6D,EAAAxE,QAAQwL,aAAdvG,MAAAxF,KAAAwF,MAGnC6Q,EAAkB7Q,MAGlB8Q,EAA0B9Q,SAjFmBpD,IA6F9C2C,EAAAxE,QAAQ0F,aA7FsC3E,MAAA,SA6FxB4E,EAAMC,GAC3BjD,EAAAiT,EAAAjV,UAAAS,WAAAR,OAAA6B,eAAAmT,EAAAjV,WAAU6D,EAAAxE,QAAQ0F,aAAlBT,OAAmCtC,EAAAiT,EAAAjV,UAAAS,WAAAR,OAAA6B,eAAAmT,EAAAjV,WAAM6D,EAAAxE,QAAQ0F,aAAdT,MAAAxF,KAAAwF,KAA4BU,EAAMC,MA9FxB/D,IAAA,cAAAd,MAAA,WAsO7C,MADA4B,GAAAiT,EAAAjV,UAAAS,WAAAR,OAAA6B,eAAAmT,EAAAjV,WAAA,cAAAsE,OAAyBtC,EAAAiT,EAAAjV,UAAAS,WAAAR,OAAA6B,eAAAmT,EAAAjV,WAAA,cAAAsE,MAAAxF,KAAAwF,MAClB+Q,EAAY/Q,KAAM,MAtOoBpD,IAAA,aAAAd,MAAA,WAgS7C,MADA4B,GAAAiT,EAAAjV,UAAAS,WAAAR,OAAA6B,eAAAmT,EAAAjV,WAAA,aAAAsE,OAAwBtC,EAAAiT,EAAAjV,UAAAS,WAAAR,OAAA6B,eAAAmT,EAAAjV,WAAA,aAAAsE,MAAAxF,KAAAwF,MACjB+Q,EAAY/Q,KAAMA,KAAK0H,MAAMhL,OAAS,MAhSAE,IAAA,aAAAd,MAAA,WA4S7C,MADA4B,GAAAiT,EAAAjV,UAAAS,WAAAR,OAAA6B,eAAAmT,EAAAjV,WAAA,aAAAsE,OAAwBtC,EAAAiT,EAAAjV,UAAAS,WAAAR,OAAA6B,eAAAmT,EAAAjV,WAAA,aAAAsE,MAAAxF,KAAAwF,MACjB+Q,EAAY/Q,KAAMA,KAAKwL,cAAgB,MA5SD5O,IAAA,iBAAAd,MAAA,WAuT7C4B,EAAAiT,EAAAjV,UAAAS,WAAAR,OAAA6B,eAAAmT,EAAAjV,WAAA,iBAAAsE,OAA4BtC,EAAAiT,EAAAjV,UAAAS,WAAAR,OAAA6B,eAAAmT,EAAAjV,WAAA,iBAAAsE,MAAAxF,KAAAwF,KAC5B,IAAMyL,GAAWzL,KAAKwL,cAAgB,EACpCxL,KAAK0H,MAAMhL,OAAS,EACpBsD,KAAKwL,cAAgB,CACvB,OAAOuF,GAAY/Q,KAAMyL,MA3ToB7O,IAAA,gBAAAe,IAAA,WAyB7C,MAAOqC,MAAKgR,IAzBiChU,IAAA,SA2B7BiU,GAChB,GAAMjQ,GAAUiQ,IAAkBjR,KAAKgR,EACvChR,MAAKgR,GAAuBC,EACxB,iBAAmBxR,GAAK/D,WAAaqB,EAAA4T,EAAAjV,UAAAS,WAAAR,OAAA6B,eAAAmT,EAAAjV,WAAA,gBAAsBuV,EAAtBjR,MACrCA,KAAKT,EAAAxE,QAAQoG,oBAAsBH,GACrChB,KAAKsB,cAAc,GAAID,aAAY,+BAhCQzE,IAAA,oBAAAe,IAAA,WA2C7C,MAAOqC,MAAKkR,IA3CiClU,IAAA,SA6CzBmU,GACpB,GAAMnQ,GAAUmQ,IAAsBnR,KAAKkR,EAC3ClR,MAAKkR,GAA2BC,EAC5B,qBAAuB1R,GAAK/D,WAAaqB,EAAA4T,EAAAjV,UAAAS,WAAAR,OAAA6B,eAAAmT,EAAAjV,WAAA,oBAA0ByV,EAA1BnR,MACzCA,KAAKT,EAAAxE,QAAQoG,oBAAsBH,GACrChB,KAAKsB,cAAc,GAAID,aAAY,mCAlDQzE,IAsD1C2C,EAAAxE,QAAQ+F,SAtDkCnD,IAAA,WAuD7C,GAAMmD,GAAWpD,EAAAiT,EAAAjV,UAAAS,WAAAR,OAAA6B,eAAAmT,EAAAjV,WAAM6D,EAAAxE,QAAQ+F,SAAdd,SAGjB,OAFAc,GAASsG,mBAAoB,EAC7BtG,EAAS8P,gBAAiB,EACnB9P,KA1DsClE,IAAA,gBAAAe,IAAA,WA4G7C,MAA4C,OAArCqC,KAAKoR,GACVpR,KAAKoR,IACL,GA9G2CpU,IAAA,SAgH7B8P,GAEhB,GAAM9L,GAAU8L,IAAU9M,KAAKqR,GAC3B3Q,SACA4Q,EAAcC,SAASzE,EAC3B,IAAIwE,IAAgBtR,KAAKoR,GAA8B,CAErD,GAAM1J,GAAQ1H,KAAK0H,MACb8J,EAAW9J,GAASA,EAAMhL,OAAS,CACnC8U,IAAYF,GAAe,GAAKA,EAAc5J,EAAMhL,SACxD4U,GAAc,GAEhBtR,KAAKoR,GAA+BE,EACpC5Q,EAAO8Q,GAAYF,GAAe,EAAI5J,EAAM4J,GAAe,KAC3DtR,KAAKyR,GAA8B/Q,MAEnCA,GAAOV,KAAKyR,EAMd,IAFI,iBAAmBhS,GAAK/D,WAAaqB,EAAA4T,EAAAjV,UAAAS,WAAAR,OAAA6B,eAAAmT,EAAAjV,WAAA,gBAAsBoR,EAAtB9M,MAErCgB,IAEFhB,KAAKqR,GAA+BC,EAEhCtR,KAAKT,EAAAxE,QAAQoG,oBAAoB,CACnC,GAAMC,GAAQ,GAAIC,aAAY,0BAC5BqQ,QACElG,cAAe8F,EACfxV,MAAOwV,IAGXtR,MAAKsB,cAAcF,GAInBpB,KAAK2R,KAAgCjR,IAEvCV,KAAKqH,aAAe3G,MAvJuB9D,IAAA,eAAAe,IAAA,WAuK7C,MAAOqC,MAAKyR,IAA+B,MAvKEzU,IAAA,SAyK9B0D,GAEf,GAAMkR,GAAuB5R,KAAK2R,GAC5B3Q,EAAUN,IAASkR,EACrB9E,QACJ,IAAIpM,IAASV,KAAKyR,GAA6B,CAE7C,GAAM/J,GAAQ1H,KAAK0H,MACb8J,EAAW9J,GAASA,EAAMhL,OAAS,CACzCoQ,GAAQ0E,EAAW3O,MAAMnH,UAAUwI,QAAQ1J,KAAKkN,EAAOhH,IAAQ,EAC/DV,KAAKoR,GAA+BtE,EAChCA,EAAQ,IACVpM,EAAO,MAETV,KAAKyR,GAA8B/Q,MAEnCoM,GAAQ9M,KAAKoR,EAMf,IAFI,gBAAkB3R,GAAK/D,WAAaqB,EAAA4T,EAAAjV,UAAAS,WAAAR,OAAA6B,eAAAmT,EAAAjV,WAAA,eAAqBgF,EAArBV,MAEpCgB,IAEFhB,KAAK2R,GAA8BjR,EAE/BkR,GAEF5R,KAAKT,EAAAxE,QAAQ0F,cAAcmR,GAAsB,GAE/ClR,GAEFV,KAAKT,EAAAxE,QAAQ0F,cAAcC,GAAM,GAGnCoQ,EAA0B9Q,MAEtBA,KAAKT,EAAAxE,QAAQoG,oBAAoB,CACnC,GAAMC,GAAQ,GAAIC,aAAY,yBAC5BqQ,QACErK,aAAc3G,EACd5E,MAAO4E,IAGXV,MAAKsB,cAAcF,GAInBpB,KAAKqR,KAAiCvE,IAExC9M,KAAKwL,cAAgBsB,MA3NsBlQ,IAAA,oBAAAe,IAAA,WAgP7C,MAAOqC,MAAK6R,IAhPiC7U,IAAA,SAkPzBoK,GACpB,GAAM0K,GAAuC,SAA9BnF,OAAOvF,GAChBpG,EAAU8Q,IAAW9R,KAAK6R,EAGhC,IAFA7R,KAAK6R,GAA2BC,EAC5B,qBAAuBrS,GAAK/D,WAAaqB,EAAA4T,EAAAjV,UAAAS,WAAAR,OAAA6B,eAAAmT,EAAAjV,WAAA,oBAA0B0L,EAA1BpH,MACzCgB,EAAS,CACX,GAAIhB,KAAKT,EAAAxE,QAAQoG,mBAAoB,CACnC,GAAMC,GAAQ,GAAIC,aAAY,6BAC9BrB,MAAKsB,cAAcF,GAEjBgG,GACFyJ,EAAkB7Q,UA7PuBpD,IAAA,iBAAAe,IAAA,WAyQ7C,MAAOqC,MAAK+R,IAzQiC/U,IAAA,SA2Q5B4T,GACjB,GAAMkB,GAAoC,SAA3BnF,OAAOiE,GAChB5P,EAAU8Q,IAAW9R,KAAK+R,EAGhC,IAFA/R,KAAK+R,GAAwBD,EACzB,kBAAoBrS,GAAK/D,WAAaqB,EAAA4T,EAAAjV,UAAAS,WAAAR,OAAA6B,eAAAmT,EAAAjV,WAAA,iBAAuBkV,EAAvB5Q,MACtCgB,EAAS,CACX,GAAIhB,KAAKT,EAAAxE,QAAQoG,mBAAoB,CACnC,GAAMC,GAAQ,GAAIC,aAAY,0BAC9BrB,MAAKsB,cAAcF,GAErB0P,EAA0B9Q,WArRiB2Q,GAKnBlR,EA6V9B,OAAOkR,GAMT,QAASI,GAAY9N,EAAS6J,GAE5B,GAAMpF,GAAQzE,EAAQyE,KACtB,IAAa,MAATA,EAEF,OAAO,CAGT,IAAMf,GAAQe,EAAMhL,OACdsV,EAAe/O,EAAQ2N,gBAGzB9D,EAAQnG,EAASA,GAASA,EAG5B6I,KAAKyC,IAAIzC,KAAK0C,IAAIpF,EAAOnG,EAAQ,GAAI,GAEjCwL,EAAgBlP,EAAQuI,aAC9B,OAAI2G,KAAkBH,IACpB/O,EAAQuI,cAAgBwG,GACjB,GAUX,QAASnB,GAAkB5N,GAEzB,GAAMyE,GAAQzE,EAAQyE,MAChBC,EAAYD,EAAQA,EAAMhL,OAAS,EAEnCkV,EAAuB3O,EAAQoE,YACrC,IAAKuK,EAME,GAAkB,IAAdjK,EAET1E,EAAQoE,aAAe,SAClB,CAEL,GAAM+K,GAAsBvP,MAAMnH,UAAUwI,QAAQ1J,KAAKkN,EAAOkK,GAC1DS,EAAwBpP,EAAQuI,aACtC,IAAI4G,EAAsB,EAAG,CAG3B,GAAME,GAAmB9C,KAAK0C,IAAIG,EAAuB1K,EAAY,EAGrE1E,GAAQoE,aAAeK,EAAM4K,OACpBF,KAAwBC,IAEjCpP,EAAQuI,cAAgB4G,OApBtBnP,GAAQmE,oBAEVnE,EAAQuI,cAAgB,GAyB9B,QAASsF,GAA0B7N,GACjC,GAAIgO,UACAE,SACEzJ,EAAQzE,EAAQyE,KACtB,IAAa,MAATA,GAAkC,IAAjBA,EAAMhL,OAEzBuU,GAAgB,EAChBE,GAAoB,MACf,IAAIlO,EAAQ2N,eAEjBK,GAAgB,EAChBE,GAAoB,MACf,CACL,GAAMrE,GAAQ7J,EAAQuI,aAClBsB,GAAQ,GAAKpF,EAAMhL,OAAS,GAG9BuU,GAAgB,EAChBE,GAAoB,IAGpBA,EAAqBrE,EAAQ,EAC7BmE,EAAiBnE,EAAQpF,EAAMhL,OAAS,GAGxCuG,EAAQgO,gBAAkBA,IAC5BhO,EAAQgO,cAAgBA,GAEtBhO,EAAQkO,oBAAsBA,IAChClO,EAAQkO,kBAAoBA,GpBuvE/BxV,OAAOS,eAAehC,EAAS,cAC7B0B,OAAO,GAGT,IAAIO,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWZ,WAAaY,EAAWZ,aAAc,EAAOY,EAAWV,cAAe,EAAU,SAAWU,KAAYA,EAAWX,UAAW,GAAML,OAAOS,eAAeG,EAAQI,EAAWC,IAAKD,IAAiB,MAAO,UAAUzB,EAAa2B,EAAYC,GAAiJ,MAA9HD,IAAYP,EAAiBpB,EAAYQ,UAAWmB,GAAiBC,GAAaR,EAAiBpB,EAAa4B,GAAqB5B,MAE5hBwC,EAAO,QAASC,GAAIV,EAAQC,EAAUC,GAA2B,OAAXF,IAAiBA,EAASW,SAASlC,UAAW,IAAI0B,GAAOzB,OAAO0B,yBAAyBJ,EAAQC,EAAW,IAAaI,SAATF,EAAoB,CAAE,GAAIG,GAAS5B,OAAO6B,eAAeP,EAAS,OAAe,QAAXM,EAAmB,OAAkCI,EAAIJ,EAAQL,EAAUC,GAAoB,GAAI,SAAWC,GAAQ,MAAOA,GAAKtB,KAAgB,IAAI+B,GAAST,EAAKO,GAAK,IAAeL,SAAXO,EAA4C,MAAOA,GAAOrD,KAAK2C,IAExdJ,EAAO,QAASC,GAAIC,EAAQC,EAAUpB,EAAOqB,GAAY,GAAIC,GAAOzB,OAAO0B,yBAAyBJ,EAAQC,EAAW,IAAaI,SAATF,EAAoB,CAAE,GAAIG,GAAS5B,OAAO6B,eAAeP,EAAwB,QAAXM,GAAmBP,EAAIO,EAAQL,EAAUpB,EAAOqB,OAAoB,IAAI,SAAWC,IAAQA,EAAKpB,SAAYoB,EAAKtB,MAAQA,MAAc,CAAE,GAAI2B,GAASL,EAAKJ,GAAoBM,UAAXG,GAAwBA,EAAOjD,KAAK2C,EAAUrB,GAAY,MAAOA,GAE1a1B,GAAQW,QoBvsFe2V,CAnDxB,IAAA9K,GAAA3L,EAAA,GpB8vFK4L,EAAWjL,EAAuBgL,GoB7vFvCtG,EAAArF,EAAA,GpBiwFKsF,EAAY3E,EAAuB0E,GoB7vFlC0R,GAAsB,EAAAnL,EAAA9K,SAAO,iBAC7BmW,GAA0B,EAAArL,EAAA9K,SAAO,qBACjC8W,GAA0B,EAAAhM,EAAA9K,SAAO,qBACjCgX,GAAuB,EAAAlM,EAAA9K,SAAO,kBAmB9BqW,GAA8B,EAAAvL,EAAA9K,SAAO,yBACrC0W,GAA6B,EAAA5L,EAAA9K,SAAO,wBACpCsW,GAA8B,EAAAxL,EAAA9K,SAAO,yBACrC4W,GAA6B,EAAA9L,EAAA9K,SAAO,yBpB6yGpC,SAASV,EAAQD,EAASH,GAE/B,YAkBA,SAASW,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GAEvF,QAASG,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAEhH,QAASC,GAA2BC,EAAMb,GAAQ,IAAKa,EAAQ,KAAM,IAAIC,gBAAe,4DAAgE,QAAOd,GAAyB,gBAATA,IAAqC,kBAATA,GAA8Ba,EAAPb,EAElO,QAASe,GAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAIN,WAAU,iEAAoEM,GAAeD,GAASE,UAAYC,OAAOC,OAAOH,GAAcA,EAAWC,WAAaG,aAAeC,MAAON,EAAUO,YAAY,EAAOC,UAAU,EAAMC,cAAc,KAAeR,IAAYE,OAAOO,eAAiBP,OAAOO,eAAeV,EAAUC,GAAcD,EAASW,UAAYV,GAtBjeE,OAAOS,eAAehC,EAAS,cAC7B0B,OAAO,GAGT,IAAIO,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWZ,WAAaY,EAAWZ,aAAc,EAAOY,EAAWV,cAAe,EAAU,SAAWU,KAAYA,EAAWX,UAAW,GAAML,OAAOS,eAAeG,EAAQI,EAAWC,IAAKD,IAAiB,MAAO,UAAUzB,EAAa2B,EAAYC,GAAiJ,MAA9HD,IAAYP,EAAiBpB,EAAYQ,UAAWmB,GAAiBC,GAAaR,EAAiBpB,EAAa4B,GAAqB5B,MAE5hBwC,EAAO,QAASC,GAAIV,EAAQC,EAAUC,GAA2B,OAAXF,IAAiBA,EAASW,SAASlC,UAAW,IAAI0B,GAAOzB,OAAO0B,yBAAyBJ,EAAQC,EAAW,IAAaI,SAATF,EAAoB,CAAE,GAAIG,GAAS5B,OAAO6B,eAAeP,EAAS,OAAe,QAAXM,EAAmB,OAAkCI,EAAIJ,EAAQL,EAAUC,GAAoB,GAAI,SAAWC,GAAQ,MAAOA,GAAKtB,KAAgB,IAAI+B,GAAST,EAAKO,GAAK,IAAeL,SAAXO,EAA4C,MAAOA,GAAOrD,KAAK2C,IqBr1G7dkC,EAAApF,EAAA,IrBy1GKsY,EAAyB3X,EAAuByE,GqBx1GrDC,EAAArF,EAAA,GrB41GKsF,EAAY3E,EAAuB0E,GqBp1GnBkT,ErBm2GM,SAAUpT,GqBj2GnC,QAAAoT,KAAcxX,EAAAgF,KAAAwS,EAAA,IAAA5Q,GAAAxG,EAAA4E,MAAAwS,EAAArW,WAAAR,OAAA6B,eAAAgV,IAAAhY,KAAAwF,MAAA,OAEZ4B,GAAKU,iBAAiB,YAAa,SAAAlB,GACjCQ,EAAKrC,EAAAxE,QAAQoG,oBAAqB,EAClCS,EAAKyF,aAAejG,EAAM7E,OAC1B6E,EAAMoG,kBACN5F,EAAKrC,EAAAxE,QAAQoG,oBAAqB,IANxBS,ErBs5Gb,MApDArG,GAAUiX,EAAqBpT,GAgB/B/C,EAAamW,IACX5V,IAAK,2BACLd,MAAO,SqB12GeqE,EAAeC,EAAUC,GAChD3C,EAAA8U,EAAA9W,UAAAS,WAAAR,OAAA6B,eAAAgV,EAAA9W,WAAA,2BAAAsE,OAAsCtC,EAAA8U,EAAA9W,UAAAS,WAAAR,OAAA6B,eAAAgV,EAAA9W,WAAA,2BAAAsE,MAAAxF,KAAAwF,KAA+BG,EAAeC,EAAUC,GACxE,mBAAlBF,IACFH,KAAKwL,cAAgBnL,MrBm3GtBzD,IqB92GF2C,EAAAxE,QAAQ0F,arB+2GN3E,MAAO,SqB/2Ga4E,EAAMC,GAC3BjD,EAAA8U,EAAA9W,UAAAS,WAAAR,OAAA6B,eAAAgV,EAAA9W,WAAU6D,EAAAxE,QAAQ0F,aAAlBT,OAAmCtC,EAAA8U,EAAA9W,UAAAS,WAAAR,OAAA6B,eAAAgV,EAAA9W,WAAM6D,EAAAxE,QAAQ0F,aAAdT,MAAAxF,KAAAwF,KAA4BU,EAAMC,GACrED,EAAKE,UAAUC,OAAO,WAAYF,MrBu3GjC/D,IAAK,QACLe,IAAK,WqBn3GN,MAAOqC,MAAKmD,crBu3GXvG,IAAK,qBACLe,IAAK,WqBp3GN,OAAQ,sBrBy3GF6U,IqBx5GuC,EAAAD,EAAAxX,SAAqB8E,arB25GrEzF,GAAQW,QqB35GYyX,EAqCrBhR,eAAeC,OAAO,wBAAyB+Q","file":"demos.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1);\n\tmodule.exports = __webpack_require__(20);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _set = function set(object, property, value, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent !== null) { set(parent, property, value, receiver); } } else if (\"value\" in desc && desc.writable) { desc.value = value; } else { var setter = desc.set; if (setter !== undefined) { setter.call(receiver, value); } } return value; };\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tvar _ChildrenContentMixin = __webpack_require__(2);\n\t\n\tvar _ChildrenContentMixin2 = _interopRequireDefault(_ChildrenContentMixin);\n\t\n\tvar _ClickSelectionMixin = __webpack_require__(7);\n\t\n\tvar _ClickSelectionMixin2 = _interopRequireDefault(_ClickSelectionMixin);\n\t\n\tvar _ContentItemsMixin = __webpack_require__(8);\n\t\n\tvar _ContentItemsMixin2 = _interopRequireDefault(_ContentItemsMixin);\n\t\n\tvar _DirectionSelectionMixin = __webpack_require__(9);\n\t\n\tvar _DirectionSelectionMixin2 = _interopRequireDefault(_DirectionSelectionMixin);\n\t\n\tvar _KeyboardDirectionMixin = __webpack_require__(10);\n\t\n\tvar _KeyboardDirectionMixin2 = _interopRequireDefault(_KeyboardDirectionMixin);\n\t\n\tvar _KeyboardMixin = __webpack_require__(11);\n\t\n\tvar _KeyboardMixin2 = _interopRequireDefault(_KeyboardMixin);\n\t\n\tvar _KeyboardPagedSelectionMixin = __webpack_require__(12);\n\t\n\tvar _KeyboardPagedSelectionMixin2 = _interopRequireDefault(_KeyboardPagedSelectionMixin);\n\t\n\tvar _KeyboardPrefixSelectionMixin = __webpack_require__(14);\n\t\n\tvar _KeyboardPrefixSelectionMixin2 = _interopRequireDefault(_KeyboardPrefixSelectionMixin);\n\t\n\tvar _SelectionAriaMixin = __webpack_require__(16);\n\t\n\tvar _SelectionAriaMixin2 = _interopRequireDefault(_SelectionAriaMixin);\n\t\n\tvar _SelectionInViewMixin = __webpack_require__(17);\n\t\n\tvar _SelectionInViewMixin2 = _interopRequireDefault(_SelectionInViewMixin);\n\t\n\tvar _ShadowTemplateMixin = __webpack_require__(18);\n\t\n\tvar _ShadowTemplateMixin2 = _interopRequireDefault(_ShadowTemplateMixin);\n\t\n\tvar _SingleSelectionMixin = __webpack_require__(19);\n\t\n\tvar _SingleSelectionMixin2 = _interopRequireDefault(_SingleSelectionMixin);\n\t\n\tvar _symbols = __webpack_require__(5);\n\t\n\tvar _symbols2 = _interopRequireDefault(_symbols);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This is currently a demo of how multiple mixins cooperate to perform useful\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * functions.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * * The component uses ShadowTemplateMixin to populate its shadow root.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * * A user can click on a child item, and ClickSelectionMixin will set the\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   selected item.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * * The SingleSelectionMixin will track the selected item, and map that to\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   changes in the selection state of the selected/deselected items.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * * The SelectionAriaMixin will reflect an item's selection state using ARIA\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   attributes to support assistive devices like screen readers.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * This demo will eventually evolve into a complete list box component, but\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * at the moment omits many features, including support for Page Up/Page Down\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * keys, keeping the selected item in view, the ability to select an item\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * by typing its initial characters, and support for slot elements as children.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\t\n\t// We want to apply a number of mixin functions to HTMLElement.\n\tvar mixins = [_ChildrenContentMixin2.default, _ClickSelectionMixin2.default, _ContentItemsMixin2.default, _DirectionSelectionMixin2.default, _KeyboardDirectionMixin2.default, _KeyboardMixin2.default, _KeyboardPagedSelectionMixin2.default, _KeyboardPrefixSelectionMixin2.default, _SelectionAriaMixin2.default, _SelectionInViewMixin2.default, _ShadowTemplateMixin2.default, _SingleSelectionMixin2.default];\n\t\n\t// The mixins are functions, so an efficient way to apply them all is with\n\t// reduce. This is just function composition. We end up with a base class we\n\t// can extend below.\n\tvar base = mixins.reduce(function (cls, mixin) {\n\t  return mixin(cls);\n\t}, HTMLElement);\n\t\n\t/**\n\t * A simple single-selection list box.\n\t *\n\t * This uses the base class we just created above, and adds in the behavior\n\t * unique to this list box element. As it turns out, much of this behavior is\n\t * also interesting to other components, and will eventually get factored into\n\t * other mixins.\n\t *\n\t * @extends HTMLElement\n\t * @mixes ChildrenContentMixin\n\t * @mixes ClickSelectionMixin\n\t * @mixes ContentItemsMixin\n\t * @mixes DirectionSelectionMixin\n\t * @mixes KeyboardDirectionMixin\n\t * @mixes KeyboardMixin\n\t * @mixes KeyboardPagedSelectionMixin\n\t * @mixes KeyboardPrefixSelectionMixin\n\t * @mixes SelectionAriaMixin\n\t * @mixes SelectionInViewMixin\n\t * @mixes ShadowTemplateMixin\n\t * @mixes SingleSelectionMixin\n\t */\n\t\n\tvar ListBox = function (_base) {\n\t  _inherits(ListBox, _base);\n\t\n\t  function ListBox() {\n\t    _classCallCheck(this, ListBox);\n\t\n\t    return _possibleConstructorReturn(this, (ListBox.__proto__ || Object.getPrototypeOf(ListBox)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(ListBox, [{\n\t    key: 'attributeChangedCallback',\n\t\n\t\n\t    // Map attribute changes to the corresponding property.\n\t    value: function attributeChangedCallback(attributeName, oldValue, newValue) {\n\t      if (_get(ListBox.prototype.__proto__ || Object.getPrototypeOf(ListBox.prototype), 'attributeChangedCallback', this)) {\n\t        _get(ListBox.prototype.__proto__ || Object.getPrototypeOf(ListBox.prototype), 'attributeChangedCallback', this).call(this, attributeName, oldValue, newValue);\n\t      }\n\t      var mapAttributeToProperty = {\n\t        'selected-index': 'selectedIndex'\n\t      };\n\t      var propertyName = mapAttributeToProperty[attributeName] || attributeName;\n\t      this[propertyName] = newValue;\n\t    }\n\t\n\t    // We define a collection of default property values which can be set in\n\t    // the constructor or connectedCallback. Defining the actual default values\n\t    // in those calls would complicate things if a subclass someday wants to\n\t    // define its own default value.\n\t\n\t  }, {\n\t    key: _symbols2.default.itemSelected,\n\t\n\t\n\t    // Map item selection to a `selected` CSS class.\n\t    value: function value(item, selected) {\n\t      if (_get(ListBox.prototype.__proto__ || Object.getPrototypeOf(ListBox.prototype), _symbols2.default.itemSelected, this)) {\n\t        _get(ListBox.prototype.__proto__ || Object.getPrototypeOf(ListBox.prototype), _symbols2.default.itemSelected, this).call(this, item, selected);\n\t      }\n\t      item.classList.toggle('selected', selected);\n\t    }\n\t\n\t    // Tell the browser which attributes we want to handle.\n\t\n\t  }, {\n\t    key: _symbols2.default.defaults,\n\t    get: function get() {\n\t      var defaults = _get(ListBox.prototype.__proto__ || Object.getPrototypeOf(ListBox.prototype), _symbols2.default.defaults, this) || {};\n\t      // By default, we assume the list presents list items vertically.\n\t      defaults.orientation = 'vertical';\n\t      return defaults;\n\t    }\n\t  }, {\n\t    key: 'orientation',\n\t\n\t\n\t    /**\n\t     * The vertical (default) or horizontal orientation of the list.\n\t     *\n\t     * Supported values are \"horizontal\" or \"vertical\".\n\t     *\n\t     * @type {string}\n\t     */\n\t    get: function get() {\n\t      return this[_symbols2.default.orientation] || this[_symbols2.default.defaults].orientation;\n\t    },\n\t    set: function set(value) {\n\t      var changed = value !== this[_symbols2.default.orientation];\n\t      this[_symbols2.default.orientation] = value;\n\t      if ('orientation' in base) {\n\t        _set(ListBox.prototype.__proto__ || Object.getPrototypeOf(ListBox.prototype), 'orientation', value, this);\n\t      }\n\t      // Reflect attribute for styling\n\t      if (this.getAttribute('orientation') !== value) {\n\t        this.setAttribute('orientation', value);\n\t      }\n\t      if (changed && this[_symbols2.default.raiseChangeEvents]) {\n\t        var event = new CustomEvent('orientation-changed');\n\t        this.dispatchEvent(event);\n\t      }\n\t    }\n\t\n\t    // Define a template that will be stamped into the Shadow DOM by the\n\t    // ShadowTemplateMixin.\n\t\n\t  }, {\n\t    key: _symbols2.default.template,\n\t    get: function get() {\n\t      return '\\n      <style>\\n      :host {\\n        border: 1px solid gray;\\n        box-sizing: border-box;\\n        cursor: default;\\n        display: flex;\\n        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\\n      }\\n\\n      #itemsContainer {\\n        flex: 1;\\n        -webkit-overflow-scrolling: touch; /* for momentum scrolling */\\n        overflow-x: hidden;\\n        overflow-y: scroll;\\n      }\\n      :host([orientation=\"horizontal\"]) #itemsContainer {\\n        display: flex;\\n        overflow-x: scroll;\\n        overflow-y: hidden;\\n      }\\n\\n      #itemsContainer ::slotted(*) {\\n        cursor: default;\\n        padding: 0.25em;\\n        -webkit-user-select: none;\\n        -moz-user-select: none;\\n        -ms-user-select: none;\\n        user-select: none;\\n      }\\n\\n      #itemsContainer ::slotted(.selected) {\\n        background: var(--elix-selected-background, highlight);\\n        color: var(--elix-selected-color, highlighttext);\\n      }\\n      </style>\\n\\n      <div id=\"itemsContainer\" role=\"none\">\\n        <slot></slot>\\n      </div>\\n    ';\n\t    }\n\t\n\t    /**\n\t     * Fires when the orientation property changes in response to internal\n\t     * component activity.\n\t     *\n\t     * @memberof ListBox\n\t     * @event orientation-changed\n\t     */\n\t\n\t  }], [{\n\t    key: 'observedAttributes',\n\t    get: function get() {\n\t      return ['orientation', 'selected-index'];\n\t    }\n\t  }]);\n\t\n\t  return ListBox;\n\t}(base);\n\t\n\tcustomElements.define('sample-list-box', ListBox);\n\texports.default = ListBox;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\texports.default = ChildrenContentMixin;\n\t\n\tvar _content = __webpack_require__(3);\n\t\n\tvar _microtask = __webpack_require__(4);\n\t\n\tvar _microtask2 = _interopRequireDefault(_microtask);\n\t\n\tvar _symbols = __webpack_require__(5);\n\t\n\tvar _symbols2 = _interopRequireDefault(_symbols);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t/**\n\t * Mixin which defines a component's `symbols.content` property as all\n\t * child elements, including elements distributed to the component's slots.\n\t *\n\t * This also provides notification of changes to a component's content. It\n\t * will invoke a `symbols.contentChanged` method when the component is first\n\t * instantiated, and whenever its distributed children change. This is intended\n\t * to satisfy the Gold Standard checklist item for monitoring\n\t * [Content Changes](https://github.com/webcomponents/gold-standard/wiki/Content-Changes).\n\t *\n\t * Example:\n\t *\n\t * ```\n\t * let base = ChildrenContentMixin(DistributedChildrenMixin(HTMLElement));\n\t * class CountingElement extends base {\n\t *\n\t *   constructor() {\n\t *     super();\n\t *     let root = this.attachShadow({ mode: 'open' });\n\t *     root.innerHTML = `<slot></slot>`;\n\t *     this[symbols.shadowCreated]();\n\t *   }\n\t *\n\t *   [symbols.contentChanged]() {\n\t *     if (super[symbols.contentChanged]) { super[symbols.contentChanged](); }\n\t *     // Count the component's children, both initially and when changed.\n\t *     this.count = this.distributedChildren.length;\n\t *   }\n\t *\n\t * }\n\t * ```\n\t *\n\t * Note that content change detection depends upon the element having at least\n\t * one `slot` element in its shadow subtree.\n\t *\n\t * This mixin is intended for use with the\n\t * [DistributedChildrenMixin](DistributedChildrenMixin.md). See that mixin for\n\t * a discussion of how that works. This ChildrenContentMixin\n\t * provides an easy way of defining the \"content\" of a component as the\n\t * component's distributed children. That in turn lets mixins like\n\t * [ContentItemsMixin](ContentItemsMixin.md) manipulate the children as list\n\t * items.\n\t *\n\t * To receive `contentChanged` notification, this mixin expects a component to\n\t * invoke a method called `symbols.shadowCreated` after the component's shadow\n\t * root has been created and populated.\n\t *\n\t * Note: This mixin relies upon the browser firing `slotchange` events when the\n\t * contents of a `slot` change. Safari and the polyfills fire this event when a\n\t * custom element is first upgraded, while Chrome does not. This mixin always\n\t * invokes the `contentChanged` method after component instantiation so that the\n\t * method will always be invoked at least once. However, on Safari (and possibly\n\t * other browsers), `contentChanged` might be invoked _twice_ for a new\n\t * component instance.\n\t *\n\t * @module ChildrenContentMixin\n\t * @param base {Class} the base class to extend\n\t * @returns {Class} the extended class\n\t */\n\tfunction ChildrenContentMixin(base) {\n\t\n\t  /**\n\t   * The class prototype added by the mixin.\n\t   */\n\t  var ChildrenContent = function (_base) {\n\t    _inherits(ChildrenContent, _base);\n\t\n\t    function ChildrenContent() {\n\t      _classCallCheck(this, ChildrenContent);\n\t\n\t      // Make an initial call to contentChanged() so that the component can do\n\t      // initialization that it normally does when content changes.\n\t      //\n\t      // This will invoke contentChanged() handlers in other mixins. In order\n\t      // that those mixins have a chance to complete their own initialization,\n\t      // we add the contentChanged() call to the microtask queue.\n\t      var _this = _possibleConstructorReturn(this, (ChildrenContent.__proto__ || Object.getPrototypeOf(ChildrenContent)).call(this));\n\t\n\t      (0, _microtask2.default)(function () {\n\t        if (_this[_symbols2.default.contentChanged]) {\n\t          _this[_symbols2.default.contentChanged]();\n\t        }\n\t      });\n\t      return _this;\n\t    }\n\t\n\t    /**\n\t     * The content of this component, defined to be the flattened array of\n\t     * children distributed to the component.\n\t     *\n\t     * The default implementation of this property only returns instances of\n\t     * Element\n\t     *\n\t     * @type {HTMLElement[]}\n\t     */\n\t\n\t\n\t    _createClass(ChildrenContent, [{\n\t      key: _symbols2.default.shadowCreated,\n\t      value: function value() {\n\t        var _this2 = this;\n\t\n\t        if (_get(ChildrenContent.prototype.__proto__ || Object.getPrototypeOf(ChildrenContent.prototype), _symbols2.default.shadowCreated, this)) {\n\t          _get(ChildrenContent.prototype.__proto__ || Object.getPrototypeOf(ChildrenContent.prototype), _symbols2.default.shadowCreated, this).call(this);\n\t        }\n\t        // Listen to changes on all slots.\n\t        var slots = this.shadowRoot.querySelectorAll('slot');\n\t        slots.forEach(function (slot) {\n\t          return slot.addEventListener('slotchange', function (event) {\n\t            if (_this2[_symbols2.default.contentChanged]) {\n\t              _this2[_symbols2.default.contentChanged]();\n\t            }\n\t          });\n\t        });\n\t      }\n\t    }, {\n\t      key: _symbols2.default.content,\n\t      get: function get() {\n\t        return (0, _content.assignedChildren)(this);\n\t      }\n\t    }]);\n\t\n\t    return ChildrenContent;\n\t  }(base);\n\t\n\t  return ChildrenContent;\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.assignedChildren = assignedChildren;\n\texports.assignedChildNodes = assignedChildNodes;\n\texports.assignedTextContent = assignedTextContent;\n\texports.filterAuxiliaryElements = filterAuxiliaryElements;\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\t/**\n\t * Helpers for accessing a component's content.\n\t *\n\t * The standard DOM API provides several ways of accessing child content:\n\t * `children`, `childNodes`, and `textContent`. None of these functions are\n\t * Shadow DOM aware. This mixin defines variations of those functions that\n\t * *are* Shadow DOM aware.\n\t *\n\t * Example: you create a component `<count-children>` that displays a number\n\t * equal to the number of children placed inside that component. If someone\n\t * instantiates your component like:\n\t *\n\t *     <count-children>\n\t *       <div></div>\n\t *       <div></div>\n\t *       <div></div>\n\t *     </count-children>\n\t *\n\t * Then the component should show \"3\", because there are three children. To\n\t * calculate the number of children, the component can just calculate\n\t * `this.children.length`. However, suppose someone instantiates your\n\t * component inside one of their own components, and puts a `<slot>` element\n\t * inside your component:\n\t *\n\t *     <count-children>\n\t *       <slot></slot>\n\t *     </count-children>\n\t *\n\t * If your component only looks at `this.children`, it will always see exactly\n\t * one child the `<slot>` element. But the user looking at the page will\n\t * *see* any nodes distributed to that slot. To match what the user sees, your\n\t * component should expand any `<slot>` elements it contains.\n\t *\n\t * That is one problem these helpers solve. For example, the helper\n\t * `assignedChildren` will return all children assigned to your component in\n\t * the composed tree.\n\t *\n\t * @module content\n\t */\n\t\n\t/**\n\t * An in-order collection of distributed children, expanding any slot\n\t * elements. Like the standard `children` property, this skips text and other\n\t * node types which are not Element instances.\n\t *\n\t * @param {HTMLElement} element - the element to inspect\n\t * @returns {Element[]} - the children assigned to the element\n\t */\n\tfunction assignedChildren(element) {\n\t  return expandAssignedNodes(element.children, true);\n\t}\n\t\n\t/**\n\t * An in-order collection of distributed child nodes, expanding any slot\n\t * elements. Like the standard `childNodes` property, this includes text and\n\t * other types of nodes.\n\t *\n\t * @param {HTMLElement} element - the element to inspect\n\t * @returns {Node[]} - the nodes assigned to the element\n\t */\n\tfunction assignedChildNodes(element) {\n\t  return expandAssignedNodes(element.childNodes, false);\n\t}\n\t\n\t/**\n\t * The concatenated `textContent` of all distributed child nodes, expanding\n\t * any slot elements.\n\t *\n\t * @param {HTMLElement} element - the element to inspect\n\t * @type {string} - the text content of all nodes assigned to the element\n\t */\n\tfunction assignedTextContent(element) {\n\t  var strings = assignedChildNodes(element).map(function (child) {\n\t    return child.textContent;\n\t  });\n\t  return strings.join('');\n\t}\n\t\n\t/**\n\t * Return the given elements, filtering out auxiliary elements that aren't\n\t * typically visible. Given a `NodeList` or array of objects, it will only\n\t * return array members that are instances of `Element` (`HTMLElement` or\n\t * `SVGElement`), and not on a blacklist of normally invisible elements\n\t * (such as `style` or `script`).\n\t *\n\t * @param {NodeList|Element[]} elements - the list of elements to filter\n\t * @returns {Element[]} - the filtered elements\n\t */\n\tfunction filterAuxiliaryElements(elements) {\n\t\n\t  // These are tags that can appear in the document body, but do not seem to\n\t  // have any user-visible manifestation.\n\t  // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element\n\t  var auxiliaryTags = ['applet', // deprecated\n\t  'basefont', // deprecated\n\t  'embed', 'font', // deprecated\n\t  'frame', // deprecated\n\t  'frameset', // deprecated\n\t  'isindex', // deprecated\n\t  'keygen', // deprecated\n\t  'link', 'multicol', // deprecated\n\t  'nextid', // deprecated\n\t  'noscript', 'object', 'param', 'script', 'style', 'template', 'noembed' // deprecated\n\t  ];\n\t\n\t  return [].filter.call(elements, function (element) {\n\t    return element instanceof Element && (!element.localName || auxiliaryTags.indexOf(element.localName) < 0);\n\t  });\n\t}\n\t\n\t//\n\t// Helpers for the helper functions\n\t//\n\t\n\t/*\n\t * Given a array of nodes, return a new array with any `slot` elements expanded\n\t * to the nodes assigned to those slots.\n\t *\n\t * If ElementsOnly is true, only Element instances are returned, as with the\n\t * standard `children` property. Otherwise, all nodes are returned, as in the\n\t * standard `childNodes` property.\n\t */\n\tfunction expandAssignedNodes(nodes, ElementsOnly) {\n\t  var _ref;\n\t\n\t  var expanded = Array.prototype.map.call(nodes, function (node) {\n\t\n\t    // We want to see if the node is an instanceof HTMLSlotELement, but\n\t    // that class won't exist if the browser that doesn't support native\n\t    // Shadow DOM and if the Shadow DOM polyfill hasn't been loaded. Instead,\n\t    // we do a simplistic check to see if the tag name is \"slot\".\n\t    var isSlot = typeof HTMLSlotElement !== 'undefined' ? node instanceof HTMLSlotElement : node.localName === 'slot';\n\t\n\t    return isSlot ? node.assignedNodes({ flatten: true }) : [node];\n\t  });\n\t  var flattened = (_ref = []).concat.apply(_ref, _toConsumableArray(expanded));\n\t  var result = ElementsOnly ? flattened.filter(function (node) {\n\t    return node instanceof Element;\n\t  }) : flattened;\n\t  return result;\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = microtask;\n\t/*\n\t * Microtask helper for IE 11.\n\t *\n\t * Executing a function as a microtask is trivial in browsers that support\n\t * promises, whose then() clauses use microtask timing. IE 11 doesn't support\n\t * promises, but does support MutationObservers, which are also executed as\n\t * microtasks. So this helper uses an MutationObserver to achieve microtask\n\t * timing.\n\t *\n\t * See https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n\t *\n\t * Inspired by Polymer's async() function.\n\t */\n\t\n\t// The queue of pending callbacks to be executed as microtasks.\n\tvar callbacks = [];\n\t\n\t// Create an element that we will modify to force observable mutations.\n\tvar element = document.createTextNode('');\n\t\n\t// A monotonically-increasing value.\n\tvar counter = 0;\n\t\n\t/**\n\t * Add a callback to the microtask queue.\n\t *\n\t * This uses a MutationObserver so that it works on IE 11.\n\t *\n\t * NOTE: IE 11 may actually use timeout timing with MutationObservers. This\n\t * needs more investigation.\n\t *\n\t * @function microtask\n\t * @param {function} callback\n\t */\n\tfunction microtask(callback) {\n\t  callbacks.push(callback);\n\t  // Force a mutation.\n\t  element.textContent = ++counter;\n\t}\n\t\n\t// Execute any pending callbacks.\n\tfunction executeCallbacks() {\n\t  while (callbacks.length > 0) {\n\t    var callback = callbacks.shift();\n\t    callback();\n\t  }\n\t}\n\t\n\t// Create the observer.\n\tvar observer = new MutationObserver(executeCallbacks);\n\tobserver.observe(element, {\n\t  characterData: true\n\t});\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _Symbol2 = __webpack_require__(6);\n\t\n\tvar _Symbol3 = _interopRequireDefault(_Symbol2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * A collection of (potentially polyfilled) Symbol objects for standard\n\t * component properties and methods.\n\t *\n\t * These Symbol objects are used to allow mixins and a component to internally\n\t * communicate, without exposing these properties and methods in the component's\n\t * public API.\n\t *\n\t * To use these Symbol objects in your own component, include this module and\n\t * then create a property or method whose key is the desired Symbol.\n\t *\n\t *     import 'SingleSelectionMixin' from 'elix-mixins/src/SingleSelectionMixin';\n\t *     import 'symbols' from 'elix-mixins/src/symbols';\n\t *\n\t *     class MyElement extends SingleSelectionMixin(HTMLElement) {\n\t *       [symbols.itemSelected](item, selected) {\n\t *         // This will be invoked whenever an item is selected/deselected.\n\t *       }\n\t *     }\n\t *\n\t * @module symbols\n\t */\n\tvar symbols = {\n\t\n\t  /**\n\t   * Symbols for the `content` property.\n\t   *\n\t   * This property returns the component's content -- however the component\n\t   * wants to define that. This could, for example, return the component's\n\t   * distributed children.\n\t   *\n\t   * @type {HTMLElement[]}\n\t   */\n\t  content: (0, _Symbol3.default)('content'),\n\t\n\t  /**\n\t   * Symbol for the `contentChanged` method.\n\t   *\n\t   * For components that define a `content` property, this method should be\n\t   * invoked when that property changes.\n\t   *\n\t   * @function contentChanged\n\t   */\n\t  contentChanged: (0, _Symbol3.default)('contentChanged'),\n\t\n\t  /**\n\t   * Symbol for the `defaults` property.\n\t   *\n\t   * This property can be used to set or override defaults that will be applied\n\t   * to a new component instance. When implementing this property, take care to\n\t   * first acquire any defaults defined by the superclass. The standard idiom is\n\t   * as follows:\n\t   *\n\t   *     get [symbols.defaults]() {\n\t   *       const defaults = super[symbols.defaults] || {};\n\t   *       // Set or override default values here\n\t   *       defaults.customProperty = false;\n\t   *       return defaults;\n\t   *     }\n\t   *\n\t   * @var {object} defaults\n\t   */\n\t  defaults: (0, _Symbol3.default)('defaults'),\n\t\n\t  /**\n\t   * Symbol for the `getItemText` method.\n\t   *\n\t   * This method can be applied to an item to return its text.\n\t   *\n\t   * @function getText\n\t   * @param {HTMLElement} item - the item to extract text from\n\t   * @returns {string} - the text of the item\n\t   */\n\t  getItemText: (0, _Symbol3.default)('getText'),\n\t\n\t  /**\n\t   * Symbol for the `goDown` method.\n\t   *\n\t   * This method is invoked when the user wants to go/navigate down.\n\t   *\n\t   * @function goDown\n\t   */\n\t  goDown: (0, _Symbol3.default)('goDown'),\n\t\n\t  /**\n\t   * Symbol for the `goEnd` method.\n\t   *\n\t   * This method is invoked when the user wants to go/navigate to the end (e.g.,\n\t   * of a list).\n\t   *\n\t   * @function goEnd\n\t   */\n\t  goEnd: (0, _Symbol3.default)('goEnd'),\n\t\n\t  /**\n\t   * Symbol for the `goLeft` method.\n\t   *\n\t   * This method is invoked when the user wants to go/navigate left.\n\t   *\n\t   * @function goLeft\n\t   */\n\t  goLeft: (0, _Symbol3.default)('goLeft'),\n\t\n\t  /**\n\t   * Symbol for the `goRight` method.\n\t   *\n\t   * This method is invoked when the user wants to go/navigate right.\n\t   *\n\t   * @function goRight\n\t   */\n\t  goRight: (0, _Symbol3.default)('goRight'),\n\t\n\t  /**\n\t   * Symbol for the `goStart` method.\n\t   *\n\t   * This method is invoked when the user wants to go/navigate to the start\n\t   * (e.g., of a list).\n\t   *\n\t   * @function goStart\n\t   */\n\t  goStart: (0, _Symbol3.default)('goStart'),\n\t\n\t  /**\n\t   * Symbol for the `goUp` method.\n\t   *\n\t   * This method is invoked when the user wants to go/navigate up.\n\t   *\n\t   * @function goUp\n\t   */\n\t  goUp: (0, _Symbol3.default)('goUp'),\n\t\n\t  /**\n\t   * Symbol for the `itemAdded` method.\n\t   *\n\t   * This method is invoked when a new item is added to a list.\n\t   *\n\t   * @function itemAdded\n\t   * @param {HTMLElement} item - the item being selected/deselected\n\t   */\n\t  itemAdded: (0, _Symbol3.default)('itemAdded'),\n\t\n\t  /**\n\t   * Symbol for the `itemsChanged` method.\n\t   *\n\t   * This method is invoked when the underlying contents change. It is also\n\t   * invoked on component initialization  since the items have \"changed\" from\n\t   * being nothing.\n\t   *\n\t   * @function itemsChanged\n\t   */\n\t  itemsChanged: (0, _Symbol3.default)('itemsChanged'),\n\t\n\t  /**\n\t   * Symbol for the `itemSelected` method.\n\t   *\n\t   * This method is invoked when an item becomes selected or deselected.\n\t   *\n\t   * @function itemSelected\n\t   * @param {HTMLElement} item - the item being selected/deselected\n\t   * @param {boolean} selected - true if the item is selected, false if not\n\t   */\n\t  itemSelected: (0, _Symbol3.default)('itemSelected'),\n\t\n\t  /**\n\t   * Symbol for the `keydown` method.\n\t   *\n\t   * This method is invoked when an element receives a `keydown` event.\n\t   *\n\t   * @function keydown\n\t   * @param {KeyboardEvent} event - the event being processed\n\t   */\n\t  keydown: (0, _Symbol3.default)('keydown'),\n\t\n\t  /**\n\t   * Indicates the general horizontal and/or vertical orientation of the\n\t   * component. This may affect both presentation and behavior (e.g., of\n\t   * keyboard navigation).\n\t   *\n\t   * Accepted values are \"horizontal\", \"vertical\", or \"both\" (the default).\n\t   *\n\t   * @type {string}\n\t   */\n\t  orientation: (0, _Symbol3.default)('orientation'),\n\t\n\t  /**\n\t   * Symbol for the `raiseChangeEvents` property.\n\t   *\n\t   * This property is used by mixins to determine whether they should raise\n\t   * property change events. The standard HTML pattern is to only raise such\n\t   * events in response to direct user interactions. For a detailed discussion\n\t   * of this point, see the Gold Standard checklist item for\n\t   * [Propery Change Events](https://github.com/webcomponents/gold-standard/wiki/Property%20Change%20Events).\n\t   *\n\t   * The above article describes a pattern for using a flag to track whether\n\t   * work is being performed in response to internal component activity, and\n\t   * whether the component should therefore raise property change events.\n\t   * This `raiseChangeEvents` symbol is a shared flag used for that purpose by\n\t   * all Elix mixins and components. Sharing this flag ensures that internal\n\t   * activity (e.g., a UI event listener) in one mixin can signal other mixins\n\t   * handling affected properties to raise change events.\n\t   *\n\t   * All UI event listeners (and other forms of internal handlers, such as\n\t   * timeouts and async network handlers) should set `raiseChangeEvents` to\n\t   * `true` at the start of the event handler, then `false` at the end:\n\t   *\n\t   *     this.addEventListener('click', event => {\n\t   *       this[symbols.raiseChangeEvents] = true;\n\t   *       // Do work here, possibly setting properties, like:\n\t   *       this.foo = 'Hello';\n\t   *       this[symbols.raiseChangeEvents] = false;\n\t   *     });\n\t   *\n\t   * Elsewhere, property setters that raise change events should only do so it\n\t   * this property is `true`:\n\t   *\n\t   *     set foo(value) {\n\t   *       // Save foo value here, do any other work.\n\t   *       if (this[symbols.raiseChangeEvents]) {\n\t   *         const event = new CustomEvent('foo-changed');\n\t   *         this.dispatchEvent(event);\n\t   *       }\n\t   *     }\n\t   *\n\t   * In this way, programmatic attempts to set the `foo` property will not\n\t   * trigger the `foo-changed` event, but UI interactions that update that\n\t   * property will cause those events to be raised.\n\t   *\n\t   * @var {boolean} raiseChangeEvents\n\t   */\n\t  raiseChangeEvents: (0, _Symbol3.default)('raiseChangeEvents'),\n\t\n\t  /**\n\t   * Symbol for the `shadowCreated` method.\n\t   *\n\t   * This method is invoked when the component's shadow root has been attached\n\t   * and populated. Other code can handle this method to perform initialization\n\t   * that depends upon the existence of a populated shadow subtree.\n\t   *\n\t   * @function shadowCreated\n\t   */\n\t  shadowCreated: (0, _Symbol3.default)('shadowCreated'),\n\t\n\t  /**\n\t   * Symbol for the `template` property.\n\t   *\n\t   * This property returns a component's template.\n\t   *\n\t   * @type {string|HTMLTemplateElement}\n\t   */\n\t  template: (0, _Symbol3.default)('template')\n\t};\n\t\n\texports.default = symbols;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/* The number of fake symbols we've served up */\n\tvar count = 0;\n\t\n\tfunction uniqueString(description) {\n\t  return '_' + description + count++;\n\t}\n\t\n\tvar symbolFunction = typeof window.Symbol === 'function' ? window.Symbol : uniqueString;\n\t\n\t/**\n\t * Polyfill for ES6 symbol class.\n\t *\n\t * Mixins and component classes often want to associate private data with an\n\t * element instance, but JavaScript does not have direct support for true\n\t * private properties. One approach is to use the\n\t * [Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)\n\t * data type to set and retrieve data on an element.\n\t *\n\t * Unfortunately, the Symbol type is not available in Internet Explorer 11. In\n\t * lieu of returning a true Symbol, this polyfill returns a different string\n\t * each time it is called.\n\t *\n\t * Usage:\n\t *\n\t *     const fooSymbol = Symbol('foo');\n\t *\n\t *     class MyElement extends HTMLElement {\n\t *       get foo() {\n\t *         return this[fooSymbol];\n\t *       }\n\t *       set foo(value) {\n\t *         this[fooSymbol] = value;\n\t *       }\n\t *     }\n\t *\n\t * In IE 11, this sample will \"hide\" data behind an instance property that looks\n\t * like this._foo0. The underscore is meant to reduce (not eliminate) potential\n\t * accidental access, and the unique number at the end is mean to avoid (not\n\t * eliminate) naming conflicts.\n\t *\n\t * @function Symbol\n\t * @param {string} description - A string to identify the symbol when debugging\n\t * @returns {Symbol|string}  A Symbol (in ES6 browsers) or unique string ID (in\n\t * ES5).\n\t */\n\texports.default = symbolFunction;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = ClickSelectionMixin;\n\t\n\tvar _symbols = __webpack_require__(5);\n\t\n\tvar _symbols2 = _interopRequireDefault(_symbols);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t/**\n\t * Mixin which maps a click (actually, a mousedown) to a selection.\n\t *\n\t * This simple mixin is useful in list box-like elements, where a click on a\n\t * list item implicitly selects it.\n\t *\n\t * The standard use for this mixin is in list-like elements. Native list\n\t * boxes don't appear to be consistent with regard to whether they select\n\t * on mousedown or click/mouseup. This mixin assumes the use of mousedown.\n\t * On touch devices, that event appears to trigger when the touch is *released*.\n\t *\n\t * This mixin only listens to mousedown events for the primary mouse button\n\t * (typically the left button). Right-clicks are ignored so that the browser\n\t * may display a context menu.\n\t *\n\t * Much has been written about how to ensure \"fast tap\" behavior on mobile\n\t * devices. This mixin makes a very straightforward use of a standard event, and\n\t * this appears to perform well on mobile devices when, e.g., the viewport is\n\t * configured with `width=device-width`.\n\t *\n\t * This mixin expects the component to provide an `items` property. It also\n\t * expects the component to define a `selectedItem` property; you can provide\n\t * that yourself, or use [SingleSelectionMixin](SingleSelectionMixin.md).\n\t *\n\t * If the component receives a clicks that doesn't correspond to an item (e.g.,\n\t * the user clicks on the element background visible between items), the\n\t * selection will be removed. However, if the component defines a\n\t * `selectionRequired` and this is true, a background click will *not* remove\n\t * the selection.\n\t *\n\t * @module ClickSelectionMixin\n\t * @param base {Class} the base class to extend\n\t * @returns {Class} the extended class\n\t */\n\tfunction ClickSelectionMixin(base) {\n\t\n\t  /**\n\t   * The class prototype added by the mixin.\n\t   */\n\t  var ClickSelection = function (_base) {\n\t    _inherits(ClickSelection, _base);\n\t\n\t    function ClickSelection() {\n\t      _classCallCheck(this, ClickSelection);\n\t\n\t      var _this = _possibleConstructorReturn(this, (ClickSelection.__proto__ || Object.getPrototypeOf(ClickSelection)).call(this));\n\t\n\t      _this.addEventListener('mousedown', function (event) {\n\t\n\t        // Only process events for the main (usually left) button.\n\t        if (event.button !== 0) {\n\t          return;\n\t        }\n\t\n\t        _this[_symbols2.default.raiseChangeEvents] = true;\n\t\n\t        // If the item clicked on is a button, the event seems to be raised in\n\t        // phase 2 (AT_TARGET)  but the event target will be the component, not\n\t        // the item that was clicked on.\n\t        var target = event.target === _this ? event.path[0] : // Event target isn't the item, so get it from path.\n\t        event.target;\n\t\n\t        // Find which item was clicked on and, if found, select it. For elements\n\t        // which don't require a selection, a background click will determine\n\t        // the item was null, in which we case we'll remove the selection.\n\t        var item = itemForTarget(_this, target);\n\t        if (item || !_this.selectionRequired) {\n\t\n\t          if (!('selectedItem' in _this)) {\n\t            console.warn('ClickSelectionMixin expects a component to define a \"selectedItem\" property.');\n\t          } else {\n\t            _this.selectedItem = item;\n\t          }\n\t\n\t          // We don't call preventDefault here. The default behavior for\n\t          // mousedown includes setting keyboard focus if the element doesn't\n\t          // already have the focus, and we want to preserve that behavior.\n\t          event.stopPropagation();\n\t        }\n\t\n\t        _this[_symbols2.default.raiseChangeEvents] = false;\n\t      });\n\t      return _this;\n\t    }\n\t\n\t    return ClickSelection;\n\t  }(base);\n\t\n\t  return ClickSelection;\n\t}\n\t\n\t/*\n\t * Return the list item that is, or contains, the indicated target element.\n\t * Return null if not found.\n\t */\n\tfunction itemForTarget(listElement, target) {\n\t  var items = listElement.items;\n\t  var itemCount = items ? items.length : 0;\n\t  for (var i = 0; i < itemCount; i++) {\n\t    var item = items[i];\n\t    if (item === target || item.contains(target)) {\n\t      return item;\n\t    }\n\t  }\n\t  return null;\n\t}\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\texports.default = ContentItemsMixin;\n\t\n\tvar _content = __webpack_require__(3);\n\t\n\tvar content = _interopRequireWildcard(_content);\n\t\n\tvar _Symbol2 = __webpack_require__(6);\n\t\n\tvar _Symbol3 = _interopRequireDefault(_Symbol2);\n\t\n\tvar _symbols = __webpack_require__(5);\n\t\n\tvar _symbols2 = _interopRequireDefault(_symbols);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t// Symbols for private data members on an element.\n\tvar itemsSymbol = (0, _Symbol3.default)('items');\n\tvar itemInitializedSymbol = (0, _Symbol3.default)('itemInitialized');\n\t\n\t/**\n\t * Mixin which maps content semantics (elements) to list item semantics.\n\t *\n\t * Items differ from element contents in several ways:\n\t *\n\t * * They are often referenced via index.\n\t * * They may have a selection state.\n\t * * It's common to do work to initialize the appearance or state of a new\n\t *   item.\n\t * * Auxiliary invisible child elements are filtered out and not counted as\n\t *   items. Auxiliary elements include link, script, style, and template\n\t *   elements. This filtering ensures that those auxiliary elements can be\n\t *   used in markup inside of a list without being treated as list items.\n\t *\n\t * This mixin expects a component to provide a `content` property returning a\n\t * raw set of elements. You can provide that yourself, or use\n\t * [ChildrenContentMixin](ChildrenContentMixin.md).\n\t *\n\t * The most commonly referenced property defined by this mixin is the `items`\n\t * property. To avoid having to do work each time that property is requested,\n\t * this mixin supports an optimized mode. If you invoke the `contentChanged`\n\t * method when the set of items changes, the mixin concludes that you'll take\n\t * care of notifying it of future changes, and turns on the optimization. With\n\t * that on, the mixin saves a reference to the computed set of items, and will\n\t * return that immediately on subsequent calls to the `items` property. If you\n\t * use this mixin in conjunction with `ChildrenContentMixin`, the\n\t * `contentChanged` method will be invoked for you when the element's children\n\t * change, turning on the optimization automatically.\n\t *\n\t * @module ContentItemsMixin\n\t * @param base {Class} the base class to extend\n\t * @returns {Class} the extended class\n\t */\n\tfunction ContentItemsMixin(base) {\n\t\n\t  /**\n\t   * The class prototype added by the mixin.\n\t   */\n\t  var ContentItems = function (_base) {\n\t    _inherits(ContentItems, _base);\n\t\n\t    function ContentItems() {\n\t      _classCallCheck(this, ContentItems);\n\t\n\t      return _possibleConstructorReturn(this, (ContentItems.__proto__ || Object.getPrototypeOf(ContentItems)).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(ContentItems, [{\n\t      key: _symbols2.default.contentChanged,\n\t      value: function value() {\n\t        if (_get(ContentItems.prototype.__proto__ || Object.getPrototypeOf(ContentItems.prototype), _symbols2.default.contentChanged, this)) {\n\t          _get(ContentItems.prototype.__proto__ || Object.getPrototypeOf(ContentItems.prototype), _symbols2.default.contentChanged, this).call(this);\n\t        }\n\t\n\t        // Since we got the contentChanged call, we'll assume we'll be notified if\n\t        // the set of items changes later. We turn on memoization of the items\n\t        // property by setting our internal property to null (instead of\n\t        // undefined).\n\t        this[itemsSymbol] = null;\n\t\n\t        this[_symbols2.default.itemsChanged]();\n\t      }\n\t\n\t      /**\n\t       * The current set of items in the list. See the top-level documentation for\n\t       * mixin for a description of how items differ from plain content.\n\t       *\n\t       * @type {HTMLElement[]}\n\t       */\n\t\n\t    }, {\n\t      key: _symbols2.default.itemsChanged,\n\t\n\t\n\t      /**\n\t       * This method is invoked when the underlying contents change. It is also\n\t       * invoked on component initialization  since the items have \"changed\" from\n\t       * being nothing.\n\t       */\n\t      value: function value() {\n\t        var _this2 = this;\n\t\n\t        if (_get(ContentItems.prototype.__proto__ || Object.getPrototypeOf(ContentItems.prototype), _symbols2.default.itemsChanged, this)) {\n\t          _get(ContentItems.prototype.__proto__ || Object.getPrototypeOf(ContentItems.prototype), _symbols2.default.itemsChanged, this).call(this);\n\t        }\n\t\n\t        // Perform per-item initialization if `itemAdded` is defined.\n\t        if (this[_symbols2.default.itemAdded]) {\n\t          Array.prototype.forEach.call(this.items, function (item) {\n\t            if (!item[itemInitializedSymbol]) {\n\t              _this2[_symbols2.default.itemAdded](item);\n\t              item[itemInitializedSymbol] = true;\n\t            }\n\t          });\n\t        }\n\t\n\t        if (this[_symbols2.default.raiseChangeEvents]) {\n\t          this.dispatchEvent(new CustomEvent('items-changed'));\n\t        }\n\t      }\n\t\n\t      /**\n\t       * Fires when the items in the list change.\n\t       *\n\t       * @memberof ContentItems\n\t       * @event items-changed\n\t       */\n\t\n\t    }, {\n\t      key: 'items',\n\t      get: function get() {\n\t        var items = void 0;\n\t        if (this[itemsSymbol] == null) {\n\t          items = content.filterAuxiliaryElements(this[_symbols2.default.content]);\n\t          // Note: test for *equality* with null, since we use `undefined` to\n\t          // indicate that we're not yet caching items.\n\t          if (this[itemsSymbol] === null) {\n\t            // Memoize the set of items.\n\t            this[itemsSymbol] = items;\n\t          }\n\t        } else {\n\t          // Return the memoized items.\n\t          items = this[itemsSymbol];\n\t        }\n\t        return items;\n\t      }\n\t    }]);\n\t\n\t    return ContentItems;\n\t  }(base);\n\t\n\t  return ContentItems;\n\t}\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\texports.default = DirectionSelectionMixin;\n\t\n\tvar _symbols = __webpack_require__(5);\n\t\n\tvar _symbols2 = _interopRequireDefault(_symbols);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t/**\n\t * Mixin which maps direction semantics (goLeft, goRight, etc.) to selection\n\t * semantics (selectPrevious, selectNext, etc.).\n\t *\n\t * This mixin can be used in conjunction with\n\t * [KeyboardDirectionMixin](KeyboardDirectionMixin.md) (which maps keyboard\n\t * events to directions) and a mixin that handles selection like\n\t * [SingleSelectionMixin](SingleSelectionMixin.md).\n\t *\n\t * @module DirectionSelectionMixin\n\t * @param base {Class} the base class to extend\n\t * @returns {Class} the extended class\n\t */\n\tfunction DirectionSelectionMixin(base) {\n\t\n\t  /**\n\t   * The class prototype added by the mixin.\n\t   */\n\t  var DirectionSelection = function (_base) {\n\t    _inherits(DirectionSelection, _base);\n\t\n\t    function DirectionSelection() {\n\t      _classCallCheck(this, DirectionSelection);\n\t\n\t      return _possibleConstructorReturn(this, (DirectionSelection.__proto__ || Object.getPrototypeOf(DirectionSelection)).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(DirectionSelection, [{\n\t      key: _symbols2.default.goDown,\n\t      value: function value() {\n\t        if (_get(DirectionSelection.prototype.__proto__ || Object.getPrototypeOf(DirectionSelection.prototype), _symbols2.default.goDown, this)) {\n\t          _get(DirectionSelection.prototype.__proto__ || Object.getPrototypeOf(DirectionSelection.prototype), _symbols2.default.goDown, this).call(this);\n\t        }\n\t        if (!this.selectNext) {\n\t          console.warn('DirectionSelectionMixin expects a component to define a \"selectNext\" method.');\n\t        } else {\n\t          return this.selectNext();\n\t        }\n\t      }\n\t    }, {\n\t      key: _symbols2.default.goEnd,\n\t      value: function value() {\n\t        if (_get(DirectionSelection.prototype.__proto__ || Object.getPrototypeOf(DirectionSelection.prototype), _symbols2.default.goEnd, this)) {\n\t          _get(DirectionSelection.prototype.__proto__ || Object.getPrototypeOf(DirectionSelection.prototype), _symbols2.default.goEnd, this).call(this);\n\t        }\n\t        if (!this.selectLast) {\n\t          console.warn('DirectionSelectionMixin expects a component to define a \"selectLast\" method.');\n\t        } else {\n\t          return this.selectLast();\n\t        }\n\t      }\n\t    }, {\n\t      key: _symbols2.default.goLeft,\n\t      value: function value() {\n\t        if (_get(DirectionSelection.prototype.__proto__ || Object.getPrototypeOf(DirectionSelection.prototype), _symbols2.default.goLeft, this)) {\n\t          _get(DirectionSelection.prototype.__proto__ || Object.getPrototypeOf(DirectionSelection.prototype), _symbols2.default.goLeft, this).call(this);\n\t        }\n\t        if (!this.selectPrevious) {\n\t          console.warn('DirectionSelectionMixin expects a component to define a \"selectPrevious\" method.');\n\t        } else {\n\t          return this.selectPrevious();\n\t        }\n\t      }\n\t    }, {\n\t      key: _symbols2.default.goRight,\n\t      value: function value() {\n\t        if (_get(DirectionSelection.prototype.__proto__ || Object.getPrototypeOf(DirectionSelection.prototype), _symbols2.default.goRight, this)) {\n\t          _get(DirectionSelection.prototype.__proto__ || Object.getPrototypeOf(DirectionSelection.prototype), _symbols2.default.goRight, this).call(this);\n\t        }\n\t        if (!this.selectNext) {\n\t          console.warn('DirectionSelectionMixin expects a component to define a \"selectNext\" method.');\n\t        } else {\n\t          return this.selectNext();\n\t        }\n\t      }\n\t    }, {\n\t      key: _symbols2.default.goStart,\n\t      value: function value() {\n\t        if (_get(DirectionSelection.prototype.__proto__ || Object.getPrototypeOf(DirectionSelection.prototype), _symbols2.default.goStart, this)) {\n\t          _get(DirectionSelection.prototype.__proto__ || Object.getPrototypeOf(DirectionSelection.prototype), _symbols2.default.goStart, this).call(this);\n\t        }\n\t        if (!this.selectFirst) {\n\t          console.warn('DirectionSelectionMixin expects a component to define a \"selectFirst\" method.');\n\t        } else {\n\t          return this.selectFirst();\n\t        }\n\t      }\n\t    }, {\n\t      key: _symbols2.default.goUp,\n\t      value: function value() {\n\t        if (_get(DirectionSelection.prototype.__proto__ || Object.getPrototypeOf(DirectionSelection.prototype), _symbols2.default.goUp, this)) {\n\t          _get(DirectionSelection.prototype.__proto__ || Object.getPrototypeOf(DirectionSelection.prototype), _symbols2.default.goUp, this).call(this);\n\t        }\n\t        if (!this.selectPrevious) {\n\t          console.warn('DirectionSelectionMixin expects a component to define a \"selectPrevious\" method.');\n\t        } else {\n\t          return this.selectPrevious();\n\t        }\n\t      }\n\t    }]);\n\t\n\t    return DirectionSelection;\n\t  }(base);\n\t\n\t  return DirectionSelection;\n\t}\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\texports.default = KeyboardDirectionMixin;\n\t\n\tvar _symbols = __webpack_require__(5);\n\t\n\tvar _symbols2 = _interopRequireDefault(_symbols);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t/**\n\t * Mixin which maps direction keys (Left, Right, etc.) to direction semantics\n\t * (go left, go right, etc.).\n\t *\n\t * This mixin expects the component to invoke a `keydown` method when a key is\n\t * pressed. You can use [KeyboardMixin](KeyboardMixin.md) for that\n\t * purpose, or wire up your own keyboard handling and call `keydown` yourself.\n\t *\n\t * This mixin calls methods such as `goLeft` and `goRight`. You can define\n\t * what that means by implementing those methods yourself. If you want to use\n\t * direction keys to navigate a selection, use this mixin with\n\t * [DirectionSelectionMixin](DirectionSelectionMixin.md).\n\t *\n\t * If the component defines a property called `symbols.orientation`, the value\n\t * of that property will constrain navigation to the horizontal or vertical axis.\n\t *\n\t * @module KeyboardDirectionMixin\n\t * @param base {Class} the base class to extend\n\t * @returns {Class} the extended class\n\t */\n\tfunction KeyboardDirectionMixin(base) {\n\t\n\t  /**\n\t   * The class prototype added by the mixin.\n\t   */\n\t  var KeyboardDirection = function (_base) {\n\t    _inherits(KeyboardDirection, _base);\n\t\n\t    function KeyboardDirection() {\n\t      _classCallCheck(this, KeyboardDirection);\n\t\n\t      return _possibleConstructorReturn(this, (KeyboardDirection.__proto__ || Object.getPrototypeOf(KeyboardDirection)).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(KeyboardDirection, [{\n\t      key: _symbols2.default.goDown,\n\t\n\t\n\t      /**\n\t       * Invoked when the user wants to go/navigate down.\n\t       * The default implementation of this method does nothing.\n\t       */\n\t      value: function value() {\n\t        if (_get(KeyboardDirection.prototype.__proto__ || Object.getPrototypeOf(KeyboardDirection.prototype), _symbols2.default.goDown, this)) {\n\t          return _get(KeyboardDirection.prototype.__proto__ || Object.getPrototypeOf(KeyboardDirection.prototype), _symbols2.default.goDown, this).call(this);\n\t        }\n\t      }\n\t\n\t      /**\n\t       * Invoked when the user wants to go/navigate to the end (e.g., of a list).\n\t       * The default implementation of this method does nothing.\n\t       */\n\t\n\t    }, {\n\t      key: _symbols2.default.goEnd,\n\t      value: function value() {\n\t        if (_get(KeyboardDirection.prototype.__proto__ || Object.getPrototypeOf(KeyboardDirection.prototype), _symbols2.default.goEnd, this)) {\n\t          return _get(KeyboardDirection.prototype.__proto__ || Object.getPrototypeOf(KeyboardDirection.prototype), _symbols2.default.goEnd, this).call(this);\n\t        }\n\t      }\n\t\n\t      /**\n\t       * Invoked when the user wants to go/navigate left.\n\t       * The default implementation of this method does nothing.\n\t       */\n\t\n\t    }, {\n\t      key: _symbols2.default.goLeft,\n\t      value: function value() {\n\t        if (_get(KeyboardDirection.prototype.__proto__ || Object.getPrototypeOf(KeyboardDirection.prototype), _symbols2.default.goLeft, this)) {\n\t          return _get(KeyboardDirection.prototype.__proto__ || Object.getPrototypeOf(KeyboardDirection.prototype), _symbols2.default.goLeft, this).call(this);\n\t        }\n\t      }\n\t\n\t      /**\n\t       * Invoked when the user wants to go/navigate right.\n\t       * The default implementation of this method does nothing.\n\t       */\n\t\n\t    }, {\n\t      key: _symbols2.default.goRight,\n\t      value: function value() {\n\t        if (_get(KeyboardDirection.prototype.__proto__ || Object.getPrototypeOf(KeyboardDirection.prototype), _symbols2.default.goRight, this)) {\n\t          return _get(KeyboardDirection.prototype.__proto__ || Object.getPrototypeOf(KeyboardDirection.prototype), _symbols2.default.goRight, this).call(this);\n\t        }\n\t      }\n\t\n\t      /**\n\t       * Invoked when the user wants to go/navigate to the start (e.g., of a\n\t       * list). The default implementation of this method does nothing.\n\t       */\n\t\n\t    }, {\n\t      key: _symbols2.default.goStart,\n\t      value: function value() {\n\t        if (_get(KeyboardDirection.prototype.__proto__ || Object.getPrototypeOf(KeyboardDirection.prototype), _symbols2.default.goStart, this)) {\n\t          return _get(KeyboardDirection.prototype.__proto__ || Object.getPrototypeOf(KeyboardDirection.prototype), _symbols2.default.goStart, this).call(this);\n\t        }\n\t      }\n\t\n\t      /**\n\t       * Invoked when the user wants to go/navigate up.\n\t       * The default implementation of this method does nothing.\n\t       */\n\t\n\t    }, {\n\t      key: _symbols2.default.goUp,\n\t      value: function value() {\n\t        if (_get(KeyboardDirection.prototype.__proto__ || Object.getPrototypeOf(KeyboardDirection.prototype), _symbols2.default.goUp, this)) {\n\t          return _get(KeyboardDirection.prototype.__proto__ || Object.getPrototypeOf(KeyboardDirection.prototype), _symbols2.default.goUp, this).call(this);\n\t        }\n\t      }\n\t    }, {\n\t      key: _symbols2.default.keydown,\n\t      value: function value(event) {\n\t        var handled = false;\n\t\n\t        var orientation = this[_symbols2.default.orientation] || 'both';\n\t        var horizontal = orientation === 'horizontal' || orientation === 'both';\n\t        var vertical = orientation === 'vertical' || orientation === 'both';\n\t\n\t        // Ignore Left/Right keys when metaKey or altKey modifier is also pressed,\n\t        // as the user may be trying to navigate back or forward in the browser.\n\t        switch (event.keyCode) {\n\t          case 35:\n\t            // End\n\t            handled = this[_symbols2.default.goEnd]();\n\t            break;\n\t          case 36:\n\t            // Home\n\t            handled = this[_symbols2.default.goStart]();\n\t            break;\n\t          case 37:\n\t            // Left\n\t            if (horizontal && !event.metaKey && !event.altKey) {\n\t              handled = this[_symbols2.default.goLeft]();\n\t            }\n\t            break;\n\t          case 38:\n\t            // Up\n\t            if (vertical) {\n\t              handled = event.altKey ? this[_symbols2.default.goStart]() : this[_symbols2.default.goUp]();\n\t            }\n\t            break;\n\t          case 39:\n\t            // Right\n\t            if (horizontal && !event.metaKey && !event.altKey) {\n\t              handled = this[_symbols2.default.goRight]();\n\t            }\n\t            break;\n\t          case 40:\n\t            // Down\n\t            if (vertical) {\n\t              handled = event.altKey ? this[_symbols2.default.goEnd]() : this[_symbols2.default.goDown]();\n\t            }\n\t            break;\n\t        }\n\t        // Prefer mixin result if it's defined, otherwise use base result.\n\t        return handled || _get(KeyboardDirection.prototype.__proto__ || Object.getPrototypeOf(KeyboardDirection.prototype), _symbols2.default.keydown, this) && _get(KeyboardDirection.prototype.__proto__ || Object.getPrototypeOf(KeyboardDirection.prototype), _symbols2.default.keydown, this).call(this, event) || false;\n\t      }\n\t    }]);\n\t\n\t    return KeyboardDirection;\n\t  }(base);\n\t\n\t  return KeyboardDirection;\n\t}\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\texports.default = KeyboardMixin;\n\t\n\tvar _symbols = __webpack_require__(5);\n\t\n\tvar _symbols2 = _interopRequireDefault(_symbols);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t/**\n\t * Mixin which manages the keydown handling for a component.\n\t *\n\t * This mixin handles several keyboard-related features.\n\t *\n\t * First, it wires up a single keydown event handler that can be shared by\n\t * multiple mixins on a component. The event handler will invoke a `keydown`\n\t * method with the event object, and any mixin along the prototype chain that\n\t * wants to handle that method can do so.\n\t *\n\t * If a mixin wants to indicate that keyboard event has been handled, and that\n\t * other mixins should *not* handle it, the mixin's `keydown` handler should\n\t * return a value of true. The convention that seems to work well is that a\n\t * mixin should see if it wants to handle the event and, if not, then ask the\n\t * superclass to see if it wants to handle the event. This has the effect of\n\t * giving the mixin that was applied last the first chance at handling a\n\t * keyboard event.\n\t *\n\t * Example:\n\t *\n\t *     [symbols.keydown](event) {\n\t *       let handled;\n\t *       switch (event.keyCode) {\n\t *         // Handle the keys you want, setting handled = true if appropriate.\n\t *       }\n\t *       // Prefer mixin result if it's defined, otherwise use base result.\n\t *       return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n\t *     }\n\t *\n\t * Until iOS Safari supports the `KeyboardEvent.key` property\n\t * (see http://caniuse.com/#search=keyboardevent.key), mixins should generally\n\t * test keys using the legacy `keyCode` property, not `key`.\n\t *\n\t * A second feature provided by this mixin is that it implicitly makes the\n\t * component a tab stop if it isn't already, by setting `tabIndex` to 0. This\n\t * has the effect of adding the component to the tab order in document order.\n\t *\n\t * @module KeyboardMixin\n\t * @param base {Class} the base class to extend\n\t * @returns {Class} the extended class\n\t */\n\tfunction KeyboardMixin(base) {\n\t\n\t  /**\n\t   * The class prototype added by the mixin.\n\t   */\n\t  var Keyboard = function (_base) {\n\t    _inherits(Keyboard, _base);\n\t\n\t    function Keyboard() {\n\t      _classCallCheck(this, Keyboard);\n\t\n\t      var _this = _possibleConstructorReturn(this, (Keyboard.__proto__ || Object.getPrototypeOf(Keyboard)).call(this));\n\t\n\t      _this.addEventListener('keydown', function (event) {\n\t        _this[_symbols2.default.raiseChangeEvents] = true;\n\t        var handled = _this[_symbols2.default.keydown](event);\n\t        if (handled) {\n\t          event.preventDefault();\n\t          event.stopPropagation();\n\t        }\n\t        _this[_symbols2.default.raiseChangeEvents] = false;\n\t      });\n\t      return _this;\n\t    }\n\t\n\t    _createClass(Keyboard, [{\n\t      key: 'connectedCallback',\n\t      value: function connectedCallback() {\n\t        if (_get(Keyboard.prototype.__proto__ || Object.getPrototypeOf(Keyboard.prototype), 'connectedCallback', this)) {\n\t          _get(Keyboard.prototype.__proto__ || Object.getPrototypeOf(Keyboard.prototype), 'connectedCallback', this).call(this);\n\t        }\n\t        if (this.getAttribute('tabindex') == null && this[_symbols2.default.defaults].tabindex !== null) {\n\t          this.setAttribute('tabindex', this[_symbols2.default.defaults].tabindex);\n\t        }\n\t      }\n\t    }, {\n\t      key: _symbols2.default.keydown,\n\t\n\t\n\t      /**\n\t       * Handle the indicated keyboard event.\n\t       *\n\t       * The default implementation of this method does nothing. This will\n\t       * typically be handled by other mixins.\n\t       *\n\t       * @param {KeyboardEvent} event - the keyboard event\n\t       * @return {boolean} true if the event was handled\n\t       */\n\t      value: function value(event) {\n\t        if (_get(Keyboard.prototype.__proto__ || Object.getPrototypeOf(Keyboard.prototype), _symbols2.default.keydown, this)) {\n\t          return _get(Keyboard.prototype.__proto__ || Object.getPrototypeOf(Keyboard.prototype), _symbols2.default.keydown, this).call(this, event);\n\t        }\n\t      }\n\t    }, {\n\t      key: _symbols2.default.defaults,\n\t      get: function get() {\n\t        var defaults = _get(Keyboard.prototype.__proto__ || Object.getPrototypeOf(Keyboard.prototype), _symbols2.default.defaults, this) || {};\n\t        // The default tab index is 0 (document order).\n\t        defaults.tabindex = 0;\n\t        return defaults;\n\t      }\n\t    }]);\n\t\n\t    return Keyboard;\n\t  }(base);\n\t\n\t  return Keyboard;\n\t}\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\texports.default = KeyboardPagedSelectionMixin;\n\t\n\tvar _defaultScrollTarget = __webpack_require__(13);\n\t\n\tvar _defaultScrollTarget2 = _interopRequireDefault(_defaultScrollTarget);\n\t\n\tvar _symbols = __webpack_require__(5);\n\t\n\tvar _symbols2 = _interopRequireDefault(_symbols);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t/**\n\t * Mixin which maps page keys (Page Up, Page Down) into operations that move\n\t * the selection by one page.\n\t *\n\t * The keyboard interaction model generally follows that of Microsoft Windows'\n\t * list boxes instead of those in OS X:\n\t *\n\t * * The Page Up/Down and Home/End keys actually change the selection, rather\n\t *   than just scrolling. The former behavior seems more generally useful for\n\t *   keyboard users.\n\t *\n\t * * Pressing Page Up/Down will change the selection to the topmost/bottommost\n\t *   visible item if the selection is not already there. Thereafter, the key\n\t *   will move the selection up/down by a page, and (per the above point) make\n\t *   the selected item visible.\n\t *\n\t * To ensure the selected item is in view following use of Page Up/Down, use\n\t * the related [SelectionInViewMixin](SelectionInViewMixin.md).\n\t *\n\t * This mixin expects the component to provide:\n\t *\n\t * * A `[symbols.keydown]` method invoked when a key is pressed. You can use\n\t *   [KeyboardMixin](KeyboardMixin.md) for that purpose, or wire up your own\n\t *   keyboard handling and call `[symbols.keydown]` yourself.\n\t * * A `selectedIndex` property that indicates the index of the selected item.\n\t *\n\t * @module KeyboardPagedSelectionMixin\n\t * @param base {Class} the base class to extend\n\t * @returns {Class} the extended class\n\t */\n\tfunction KeyboardPagedSelectionMixin(base) {\n\t\n\t  /**\n\t   * The class prototype added by the mixin.\n\t   */\n\t  var KeyboardPagedSelection = function (_base) {\n\t    _inherits(KeyboardPagedSelection, _base);\n\t\n\t    function KeyboardPagedSelection() {\n\t      _classCallCheck(this, KeyboardPagedSelection);\n\t\n\t      return _possibleConstructorReturn(this, (KeyboardPagedSelection.__proto__ || Object.getPrototypeOf(KeyboardPagedSelection)).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(KeyboardPagedSelection, [{\n\t      key: _symbols2.default.keydown,\n\t      value: function value(event) {\n\t        var handled = false;\n\t        var orientation = this[_symbols2.default.orientation];\n\t        if (orientation !== 'horizontal') {\n\t          switch (event.keyCode) {\n\t            case 33:\n\t              // Page Up\n\t              handled = this.pageUp();\n\t              break;\n\t            case 34:\n\t              // Page Down\n\t              handled = this.pageDown();\n\t              break;\n\t          }\n\t        }\n\t        // Prefer mixin result if it's defined, otherwise use base result.\n\t        return handled || _get(KeyboardPagedSelection.prototype.__proto__ || Object.getPrototypeOf(KeyboardPagedSelection.prototype), _symbols2.default.keydown, this) && _get(KeyboardPagedSelection.prototype.__proto__ || Object.getPrototypeOf(KeyboardPagedSelection.prototype), _symbols2.default.keydown, this).call(this, event);\n\t      }\n\t\n\t      /**\n\t       * Scroll down one page.\n\t       */\n\t\n\t    }, {\n\t      key: 'pageDown',\n\t      value: function pageDown() {\n\t        if (_get(KeyboardPagedSelection.prototype.__proto__ || Object.getPrototypeOf(KeyboardPagedSelection.prototype), 'pageDown', this)) {\n\t          _get(KeyboardPagedSelection.prototype.__proto__ || Object.getPrototypeOf(KeyboardPagedSelection.prototype), 'pageDown', this).call(this);\n\t        }\n\t        return scrollOnePage(this, true);\n\t      }\n\t\n\t      /**\n\t       * Scroll up one page.\n\t       */\n\t\n\t    }, {\n\t      key: 'pageUp',\n\t      value: function pageUp() {\n\t        if (_get(KeyboardPagedSelection.prototype.__proto__ || Object.getPrototypeOf(KeyboardPagedSelection.prototype), 'pageUp', this)) {\n\t          _get(KeyboardPagedSelection.prototype.__proto__ || Object.getPrototypeOf(KeyboardPagedSelection.prototype), 'pageUp', this).call(this);\n\t        }\n\t        return scrollOnePage(this, false);\n\t      }\n\t\n\t      /* Provide a default scrollTarget implementation if none exists. */\n\t\n\t    }, {\n\t      key: _symbols2.default.scrollTarget,\n\t      get: function get() {\n\t        return _get(KeyboardPagedSelection.prototype.__proto__ || Object.getPrototypeOf(KeyboardPagedSelection.prototype), _symbols2.default.scrollTarget, this) || (0, _defaultScrollTarget2.default)(this);\n\t      }\n\t    }]);\n\t\n\t    return KeyboardPagedSelection;\n\t  }(base);\n\t\n\t  return KeyboardPagedSelection;\n\t}\n\t\n\t// Return the item whose content spans the given y position (relative to the\n\t// top of the list's scrolling client area), or null if not found.\n\t//\n\t// If downward is true, move down the list of items to find the first item\n\t// found at the given y position; if downward is false, move up the list of\n\t// items to find the last item at that position.\n\tfunction getIndexOfItemAtY(element, scrollTarget, y, downward) {\n\t\n\t  var items = element.items;\n\t  var start = downward ? 0 : items.length - 1;\n\t  var end = downward ? items.length : 0;\n\t  var step = downward ? 1 : -1;\n\t\n\t  var topOfClientArea = scrollTarget.offsetTop + scrollTarget.clientTop;\n\t\n\t  // Find the item spanning the indicated y coordinate.\n\t  var item = void 0;\n\t  var itemIndex = start;\n\t  var itemTop = void 0;\n\t  var found = false;\n\t  while (itemIndex !== end) {\n\t    item = items[itemIndex];\n\t    itemTop = item.offsetTop - topOfClientArea;\n\t    var itemBottom = itemTop + item.offsetHeight;\n\t    if (itemTop <= y && itemBottom >= y) {\n\t      // Item spans the indicated y coordinate.\n\t      found = true;\n\t      break;\n\t    }\n\t    itemIndex += step;\n\t  }\n\t\n\t  if (!found) {\n\t    return null;\n\t  }\n\t\n\t  // We may have found an item whose padding spans the given y coordinate,\n\t  // but whose content is actually above/below that point.\n\t  // TODO: If the item has a border, then padding should be included in\n\t  // considering a hit.\n\t  var itemStyle = getComputedStyle(item);\n\t  var itemPaddingTop = parseFloat(itemStyle.paddingTop);\n\t  var itemPaddingBottom = parseFloat(itemStyle.paddingBottom);\n\t  var contentTop = itemTop + item.clientTop + itemPaddingTop;\n\t  var contentBottom = contentTop + item.clientHeight - itemPaddingTop - itemPaddingBottom;\n\t  if (downward && contentTop <= y || !downward && contentBottom >= y) {\n\t    // The indicated coordinate hits the actual item content.\n\t    return itemIndex;\n\t  } else {\n\t    // The indicated coordinate falls within the item's padding. Back up to\n\t    // the item below/above the item we found and return that.\n\t    return itemIndex - step;\n\t  }\n\t}\n\t\n\t// Move by one page downward (if downward is true), or upward (if false).\n\t// Return true if we ended up changing the selection, false if not.\n\tfunction scrollOnePage(element, downward) {\n\t\n\t  // Determine the item visible just at the edge of direction we're heading.\n\t  // We'll select that item if it's not already selected.\n\t  var scrollTarget = element[_symbols2.default.scrollTarget];\n\t  var edge = scrollTarget.scrollTop + (downward ? scrollTarget.clientHeight : 0);\n\t  var indexOfItemAtEdge = getIndexOfItemAtY(element, scrollTarget, edge, downward);\n\t\n\t  var selectedIndex = element.selectedIndex;\n\t  var newIndex = void 0;\n\t  if (indexOfItemAtEdge && selectedIndex === indexOfItemAtEdge) {\n\t    // The item at the edge was already selected, so scroll in the indicated\n\t    // direction by one page. Leave the new item at that edge selected.\n\t    var delta = (downward ? 1 : -1) * scrollTarget.clientHeight;\n\t    newIndex = getIndexOfItemAtY(element, scrollTarget, edge + delta, downward);\n\t  } else {\n\t    // The item at the edge wasn't selected yet. Instead of scrolling, we'll\n\t    // just select that item. That is, the first attempt to page up/down\n\t    // usually just moves the selection to the edge in that direction.\n\t    newIndex = indexOfItemAtEdge;\n\t  }\n\t\n\t  if (!newIndex) {\n\t    // We can't find an item in the direction we want to travel. Select the\n\t    // last item (if moving downward) or first item (if moving upward).\n\t    newIndex = downward ? element.items.length - 1 : 0;\n\t  }\n\t\n\t  if (newIndex !== selectedIndex) {\n\t    element.selectedIndex = newIndex;\n\t    return true; // We handled the page up/down ourselves.\n\t  } else {\n\t    return false; // We didn't do anything.\n\t  }\n\t}\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = defaultScrollTarget;\n\t/**\n\t * Return a guess as to what portion of the given element can be scrolled.\n\t * This can be used to provide a default implementation of\n\t * [symbols.scrollTarget].\n\t *\n\t * If the element has a shadow root containing a default (unnamed) slot, this\n\t * returns the first ancestor of that slot that is styled with `overflow-y:\n\t * auto` or `overflow-y: scroll`. If the element has no default slot, or no\n\t * scrolling ancestor is found, the element itself is returned.\n\t *\n\t * @type {HTMLElement}\n\t */\n\tfunction defaultScrollTarget(element) {\n\t  var slot = element.shadowRoot && element.shadowRoot.querySelector('slot:not([name])');\n\t  return slot ? getScrollingParent(slot, element) : element;\n\t}\n\t\n\t// Return the parent of the given element that can be scroll vertically. If no\n\t// such element is found, return the given root element.\n\tfunction getScrollingParent(element, root) {\n\t  if (element === null || element === root) {\n\t    // Didn't find a scrolling parent; use the root element instead.\n\t    return root;\n\t  }\n\t  var overflowY = getComputedStyle(element).overflowY;\n\t  if (overflowY === 'scroll' || overflowY === 'auto') {\n\t    // Found an element we can scroll vertically.\n\t    return element;\n\t  }\n\t  // Keep looking higher in the hierarchy for a scrolling parent.\n\t  return getScrollingParent(element.parentNode, root);\n\t}\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _set = function set(object, property, value, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent !== null) { set(parent, property, value, receiver); } } else if (\"value\" in desc && desc.writable) { desc.value = value; } else { var setter = desc.set; if (setter !== undefined) { setter.call(receiver, value); } } return value; };\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\texports.default = KeyboardPrefixSelectionMixin;\n\t\n\tvar _constants = __webpack_require__(15);\n\t\n\tvar _constants2 = _interopRequireDefault(_constants);\n\t\n\tvar _Symbol2 = __webpack_require__(6);\n\t\n\tvar _Symbol3 = _interopRequireDefault(_Symbol2);\n\t\n\tvar _symbols = __webpack_require__(5);\n\t\n\tvar _symbols2 = _interopRequireDefault(_symbols);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t// Symbols for private data members on an element.\n\tvar itemTextContentsSymbol = (0, _Symbol3.default)('itemTextContents');\n\tvar typedPrefixSymbol = (0, _Symbol3.default)('typedPrefix');\n\tvar prefixTimeoutSymbol = (0, _Symbol3.default)('prefixTimeout');\n\tvar settingSelectionSymbol = (0, _Symbol3.default)('settingSelection');\n\t\n\t/**\n\t * Mixin that handles list box-style prefix typing, in which the user can type\n\t * a string to select the first item that begins with that string.\n\t *\n\t * Example: suppose a component using this mixin has the following items:\n\t *\n\t *     <sample-list-component>\n\t *       <div>Apple</div>\n\t *       <div>Apricot</div>\n\t *       <div>Banana</div>\n\t *       <div>Blackberry</div>\n\t *       <div>Blueberry</div>\n\t *       <div>Cantaloupe</div>\n\t *       <div>Cherry</div>\n\t *       <div>Lemon</div>\n\t *       <div>Lime</div>\n\t *     </sample-list-component>\n\t *\n\t * If this component receives the focus, and the user presses the \"b\" or \"B\"\n\t * key, the \"Banana\" item will be selected, because it's the first item that\n\t * matches the prefix \"b\". (Matching is case-insensitive.) If the user now\n\t * presses the \"l\" or \"L\" key quickly, the prefix to match becomes \"bl\", so\n\t * \"Blackberry\" will be selected.\n\t *\n\t * The prefix typing feature has a one second timeout the prefix to match\n\t * will be reset after a second has passed since the user last typed a key.\n\t * If, in the above example, the user waits a second between typing \"b\" and\n\t * \"l\", the prefix will become \"l\", so \"Lemon\" would be selected.\n\t *\n\t * This mixin expects the component to invoke a `keydown` method when a key is\n\t * pressed. You can use [KeyboardMixin](KeyboardMixin.md) for that\n\t * purpose, or wire up your own keyboard handling and call `keydown` yourself.\n\t *\n\t * This mixin also expects the component to provide an `items` property. The\n\t * `textContent` of those items will be used for purposes of prefix matching.\n\t *\n\t * @module KeyboardPrefixSelectionMixin\n\t * @param base {Class} the base class to extend\n\t * @returns {Class} the extended class\n\t */\n\tfunction KeyboardPrefixSelectionMixin(base) {\n\t\n\t  /**\n\t   * The class prototype added by the mixin.\n\t   */\n\t  var KeyboardPrefixSelection = function (_base) {\n\t    _inherits(KeyboardPrefixSelection, _base);\n\t\n\t    function KeyboardPrefixSelection() {\n\t      _classCallCheck(this, KeyboardPrefixSelection);\n\t\n\t      return _possibleConstructorReturn(this, (KeyboardPrefixSelection.__proto__ || Object.getPrototypeOf(KeyboardPrefixSelection)).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(KeyboardPrefixSelection, [{\n\t      key: _symbols2.default.getItemText,\n\t\n\t\n\t      // Default implementation returns an item's `alt` attribute or its\n\t      // `textContent`, in that order.\n\t      value: function value(item) {\n\t        return item.getAttribute('alt') || item.textContent;\n\t      }\n\t\n\t      // If the set of items has changed, reset the prefix. We'll also need to\n\t      // rebuild our cache of item text the next time we're asked for it.\n\t\n\t    }, {\n\t      key: _symbols2.default.itemsChanged,\n\t      value: function value() {\n\t        if (_get(KeyboardPrefixSelection.prototype.__proto__ || Object.getPrototypeOf(KeyboardPrefixSelection.prototype), _symbols2.default.itemsChanged, this)) {\n\t          _get(KeyboardPrefixSelection.prototype.__proto__ || Object.getPrototypeOf(KeyboardPrefixSelection.prototype), _symbols2.default.itemsChanged, this).call(this);\n\t        }\n\t        this[itemTextContentsSymbol] = null;\n\t        resetTypedPrefix(this);\n\t      }\n\t    }, {\n\t      key: _symbols2.default.keydown,\n\t      value: function value(event) {\n\t        var handled = void 0;\n\t        var resetPrefix = true;\n\t\n\t        switch (event.keyCode) {\n\t          case 8:\n\t            // Backspace\n\t            handleBackspace(this);\n\t            handled = true;\n\t            resetPrefix = false;\n\t            break;\n\t          case 27:\n\t            // Escape\n\t            handled = true;\n\t            break;\n\t          default:\n\t            if (!event.ctrlKey && !event.metaKey && !event.altKey && event.which !== 32 /* Space */) {\n\t                handlePlainCharacter(this, String.fromCharCode(event.keyCode));\n\t              }\n\t            resetPrefix = false;\n\t        }\n\t\n\t        if (resetPrefix) {\n\t          resetTypedPrefix(this);\n\t        }\n\t\n\t        // Prefer mixin result if it's defined, otherwise use base result.\n\t        return handled || _get(KeyboardPrefixSelection.prototype.__proto__ || Object.getPrototypeOf(KeyboardPrefixSelection.prototype), _symbols2.default.keydown, this) && _get(KeyboardPrefixSelection.prototype.__proto__ || Object.getPrototypeOf(KeyboardPrefixSelection.prototype), _symbols2.default.keydown, this).call(this, event);\n\t      }\n\t    }, {\n\t      key: 'selectItemWithTextPrefix',\n\t\n\t\n\t      /**\n\t       * Select the first item whose text content begins with the given prefix.\n\t       *\n\t       * @param prefix [String] The prefix string to search for\n\t       */\n\t      value: function selectItemWithTextPrefix(prefix) {\n\t        if (_get(KeyboardPrefixSelection.prototype.__proto__ || Object.getPrototypeOf(KeyboardPrefixSelection.prototype), 'selectItemWithTextPrefix', this)) {\n\t          _get(KeyboardPrefixSelection.prototype.__proto__ || Object.getPrototypeOf(KeyboardPrefixSelection.prototype), 'selectItemWithTextPrefix', this).call(this, prefix);\n\t        }\n\t        if (prefix == null || prefix.length === 0) {\n\t          return;\n\t        }\n\t        var index = getIndexOfItemWithTextPrefix(this, prefix);\n\t        if (index >= 0) {\n\t          // Update the selection. During that operation, set the flag that lets\n\t          // us know that we are the cause of the selection change. See note at\n\t          // this mixin's `selectedIndex` implementation.\n\t          this[settingSelectionSymbol] = true;\n\t          this.selectedIndex = index;\n\t          this[settingSelectionSymbol] = false;\n\t        }\n\t      }\n\t    }, {\n\t      key: 'selectedIndex',\n\t      get: function get() {\n\t        return _get(KeyboardPrefixSelection.prototype.__proto__ || Object.getPrototypeOf(KeyboardPrefixSelection.prototype), 'selectedIndex', this);\n\t      },\n\t      set: function set(index) {\n\t        if ('selectedIndex' in base.prototype) {\n\t          _set(KeyboardPrefixSelection.prototype.__proto__ || Object.getPrototypeOf(KeyboardPrefixSelection.prototype), 'selectedIndex', index, this);\n\t        }\n\t        if (!this[settingSelectionSymbol]) {\n\t          // Someone else (not this mixin) has changed the selection. In response,\n\t          // we invalidate the prefix under construction.\n\t          resetTypedPrefix(this);\n\t        }\n\t      }\n\t    }]);\n\t\n\t    return KeyboardPrefixSelection;\n\t  }(base);\n\t\n\t  return KeyboardPrefixSelection;\n\t}\n\t\n\t// Return the index of the first item with the given prefix, else -1.\n\tfunction getIndexOfItemWithTextPrefix(element, prefix) {\n\t  var itemTextContents = getItemTextContents(element);\n\t  var prefixLength = prefix.length;\n\t  for (var i = 0; i < itemTextContents.length; i++) {\n\t    var itemTextContent = itemTextContents[i];\n\t    if (itemTextContent.substr(0, prefixLength) === prefix) {\n\t      return i;\n\t    }\n\t  }\n\t  return -1;\n\t}\n\t\n\t// Return an array of the text content (in lowercase) of all items.\n\t// Cache these results.\n\tfunction getItemTextContents(element) {\n\t  if (!element[itemTextContentsSymbol]) {\n\t    var items = element.items;\n\t    element[itemTextContentsSymbol] = Array.prototype.map.call(items, function (item) {\n\t      var text = element[_symbols2.default.getItemText](item);\n\t      return text.toLowerCase();\n\t    });\n\t  }\n\t  return element[itemTextContentsSymbol];\n\t}\n\t\n\t// Handle the Backspace key: remove the last character from the prefix.\n\tfunction handleBackspace(element) {\n\t  var length = element[typedPrefixSymbol] ? element[typedPrefixSymbol].length : 0;\n\t  if (length > 0) {\n\t    element[typedPrefixSymbol] = element[typedPrefixSymbol].substr(0, length - 1);\n\t  }\n\t  element.selectItemWithTextPrefix(element[typedPrefixSymbol]);\n\t  setPrefixTimeout(element);\n\t}\n\t\n\t// Add a plain character to the prefix.\n\tfunction handlePlainCharacter(element, char) {\n\t  var prefix = element[typedPrefixSymbol] || '';\n\t  element[typedPrefixSymbol] = prefix + char.toLowerCase();\n\t  element.selectItemWithTextPrefix(element[typedPrefixSymbol]);\n\t  setPrefixTimeout(element);\n\t}\n\t\n\t// Stop listening for typing.\n\tfunction resetPrefixTimeout(element) {\n\t  if (element[prefixTimeoutSymbol]) {\n\t    clearTimeout(element[prefixTimeoutSymbol]);\n\t    element[prefixTimeoutSymbol] = false;\n\t  }\n\t}\n\t\n\t// Clear the prefix under construction.\n\tfunction resetTypedPrefix(element) {\n\t  element[typedPrefixSymbol] = '';\n\t  resetPrefixTimeout(element);\n\t}\n\t\n\t// Wait for the user to stop typing.\n\tfunction setPrefixTimeout(element) {\n\t  resetPrefixTimeout(element);\n\t  element[prefixTimeoutSymbol] = setTimeout(function () {\n\t    resetTypedPrefix(element);\n\t  }, _constants2.default.TYPING_TIMEOUT_DURATION);\n\t}\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/**\n\t * A collection of constants used by Elix mixins and components for consistency\n\t * in things such as user interface timings.\n\t *\n\t * @module constants\n\t */\n\tvar constants = {\n\t\n\t  /**\n\t   * Time in milliseconds after which the user is considered to have stopped\n\t   * typing.\n\t   *\n\t   * @const {number} TYPING_TIMEOUT_DURATION\n\t   */\n\t  TYPING_TIMEOUT_DURATION: 1000\n\t\n\t};\n\t\n\texports.default = constants;\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _set = function set(object, property, value, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent !== null) { set(parent, property, value, receiver); } } else if (\"value\" in desc && desc.writable) { desc.value = value; } else { var setter = desc.set; if (setter !== undefined) { setter.call(receiver, value); } } return value; };\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\texports.default = function (base) {\n\t\n\t  /**\n\t   * The class prototype added by the mixin.\n\t   */\n\t  var SelectionAria = function (_base) {\n\t    _inherits(SelectionAria, _base);\n\t\n\t    function SelectionAria() {\n\t      _classCallCheck(this, SelectionAria);\n\t\n\t      return _possibleConstructorReturn(this, (SelectionAria.__proto__ || Object.getPrototypeOf(SelectionAria)).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(SelectionAria, [{\n\t      key: 'connectedCallback',\n\t      value: function connectedCallback() {\n\t        if (_get(SelectionAria.prototype.__proto__ || Object.getPrototypeOf(SelectionAria.prototype), 'connectedCallback', this)) {\n\t          _get(SelectionAria.prototype.__proto__ || Object.getPrototypeOf(SelectionAria.prototype), 'connectedCallback', this).call(this);\n\t        }\n\t\n\t        // Set default ARIA role for the overall component.\n\t        if (this.getAttribute('role') == null && this[_symbols2.default.defaults].role) {\n\t          this.setAttribute('role', this[_symbols2.default.defaults].role);\n\t        }\n\t      }\n\t    }, {\n\t      key: _symbols2.default.itemAdded,\n\t      value: function value(item) {\n\t        if (_get(SelectionAria.prototype.__proto__ || Object.getPrototypeOf(SelectionAria.prototype), _symbols2.default.itemAdded, this)) {\n\t          _get(SelectionAria.prototype.__proto__ || Object.getPrototypeOf(SelectionAria.prototype), _symbols2.default.itemAdded, this).call(this, item);\n\t        }\n\t\n\t        if (!item.getAttribute('role')) {\n\t          // Assign a default ARIA role for an individual item.\n\t          item.setAttribute('role', this[_symbols2.default.defaults].itemRole);\n\t        }\n\t\n\t        // Ensure each item has an ID so we can set aria-activedescendant on the\n\t        // overall list whenever the selection changes.\n\t        //\n\t        // The ID will take the form of a base ID plus a unique integer. The base\n\t        // ID will be incorporate the component's own ID. E.g., if a component has\n\t        // ID \"foo\", then its items will have IDs that look like \"_fooOption1\". If\n\t        // the compnent has no ID itself, its items will get IDs that look like\n\t        // \"_option1\". Item IDs are prefixed with an underscore to differentiate\n\t        // them from manually-assigned IDs, and to minimize the potential for ID\n\t        // conflicts.\n\t        if (!item.id) {\n\t          var baseId = this.id ? \"_\" + this.id + \"Option\" : \"_option\";\n\t          item.id = baseId + idCount++;\n\t        }\n\t      }\n\t    }, {\n\t      key: _symbols2.default.itemSelected,\n\t      value: function value(item, selected) {\n\t        if (_get(SelectionAria.prototype.__proto__ || Object.getPrototypeOf(SelectionAria.prototype), _symbols2.default.itemSelected, this)) {\n\t          _get(SelectionAria.prototype.__proto__ || Object.getPrototypeOf(SelectionAria.prototype), _symbols2.default.itemSelected, this).call(this, item, selected);\n\t        }\n\t        item.setAttribute('aria-selected', selected);\n\t        var itemId = item.id;\n\t        if (itemId && selected) {\n\t          this.setAttribute('aria-activedescendant', itemId);\n\t        }\n\t      }\n\t    }, {\n\t      key: _symbols2.default.defaults,\n\t      get: function get() {\n\t        var defaults = _get(SelectionAria.prototype.__proto__ || Object.getPrototypeOf(SelectionAria.prototype), _symbols2.default.defaults, this) || {};\n\t        defaults.role = 'listbox';\n\t        defaults.itemRole = 'option';\n\t        return defaults;\n\t      }\n\t    }, {\n\t      key: 'selectedItem',\n\t      get: function get() {\n\t        return _get(SelectionAria.prototype.__proto__ || Object.getPrototypeOf(SelectionAria.prototype), 'selectedItem', this);\n\t      },\n\t      set: function set(item) {\n\t        if ('selectedItem' in base.prototype) {\n\t          _set(SelectionAria.prototype.__proto__ || Object.getPrototypeOf(SelectionAria.prototype), 'selectedItem', item, this);\n\t        }\n\t        if (item == null) {\n\t          // Selection was removed.\n\t          this.removeAttribute('aria-activedescendant');\n\t        }\n\t      }\n\t    }]);\n\t\n\t    return SelectionAria;\n\t  }(base);\n\t\n\t  return SelectionAria;\n\t};\n\t\n\tvar _symbols = __webpack_require__(5);\n\t\n\tvar _symbols2 = _interopRequireDefault(_symbols);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t// Used to assign unique IDs to item elements without IDs.\n\tvar idCount = 0;\n\t\n\t/**\n\t * Mixin which treats the selected item in a list as the active item in ARIA\n\t * accessibility terms.\n\t *\n\t * Handling ARIA selection state properly is actually quite complex:\n\t *\n\t * * The items in the list need to be indicated as possible items via an ARIA\n\t *   `role` attribute value such as \"option\".\n\t * * The selected item need to be marked as selected by setting the item's\n\t *   `aria-selected` attribute to true *and* the other items need be marked as\n\t *   *not* selected by setting `aria-selected` to false.\n\t * * The outermost element with the keyboard focus needs to have attributes\n\t *   set on it so that the selection is knowable at the list level via the\n\t *   `aria-activedescendant` attribute.\n\t * * Use of `aria-activedescendant` in turn requires that all items in the\n\t *   list have ID attributes assigned to them.\n\t *\n\t * This mixin tries to address all of the above requirements. To that end,\n\t * this mixin will assign generated IDs to any item that doesn't already have\n\t * an ID.\n\t *\n\t * ARIA relies on elements to provide `role` attributes. This mixin will apply\n\t * a default role of \"listbox\" on the outer list if it doesn't already have an\n\t * explicit role. Similarly, this mixin will apply a default role of \"option\"\n\t * to any list item that does not already have a role specified.\n\t *\n\t * This mixin expects a set of members that manage the state of the selection:\n\t * `[symbols.itemSelected]`, `[symbols.itemAdded]`, and `selectedItem`. You can\n\t * supply these yourself, or do so via\n\t * [SingleSelectionMixin](SingleSelectionMixin.md).\n\t *\n\t * @module\n\t * @param base {Class} the base class to extend\n\t * @returns {Class} the extended class\n\t */\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _set = function set(object, property, value, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent !== null) { set(parent, property, value, receiver); } } else if (\"value\" in desc && desc.writable) { desc.value = value; } else { var setter = desc.set; if (setter !== undefined) { setter.call(receiver, value); } } return value; };\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tvar _defaultScrollTarget = __webpack_require__(13);\n\t\n\tvar _defaultScrollTarget2 = _interopRequireDefault(_defaultScrollTarget);\n\t\n\tvar _symbols = __webpack_require__(5);\n\t\n\tvar _symbols2 = _interopRequireDefault(_symbols);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t/**\n\t * Mixin which scrolls a container horizontally and/or vertically to ensure that\n\t * a newly-selected item is visible to the user.\n\t *\n\t * When the selected item in a list-like component changes, the selected item\n\t * should be brought into view so that the user can confirm their selection.\n\t *\n\t * This mixin expects a `selectedItem` property to be set when the selection\n\t * changes. You can supply that yourself, or use\n\t * [SingleSelectionMixin](SingleSelectionMixin.md).\n\t *\n\t * @module SelectinInViewMixin\n\t * @param base {Class} the base class to extend\n\t * @returns {Class} the extended class\n\t */\n\texports.default = function (base) {\n\t\n\t  /**\n\t   * The class prototype added by the mixin.\n\t   */\n\t  var SelectionInView = function (_base) {\n\t    _inherits(SelectionInView, _base);\n\t\n\t    function SelectionInView() {\n\t      _classCallCheck(this, SelectionInView);\n\t\n\t      return _possibleConstructorReturn(this, (SelectionInView.__proto__ || Object.getPrototypeOf(SelectionInView)).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(SelectionInView, [{\n\t      key: 'connectedCallback',\n\t      value: function connectedCallback() {\n\t        if (_get(SelectionInView.prototype.__proto__ || Object.getPrototypeOf(SelectionInView.prototype), 'connectedCallback', this)) {\n\t          _get(SelectionInView.prototype.__proto__ || Object.getPrototypeOf(SelectionInView.prototype), 'connectedCallback', this).call(this);\n\t        }\n\t        var selectedItem = this.selectedItem;\n\t        if (selectedItem) {\n\t          this.scrollItemIntoView(selectedItem);\n\t        }\n\t      }\n\t\n\t      /**\n\t       * Scroll the given element completely into view, minimizing the degree of\n\t       * scrolling performed.\n\t       *\n\t       * Blink has a `scrollIntoViewIfNeeded()` function that does something\n\t       * similar, but unfortunately it's non-standard, and in any event often ends\n\t       * up scrolling more than is absolutely necessary.\n\t       *\n\t       * This scrolls the containing element defined by the `scrollTarget`\n\t       * property. See that property for a discussion of the default value of\n\t       * that property.\n\t       *\n\t       * @param {HTMLElement} item - the item to scroll into view.\n\t       */\n\t\n\t    }, {\n\t      key: 'scrollItemIntoView',\n\t      value: function scrollItemIntoView(item) {\n\t        if (_get(SelectionInView.prototype.__proto__ || Object.getPrototypeOf(SelectionInView.prototype), 'scrollItemIntoView', this)) {\n\t          _get(SelectionInView.prototype.__proto__ || Object.getPrototypeOf(SelectionInView.prototype), 'scrollItemIntoView', this).call(this);\n\t        }\n\t\n\t        var scrollTarget = this[_symbols2.default.scrollTarget];\n\t\n\t        // Determine the bounds of the scroll target and item. We use\n\t        // getBoundingClientRect instead of .offsetTop, etc., because the latter\n\t        // round values, and we want to handle fractional values.\n\t        var scrollTargetRect = scrollTarget.getBoundingClientRect();\n\t        var itemRect = item.getBoundingClientRect();\n\t\n\t        // Determine how far the item is outside the viewport.\n\t        var bottomDelta = itemRect.bottom - scrollTargetRect.bottom;\n\t        var topDelta = itemRect.top - scrollTargetRect.top;\n\t        var leftDelta = itemRect.left - scrollTargetRect.left;\n\t        var rightDelta = itemRect.right - scrollTargetRect.right;\n\t\n\t        // Scroll the target as necessary to bring the item into view.\n\t        if (bottomDelta > 0) {\n\t          scrollTarget.scrollTop += bottomDelta; // Scroll down\n\t        } else if (topDelta < 0) {\n\t          scrollTarget.scrollTop += Math.ceil(topDelta); // Scroll up\n\t        }\n\t        if (rightDelta > 0) {\n\t          scrollTarget.scrollLeft += rightDelta; // Scroll right\n\t        } else if (leftDelta < 0) {\n\t          scrollTarget.scrollLeft += Math.ceil(leftDelta); // Scroll left\n\t        }\n\t      }\n\t\n\t      /* Provide a default scrollTarget implementation if none exists. */\n\t\n\t    }, {\n\t      key: _symbols2.default.scrollTarget,\n\t      get: function get() {\n\t        return _get(SelectionInView.prototype.__proto__ || Object.getPrototypeOf(SelectionInView.prototype), _symbols2.default.scrollTarget, this) || (0, _defaultScrollTarget2.default)(this);\n\t      }\n\t    }, {\n\t      key: 'selectedItem',\n\t      get: function get() {\n\t        return _get(SelectionInView.prototype.__proto__ || Object.getPrototypeOf(SelectionInView.prototype), 'selectedItem', this);\n\t      },\n\t      set: function set(item) {\n\t        if ('selectedItem' in base.prototype) {\n\t          _set(SelectionInView.prototype.__proto__ || Object.getPrototypeOf(SelectionInView.prototype), 'selectedItem', item, this);\n\t        }\n\t        if (item) {\n\t          // Keep the selected item in view.\n\t          this.scrollItemIntoView(item);\n\t        }\n\t      }\n\t    }]);\n\t\n\t    return SelectionInView;\n\t  }(base);\n\t\n\t  return SelectionInView;\n\t};\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\texports.default = ShadowTemplateMixin;\n\t\n\tvar _symbols = __webpack_require__(5);\n\t\n\tvar _symbols2 = _interopRequireDefault(_symbols);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t// A cache of processed templates.\n\t//\n\t// We maintain this as a map keyed by element tag (localName). We could store\n\t// an element's processed template on its element prototype. One scenario that\n\t// wouldn't support would be registration of the same constructor under multiple\n\t// tag names, which was a (perhaps theoretical) use case for Custom Elements.\n\t//\n\tvar mapTagToTemplate = {};\n\t\n\t/**\n\t * Mixin which adds stamping a template into a Shadow DOM subtree upon component\n\t * instantiation.\n\t *\n\t * To use this mixin, define a `template` property as a string or HTML\n\t * `<template>` element:\n\t *\n\t *     class MyElement extends ShadowTemplateMixin(HTMLElement) {\n\t *       get [symbols.template]() {\n\t *         return `Hello, <em>world</em>.`;\n\t *       }\n\t *     }\n\t *\n\t * When your component class is instantiated, a shadow root will be created on\n\t * the instance, and the contents of the template will be cloned into the\n\t * shadow root. If your component does not define a `template` property, this\n\t * mixin has no effect.\n\t *\n\t * For the time being, this extension retains support for Shadow DOM v0. That\n\t * will eventually be deprecated as browsers (and the Shadow DOM polyfill)\n\t * implement Shadow DOM v1.\n\t *\n\t * @module ShadowTemplateMixin\n\t * @param base {Class} the base class to extend\n\t * @returns {Class} the extended class\n\t */\n\tfunction ShadowTemplateMixin(base) {\n\t\n\t  /**\n\t   * The class prototype added by the mixin.\n\t   */\n\t  var ShadowTemplate = function (_base) {\n\t    _inherits(ShadowTemplate, _base);\n\t\n\t    /*\n\t     * If the component defines a template, a shadow root will be created on the\n\t     * component instance, and the template stamped into it.\n\t     */\n\t    function ShadowTemplate() {\n\t      _classCallCheck(this, ShadowTemplate);\n\t\n\t      var _this = _possibleConstructorReturn(this, (ShadowTemplate.__proto__ || Object.getPrototypeOf(ShadowTemplate)).call(this));\n\t\n\t      var tag = _this.localName;\n\t      var template = mapTagToTemplate[tag];\n\t\n\t      // See if we've already processed a template for this tag.\n\t      if (!template) {\n\t        // This is the first time we've created an instance of this tag.\n\t\n\t        // Get the template and perform initial processing.\n\t        template = _this[_symbols2.default.template];\n\t        if (!template) {\n\t          console.warn('ShadowTemplateMixin expects a component to define a property called [symbols.template].');\n\t          return _possibleConstructorReturn(_this);\n\t        }\n\t\n\t        if (typeof template === 'string') {\n\t          // Upgrade plain string to real template.\n\t          var templateText = template;\n\t          template = document.createElement('template');\n\t          template.innerHTML = templateText;\n\t        }\n\t\n\t        if (window.ShadyCSS) {\n\t          // Let the CSS polyfill do its own initialization.\n\t          window.ShadyCSS.prepareTemplate(template, tag);\n\t        }\n\t\n\t        // Store this for the next time we create the same type of element.\n\t        mapTagToTemplate[tag] = template;\n\t      }\n\t\n\t      // Stamp the template into a new shadow root.\n\t      var root = _this.attachShadow({ mode: 'open' });\n\t      var clone = document.importNode(template.content, true);\n\t      root.appendChild(clone);\n\t\n\t      /* Let the component know the shadow tree has been populated. */\n\t      if (_this[_symbols2.default.shadowCreated]) {\n\t        _this[_symbols2.default.shadowCreated]();\n\t      }\n\t      return _this;\n\t    }\n\t\n\t    _createClass(ShadowTemplate, [{\n\t      key: 'connectedCallback',\n\t      value: function connectedCallback() {\n\t        if (_get(ShadowTemplate.prototype.__proto__ || Object.getPrototypeOf(ShadowTemplate.prototype), 'connectedCallback', this)) {\n\t          _get(ShadowTemplate.prototype.__proto__ || Object.getPrototypeOf(ShadowTemplate.prototype), 'connectedCallback', this).call(this);\n\t        }\n\t        if (window.ShadyCSS) {\n\t          window.ShadyCSS.applyStyle(this);\n\t        }\n\t      }\n\t    }]);\n\t\n\t    return ShadowTemplate;\n\t  }(base);\n\t\n\t  return ShadowTemplate;\n\t}\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tvar _set = function set(object, property, value, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent !== null) { set(parent, property, value, receiver); } } else if (\"value\" in desc && desc.writable) { desc.value = value; } else { var setter = desc.set; if (setter !== undefined) { setter.call(receiver, value); } } return value; };\n\t\n\texports.default = SingleSelectionMixin;\n\t\n\tvar _Symbol2 = __webpack_require__(6);\n\t\n\tvar _Symbol3 = _interopRequireDefault(_Symbol2);\n\t\n\tvar _symbols = __webpack_require__(5);\n\t\n\tvar _symbols2 = _interopRequireDefault(_symbols);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t// Symbols for private data members on an element.\n\tvar canSelectNextSymbol = (0, _Symbol3.default)('canSelectNext');\n\tvar canSelectPreviousSymbol = (0, _Symbol3.default)('canSelectPrevious');\n\tvar selectionRequiredSymbol = (0, _Symbol3.default)('selectionRequired');\n\tvar selectionWrapsSymbol = (0, _Symbol3.default)('selectionWraps');\n\t\n\t// We want to expose both selectedIndex and selectedItem as independent\n\t// properties but keep them in sync. This allows a component user to reference\n\t// the selection by whatever means is most natural for their situation.\n\t//\n\t// To efficiently keep these properties in sync, we track \"external\" and\n\t// \"internal\" references for each property:\n\t//\n\t// The external index or item is the one we report to the outside world when\n\t// asked for selection.  When handling a change to index or item, we update the\n\t// external reference as soon as possible, so that if anyone immediately asks\n\t// for the current selection, they will receive a stable answer.\n\t//\n\t// The internal index or item tracks whichever index or item last received the\n\t// full set of processing. Processing includes raising a change event for the\n\t// new value. Once we've begun that processing, we store the new value as the\n\t// internal value to indicate we've handled it.\n\t//\n\tvar externalSelectedIndexSymbol = (0, _Symbol3.default)('externalSelectedIndex');\n\tvar externalSelectedItemSymbol = (0, _Symbol3.default)('externalSelectedItem');\n\tvar internalSelectedIndexSymbol = (0, _Symbol3.default)('internalSelectedIndex');\n\tvar internalSelectedItemSymbol = (0, _Symbol3.default)('internalSelectedItem');\n\t\n\t/**\n\t * Mixin which adds single-selection semantics for items in a list.\n\t *\n\t * This mixin expects a component to provide an `items` Array or NodeList of\n\t * all elements in the list.\n\t *\n\t * This mixin tracks a single selected item in the list, and provides means to\n\t * get and set that state by item position (`selectedIndex`) or item identity\n\t * (`selectedItem`). The selection can be moved in the list via the methods\n\t * `selectFirst`, `selectLast`, `selectNext`, and `selectPrevious`.\n\t *\n\t * This mixin does not produce any user-visible effects to represent\n\t * selection.\n\t *\n\t * @module SingleSelectionMixin\n\t * @param base {Class} the base class to extend\n\t * @returns {Class} the extended class\n\t */\n\tfunction SingleSelectionMixin(base) {\n\t\n\t  /**\n\t   * The class prototype added by the mixin.\n\t   */\n\t  var SingleSelection = function (_base) {\n\t    _inherits(SingleSelection, _base);\n\t\n\t    function SingleSelection() {\n\t      _classCallCheck(this, SingleSelection);\n\t\n\t      // Set defaults.\n\t      var _this = _possibleConstructorReturn(this, (SingleSelection.__proto__ || Object.getPrototypeOf(SingleSelection)).call(this));\n\t\n\t      if (typeof _this.selectionRequired === 'undefined') {\n\t        _this.selectionRequired = _this[_symbols2.default.defaults].selectionRequired;\n\t      }\n\t      if (typeof _this.selectionWraps === 'undefined') {\n\t        _this.selectionWraps = _this[_symbols2.default.defaults].selectionWraps;\n\t      }\n\t      return _this;\n\t    }\n\t\n\t    /**\n\t     * True if the selection can be moved to the next item, false if not (the\n\t     * selected item is the last item in the list).\n\t     *\n\t     * @type {boolean}\n\t     */\n\t\n\t\n\t    _createClass(SingleSelection, [{\n\t      key: _symbols2.default.itemAdded,\n\t\n\t\n\t      /**\n\t       * Handle a new item being added to the list.\n\t       *\n\t       * The default implementation of this method simply sets the item's\n\t       * selection state to false.\n\t       *\n\t       * @param {HTMLElement} item - the item being added\n\t       */\n\t      value: function value(item) {\n\t        if (_get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), _symbols2.default.itemAdded, this)) {\n\t          _get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), _symbols2.default.itemAdded, this).call(this, item);\n\t        }\n\t        this[_symbols2.default.itemSelected](item, item === this.selectedItem);\n\t      }\n\t    }, {\n\t      key: _symbols2.default.itemsChanged,\n\t      value: function value() {\n\t        if (_get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), _symbols2.default.itemsChanged, this)) {\n\t          _get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), _symbols2.default.itemsChanged, this).call(this);\n\t        }\n\t\n\t        // In case selected item changed position or was removed.\n\t        trackSelectedItem(this);\n\t\n\t        // In case the change in items affected which navigations are possible.\n\t        updatePossibleNavigations(this);\n\t      }\n\t\n\t      /**\n\t       * Apply the indicate selection state to the item.\n\t       *\n\t       * The default implementation of this method does nothing. User-visible\n\t       * effects will typically be handled by other mixins.\n\t       *\n\t       * @param {HTMLElement} item - the item being selected/deselected\n\t       * @param {boolean} selected - true if the item is selected, false if not\n\t       */\n\t\n\t    }, {\n\t      key: _symbols2.default.itemSelected,\n\t      value: function value(item, selected) {\n\t        if (_get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), _symbols2.default.itemSelected, this)) {\n\t          _get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), _symbols2.default.itemSelected, this).call(this, item, selected);\n\t        }\n\t      }\n\t\n\t      /**\n\t       * The index of the item which is currently selected.\n\t       *\n\t       * The setter expects an integer or a string representing an integer.\n\t       *\n\t       * A `selectedIndex` of -1 indicates there is no selection. Setting this\n\t       * property to -1 will remove any existing selection.\n\t       *\n\t       * @type {number}\n\t       */\n\t\n\t    }, {\n\t      key: 'selectFirst',\n\t\n\t\n\t      /**\n\t       * Select the first item in the list.\n\t       *\n\t       * @returns {Boolean} True if the selection changed, false if not.\n\t       */\n\t      value: function selectFirst() {\n\t        if (_get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectFirst', this)) {\n\t          _get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectFirst', this).call(this);\n\t        }\n\t        return selectIndex(this, 0);\n\t      }\n\t\n\t      /**\n\t       * True if the list should always have a selection (if it has items).\n\t       *\n\t       * @type {boolean}\n\t       * @default false\n\t       */\n\t\n\t    }, {\n\t      key: 'selectLast',\n\t\n\t\n\t      /**\n\t       * Select the last item in the list.\n\t       *\n\t       * @returns {Boolean} True if the selection changed, false if not.\n\t       */\n\t      value: function selectLast() {\n\t        if (_get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectLast', this)) {\n\t          _get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectLast', this).call(this);\n\t        }\n\t        return selectIndex(this, this.items.length - 1);\n\t      }\n\t\n\t      /**\n\t       * Select the next item in the list.\n\t       *\n\t       * If the list has no selection, the first item will be selected.\n\t       *\n\t       * @returns {Boolean} True if the selection changed, false if not.\n\t       */\n\t\n\t    }, {\n\t      key: 'selectNext',\n\t      value: function selectNext() {\n\t        if (_get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectNext', this)) {\n\t          _get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectNext', this).call(this);\n\t        }\n\t        return selectIndex(this, this.selectedIndex + 1);\n\t      }\n\t\n\t      /**\n\t       * Select the previous item in the list.\n\t       *\n\t       * If the list has no selection, the last item will be selected.\n\t       *\n\t       * @returns {Boolean} True if the selection changed, false if not.\n\t       */\n\t\n\t    }, {\n\t      key: 'selectPrevious',\n\t      value: function selectPrevious() {\n\t        if (_get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectPrevious', this)) {\n\t          _get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectPrevious', this).call(this);\n\t        }\n\t        var newIndex = this.selectedIndex < 0 ? this.items.length - 1 : // No selection yet; select last item.\n\t        this.selectedIndex - 1;\n\t        return selectIndex(this, newIndex);\n\t      }\n\t\n\t      /**\n\t       * Fires when the canSelectNext property changes in response to internal\n\t       * component activity.\n\t       *\n\t       * @memberof SingleSelection\n\t       * @event can-select-next-changed\n\t       */\n\t\n\t      /**\n\t       * Fires when the canSelectPrevious property changes in response to internal\n\t       * component activity.\n\t       *\n\t       * @memberof SingleSelection\n\t       * @event can-select-previous-changed\n\t       */\n\t\n\t      /**\n\t       * Fires when the selectedIndex property changes in response to internal\n\t       * component activity.\n\t       *\n\t       * @memberof SingleSelection\n\t       * @event selected-index-changed\n\t       * @param {number} detail.selectedIndex The new selected index.\n\t       */\n\t\n\t      /**\n\t       * Fires when the selectedItem property changes in response to internal\n\t       * component activity.\n\t       *\n\t       * @memberof SingleSelection\n\t       * @event selected-item-changed\n\t       * @param {HTMLElement} detail.selectedItem The new selected item.\n\t       */\n\t\n\t    }, {\n\t      key: 'canSelectNext',\n\t      get: function get() {\n\t        return this[canSelectNextSymbol];\n\t      },\n\t      set: function set(canSelectNext) {\n\t        var changed = canSelectNext !== this[canSelectNextSymbol];\n\t        this[canSelectNextSymbol] = canSelectNext;\n\t        if ('canSelectNext' in base.prototype) {\n\t          _set(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'canSelectNext', canSelectNext, this);\n\t        }\n\t        if (this[_symbols2.default.raiseChangeEvents] && changed) {\n\t          this.dispatchEvent(new CustomEvent('can-select-next-changed'));\n\t        }\n\t      }\n\t\n\t      /**\n\t       * True if the selection can be moved to the previous item, false if not\n\t       * (the selected item is the first one in the list).\n\t       *\n\t       * @type {boolean}\n\t       */\n\t\n\t    }, {\n\t      key: 'canSelectPrevious',\n\t      get: function get() {\n\t        return this[canSelectPreviousSymbol];\n\t      },\n\t      set: function set(canSelectPrevious) {\n\t        var changed = canSelectPrevious !== this[canSelectPreviousSymbol];\n\t        this[canSelectPreviousSymbol] = canSelectPrevious;\n\t        if ('canSelectPrevious' in base.prototype) {\n\t          _set(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'canSelectPrevious', canSelectPrevious, this);\n\t        }\n\t        if (this[_symbols2.default.raiseChangeEvents] && changed) {\n\t          this.dispatchEvent(new CustomEvent('can-select-previous-changed'));\n\t        }\n\t      }\n\t    }, {\n\t      key: _symbols2.default.defaults,\n\t      get: function get() {\n\t        var defaults = _get(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), _symbols2.default.defaults, this) || {};\n\t        defaults.selectionRequired = false;\n\t        defaults.selectionWraps = false;\n\t        return defaults;\n\t      }\n\t    }, {\n\t      key: 'selectedIndex',\n\t      get: function get() {\n\t        return this[externalSelectedIndexSymbol] != null ? this[externalSelectedIndexSymbol] : -1;\n\t      },\n\t      set: function set(index) {\n\t        // See notes at top about internal vs. external copies of this property.\n\t        var changed = index !== this[internalSelectedIndexSymbol];\n\t        var item = void 0;\n\t        var parsedIndex = parseInt(index);\n\t        if (parsedIndex !== this[externalSelectedIndexSymbol]) {\n\t          // Store the new index and the corresponding item.\n\t          var items = this.items;\n\t          var hasItems = items && items.length > 0;\n\t          if (!(hasItems && parsedIndex >= 0 && parsedIndex < items.length)) {\n\t            parsedIndex = -1; // No item at that index.\n\t          }\n\t          this[externalSelectedIndexSymbol] = parsedIndex;\n\t          item = hasItems && parsedIndex >= 0 ? items[parsedIndex] : null;\n\t          this[externalSelectedItemSymbol] = item;\n\t        } else {\n\t          item = this[externalSelectedItemSymbol];\n\t        }\n\t\n\t        // Now let super do any work.\n\t        if ('selectedIndex' in base.prototype) {\n\t          _set(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectedIndex', index, this);\n\t        }\n\t\n\t        if (changed) {\n\t          // The selected index changed.\n\t          this[internalSelectedIndexSymbol] = parsedIndex;\n\t\n\t          if (this[_symbols2.default.raiseChangeEvents]) {\n\t            var event = new CustomEvent('selected-index-changed', {\n\t              detail: {\n\t                selectedIndex: parsedIndex,\n\t                value: parsedIndex // for Polymer binding. TODO: Verify still necessary\n\t              }\n\t            });\n\t            this.dispatchEvent(event);\n\t          }\n\t        }\n\t\n\t        if (this[internalSelectedItemSymbol] !== item) {\n\t          // Update selectedItem property so it can have its own effects.\n\t          this.selectedItem = item;\n\t        }\n\t      }\n\t\n\t      /**\n\t       * The currently selected item, or null if there is no selection.\n\t       *\n\t       * Setting this property to null deselects any currently-selected item.\n\t       * Setting this property to an object that is not in the list has no effect.\n\t       *\n\t       * TODO: Even if selectionRequired, can still explicitly set selectedItem to null.\n\t       * TODO: If selectionRequired, leave selection alone?\n\t       *\n\t       * @type {object}\n\t       */\n\t\n\t    }, {\n\t      key: 'selectedItem',\n\t      get: function get() {\n\t        return this[externalSelectedItemSymbol] || null;\n\t      },\n\t      set: function set(item) {\n\t        // See notes at top about internal vs. external copies of this property.\n\t        var previousSelectedItem = this[internalSelectedItemSymbol];\n\t        var changed = item !== previousSelectedItem;\n\t        var index = void 0;\n\t        if (item !== this[externalSelectedItemSymbol]) {\n\t          // Store item and look up corresponding index.\n\t          var items = this.items;\n\t          var hasItems = items && items.length > 0;\n\t          index = hasItems ? Array.prototype.indexOf.call(items, item) : -1;\n\t          this[externalSelectedIndexSymbol] = index;\n\t          if (index < 0) {\n\t            item = null; // The indicated item isn't actually in `items`.\n\t          }\n\t          this[externalSelectedItemSymbol] = item;\n\t        } else {\n\t          index = this[externalSelectedIndexSymbol];\n\t        }\n\t\n\t        // Now let super do any work.\n\t        if ('selectedItem' in base.prototype) {\n\t          _set(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectedItem', item, this);\n\t        }\n\t\n\t        if (changed) {\n\t          // The selected item changed.\n\t          this[internalSelectedItemSymbol] = item;\n\t\n\t          if (previousSelectedItem) {\n\t            // Update selection state of old item.\n\t            this[_symbols2.default.itemSelected](previousSelectedItem, false);\n\t          }\n\t          if (item) {\n\t            // Update selection state to new item.\n\t            this[_symbols2.default.itemSelected](item, true);\n\t          }\n\t\n\t          updatePossibleNavigations(this);\n\t\n\t          if (this[_symbols2.default.raiseChangeEvents]) {\n\t            var event = new CustomEvent('selected-item-changed', {\n\t              detail: {\n\t                selectedItem: item,\n\t                value: item // for Polymer binding\n\t              }\n\t            });\n\t            this.dispatchEvent(event);\n\t          }\n\t        }\n\t\n\t        if (this[internalSelectedIndexSymbol] !== index) {\n\t          // Update selectedIndex property so it can have its own effects.\n\t          this.selectedIndex = index;\n\t        }\n\t      }\n\t    }, {\n\t      key: 'selectionRequired',\n\t      get: function get() {\n\t        return this[selectionRequiredSymbol];\n\t      },\n\t      set: function set(selectionRequired) {\n\t        var parsed = String(selectionRequired) === 'true';\n\t        var changed = parsed !== this[selectionRequiredSymbol];\n\t        this[selectionRequiredSymbol] = parsed;\n\t        if ('selectionRequired' in base.prototype) {\n\t          _set(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectionRequired', selectionRequired, this);\n\t        }\n\t        if (changed) {\n\t          if (this[_symbols2.default.raiseChangeEvents]) {\n\t            var event = new CustomEvent('selection-required-changed');\n\t            this.dispatchEvent(event);\n\t          }\n\t          if (selectionRequired) {\n\t            trackSelectedItem(this);\n\t          }\n\t        }\n\t      }\n\t\n\t      /**\n\t       * True if selection navigations wrap from last to first, and vice versa.\n\t       *\n\t       * @type {boolean}\n\t       * @default false\n\t       */\n\t\n\t    }, {\n\t      key: 'selectionWraps',\n\t      get: function get() {\n\t        return this[selectionWrapsSymbol];\n\t      },\n\t      set: function set(selectionWraps) {\n\t        var parsed = String(selectionWraps) === 'true';\n\t        var changed = parsed !== this[selectionWrapsSymbol];\n\t        this[selectionWrapsSymbol] = parsed;\n\t        if ('selectionWraps' in base.prototype) {\n\t          _set(SingleSelection.prototype.__proto__ || Object.getPrototypeOf(SingleSelection.prototype), 'selectionWraps', selectionWraps, this);\n\t        }\n\t        if (changed) {\n\t          if (this[_symbols2.default.raiseChangeEvents]) {\n\t            var event = new CustomEvent('selection-wraps-changed');\n\t            this.dispatchEvent(event);\n\t          }\n\t          updatePossibleNavigations(this);\n\t        }\n\t      }\n\t    }]);\n\t\n\t    return SingleSelection;\n\t  }(base);\n\t\n\t  return SingleSelection;\n\t}\n\t\n\t// Ensure the given index is within bounds, and select it if it's not already\n\t// selected.\n\tfunction selectIndex(element, index) {\n\t\n\t  var items = element.items;\n\t  if (items == null) {\n\t    // Nothing to select.\n\t    return false;\n\t  }\n\t\n\t  var count = items.length;\n\t  var boundedIndex = element.selectionWraps ?\n\t  // JavaScript mod doesn't handle negative numbers the way we want to wrap.\n\t  // See http://stackoverflow.com/a/18618250/76472\n\t  (index % count + count) % count :\n\t\n\t  // Keep index within bounds of array.\n\t  Math.max(Math.min(index, count - 1), 0);\n\t\n\t  var previousIndex = element.selectedIndex;\n\t  if (previousIndex !== boundedIndex) {\n\t    element.selectedIndex = boundedIndex;\n\t    return true;\n\t  } else {\n\t    return false;\n\t  }\n\t}\n\t\n\t// Following a change in the set of items, or in the value of the\n\t// `selectionRequired` property, reacquire the selected item. If it's moved,\n\t// update `selectedIndex`. If it's been removed, and a selection is required,\n\t// try to select another item.\n\tfunction trackSelectedItem(element) {\n\t\n\t  var items = element.items;\n\t  var itemCount = items ? items.length : 0;\n\t\n\t  var previousSelectedItem = element.selectedItem;\n\t  if (!previousSelectedItem) {\n\t    // No item was previously selected.\n\t    if (element.selectionRequired) {\n\t      // Select the first item by default.\n\t      element.selectedIndex = 0;\n\t    }\n\t  } else if (itemCount === 0) {\n\t    // We've lost the selection, and there's nothing left to select.\n\t    element.selectedItem = null;\n\t  } else {\n\t    // Try to find the previously-selected item in the current set of items.\n\t    var indexInCurrentItems = Array.prototype.indexOf.call(items, previousSelectedItem);\n\t    var previousSelectedIndex = element.selectedIndex;\n\t    if (indexInCurrentItems < 0) {\n\t      // Previously-selected item was removed from the items.\n\t      // Select the item at the same index (if it exists) or as close as possible.\n\t      var newSelectedIndex = Math.min(previousSelectedIndex, itemCount - 1);\n\t      // Select by item, since index may be the same, and we want to raise the\n\t      // selected-item-changed event.\n\t      element.selectedItem = items[newSelectedIndex];\n\t    } else if (indexInCurrentItems !== previousSelectedIndex) {\n\t      // Previously-selected item still there, but changed position.\n\t      element.selectedIndex = indexInCurrentItems;\n\t    }\n\t  }\n\t}\n\t\n\t// Following a change in selection, report whether it's now possible to\n\t// go next/previous from the given index.\n\tfunction updatePossibleNavigations(element) {\n\t  var canSelectNext = void 0;\n\t  var canSelectPrevious = void 0;\n\t  var items = element.items;\n\t  if (items == null || items.length === 0) {\n\t    // No items to select.\n\t    canSelectNext = false;\n\t    canSelectPrevious = false;\n\t  } else if (element.selectionWraps) {\n\t    // Since there are items, can always go next/previous.\n\t    canSelectNext = true;\n\t    canSelectPrevious = true;\n\t  } else {\n\t    var index = element.selectedIndex;\n\t    if (index < 0 && items.length > 0) {\n\t      // Special case. If there are items but no selection, declare that it's\n\t      // always possible to go next/previous to create a selection.\n\t      canSelectNext = true;\n\t      canSelectPrevious = true;\n\t    } else {\n\t      // Normal case: we have an index in a list that has items.\n\t      canSelectPrevious = index > 0;\n\t      canSelectNext = index < items.length - 1;\n\t    }\n\t  }\n\t  if (element.canSelectNext !== canSelectNext) {\n\t    element.canSelectNext = canSelectNext;\n\t  }\n\t  if (element.canSelectPrevious !== canSelectPrevious) {\n\t    element.canSelectPrevious = canSelectPrevious;\n\t  }\n\t}\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tvar _SingleSelectionMixin2 = __webpack_require__(19);\n\t\n\tvar _SingleSelectionMixin3 = _interopRequireDefault(_SingleSelectionMixin2);\n\t\n\tvar _symbols = __webpack_require__(5);\n\t\n\tvar _symbols2 = _interopRequireDefault(_symbols);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t/*\n\t * A very simple component to show the application of SingleSelectionMixin.\n\t *\n\t * For a more complete demo using SingleSelectionMixin, see the ListBox demo.\n\t */\n\tvar SingleSelectionDemo = function (_SingleSelectionMixin) {\n\t  _inherits(SingleSelectionDemo, _SingleSelectionMixin);\n\t\n\t  function SingleSelectionDemo() {\n\t    _classCallCheck(this, SingleSelectionDemo);\n\t\n\t    var _this = _possibleConstructorReturn(this, (SingleSelectionDemo.__proto__ || Object.getPrototypeOf(SingleSelectionDemo)).call(this));\n\t\n\t    _this.addEventListener('mousedown', function (event) {\n\t      _this[_symbols2.default.raiseChangeEvents] = true;\n\t      _this.selectedItem = event.target;\n\t      event.stopPropagation();\n\t      _this[_symbols2.default.raiseChangeEvents] = false;\n\t    });\n\t    return _this;\n\t  }\n\t\n\t  _createClass(SingleSelectionDemo, [{\n\t    key: 'attributeChangedCallback',\n\t    value: function attributeChangedCallback(attributeName, oldValue, newValue) {\n\t      if (_get(SingleSelectionDemo.prototype.__proto__ || Object.getPrototypeOf(SingleSelectionDemo.prototype), 'attributeChangedCallback', this)) {\n\t        _get(SingleSelectionDemo.prototype.__proto__ || Object.getPrototypeOf(SingleSelectionDemo.prototype), 'attributeChangedCallback', this).call(this, attributeName, oldValue, newValue);\n\t      }\n\t      if (attributeName === 'selected-index') {\n\t        this.selectedIndex = newValue;\n\t      }\n\t    }\n\t\n\t    // Map item selection to a `selected` CSS class.\n\t\n\t  }, {\n\t    key: _symbols2.default.itemSelected,\n\t    value: function value(item, selected) {\n\t      if (_get(SingleSelectionDemo.prototype.__proto__ || Object.getPrototypeOf(SingleSelectionDemo.prototype), _symbols2.default.itemSelected, this)) {\n\t        _get(SingleSelectionDemo.prototype.__proto__ || Object.getPrototypeOf(SingleSelectionDemo.prototype), _symbols2.default.itemSelected, this).call(this, item, selected);\n\t      }\n\t      item.classList.toggle('selected', selected);\n\t    }\n\t\n\t    // Simplistic implementation of items property doesn't handle redistribution.\n\t\n\t  }, {\n\t    key: 'items',\n\t    get: function get() {\n\t      return this.children;\n\t    }\n\t  }], [{\n\t    key: 'observedAttributes',\n\t    get: function get() {\n\t      return ['selected-index'];\n\t    }\n\t  }]);\n\t\n\t  return SingleSelectionDemo;\n\t}((0, _SingleSelectionMixin3.default)(HTMLElement));\n\t\n\texports.default = SingleSelectionDemo;\n\t\n\t\n\tcustomElements.define('single-selection-demo', SingleSelectionDemo);\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// demos.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 36937516cb41fc4ca729","/*\n * This is currently a demo of how multiple mixins cooperate to perform useful\n * functions.\n *\n * * The component uses ShadowTemplateMixin to populate its shadow root.\n * * A user can click on a child item, and ClickSelectionMixin will set the\n *   selected item.\n * * The SingleSelectionMixin will track the selected item, and map that to\n *   changes in the selection state of the selected/deselected items.\n * * The SelectionAriaMixin will reflect an item's selection state using ARIA\n *   attributes to support assistive devices like screen readers.\n *\n * This demo will eventually evolve into a complete list box component, but\n * at the moment omits many features, including support for Page Up/Page Down\n * keys, keeping the selected item in view, the ability to select an item\n * by typing its initial characters, and support for slot elements as children.\n */\n\n\nimport ChildrenContentMixin from '../../elix-mixins/src/ChildrenContentMixin';\nimport ClickSelectionMixin from '../../elix-mixins/src/ClickSelectionMixin';\nimport ContentItemsMixin from '../../elix-mixins/src/ContentItemsMixin';\nimport DirectionSelectionMixin from '../../elix-mixins/src/DirectionSelectionMixin';\nimport KeyboardDirectionMixin from '../../elix-mixins/src/KeyboardDirectionMixin';\nimport KeyboardMixin from '../../elix-mixins/src/KeyboardMixin';\nimport KeyboardPagedSelectionMixin from '../../elix-mixins/src/KeyboardPagedSelectionMixin';\nimport KeyboardPrefixSelectionMixin from '../../elix-mixins/src/KeyboardPrefixSelectionMixin';\nimport SelectionAriaMixin from '../../elix-mixins/src/SelectionAriaMixin';\nimport SelectionInViewMixin from '../../elix-mixins/src/SelectionInViewMixin';\nimport ShadowTemplateMixin from '../../elix-mixins/src/ShadowTemplateMixin';\nimport SingleSelectionMixin from '../../elix-mixins/src/SingleSelectionMixin';\nimport symbols from '../../elix-mixins/src/symbols';\n\n\n// We want to apply a number of mixin functions to HTMLElement.\nconst mixins = [\n  ChildrenContentMixin,\n  ClickSelectionMixin,\n  ContentItemsMixin,\n  DirectionSelectionMixin,\n  KeyboardDirectionMixin,\n  KeyboardMixin,\n  KeyboardPagedSelectionMixin,\n  KeyboardPrefixSelectionMixin,\n  SelectionAriaMixin,\n  SelectionInViewMixin,\n  ShadowTemplateMixin,\n  SingleSelectionMixin\n];\n\n// The mixins are functions, so an efficient way to apply them all is with\n// reduce. This is just function composition. We end up with a base class we\n// can extend below.\nconst base = mixins.reduce((cls, mixin) => mixin(cls), HTMLElement);\n\n\n/**\n * A simple single-selection list box.\n *\n * This uses the base class we just created above, and adds in the behavior\n * unique to this list box element. As it turns out, much of this behavior is\n * also interesting to other components, and will eventually get factored into\n * other mixins.\n *\n * @extends HTMLElement\n * @mixes ChildrenContentMixin\n * @mixes ClickSelectionMixin\n * @mixes ContentItemsMixin\n * @mixes DirectionSelectionMixin\n * @mixes KeyboardDirectionMixin\n * @mixes KeyboardMixin\n * @mixes KeyboardPagedSelectionMixin\n * @mixes KeyboardPrefixSelectionMixin\n * @mixes SelectionAriaMixin\n * @mixes SelectionInViewMixin\n * @mixes ShadowTemplateMixin\n * @mixes SingleSelectionMixin\n */\nclass ListBox extends base {\n\n  // Map attribute changes to the corresponding property.\n  attributeChangedCallback(attributeName, oldValue, newValue) {\n    if (super.attributeChangedCallback) { super.attributeChangedCallback(attributeName, oldValue, newValue); }\n    const mapAttributeToProperty = {\n      'selected-index': 'selectedIndex'\n    };\n    const propertyName = mapAttributeToProperty[attributeName] || attributeName;\n    this[propertyName] = newValue;\n  }\n\n  // We define a collection of default property values which can be set in\n  // the constructor or connectedCallback. Defining the actual default values\n  // in those calls would complicate things if a subclass someday wants to\n  // define its own default value.\n  get [symbols.defaults]() {\n    const defaults = super[symbols.defaults] || {};\n    // By default, we assume the list presents list items vertically.\n    defaults.orientation = 'vertical';\n    return defaults;\n  }\n\n  // Map item selection to a `selected` CSS class.\n  [symbols.itemSelected](item, selected) {\n    if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    item.classList.toggle('selected', selected);\n  }\n\n  // Tell the browser which attributes we want to handle.\n  static get observedAttributes() {\n    return ['orientation', 'selected-index'];\n  }\n\n  /**\n   * The vertical (default) or horizontal orientation of the list.\n   *\n   * Supported values are \"horizontal\" or \"vertical\".\n   *\n   * @type {string}\n   */\n  get orientation() {\n    return this[symbols.orientation] || this[symbols.defaults].orientation;\n  }\n  set orientation(value) {\n    const changed = value !== this[symbols.orientation];\n    this[symbols.orientation] = value;\n    if ('orientation' in base) { super.orientation = value; }\n    // Reflect attribute for styling\n    if (this.getAttribute('orientation') !== value) {\n      this.setAttribute('orientation', value);\n    }\n    if (changed && this[symbols.raiseChangeEvents]) {\n      const event = new CustomEvent('orientation-changed');\n      this.dispatchEvent(event);\n    }\n  }\n\n  // Define a template that will be stamped into the Shadow DOM by the\n  // ShadowTemplateMixin.\n  get [symbols.template]() {\n    return `\n      <style>\n      :host {\n        border: 1px solid gray;\n        box-sizing: border-box;\n        cursor: default;\n        display: flex;\n        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n      }\n\n      #itemsContainer {\n        flex: 1;\n        -webkit-overflow-scrolling: touch; /* for momentum scrolling */\n        overflow-x: hidden;\n        overflow-y: scroll;\n      }\n      :host([orientation=\"horizontal\"]) #itemsContainer {\n        display: flex;\n        overflow-x: scroll;\n        overflow-y: hidden;\n      }\n\n      #itemsContainer ::slotted(*) {\n        cursor: default;\n        padding: 0.25em;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        user-select: none;\n      }\n\n      #itemsContainer ::slotted(.selected) {\n        background: var(--elix-selected-background, highlight);\n        color: var(--elix-selected-color, highlighttext);\n      }\n      </style>\n\n      <div id=\"itemsContainer\" role=\"none\">\n        <slot></slot>\n      </div>\n    `;\n  }\n\n  /**\n   * Fires when the orientation property changes in response to internal\n   * component activity.\n   *\n   * @memberof ListBox\n   * @event orientation-changed\n   */\n}\n\n\ncustomElements.define('sample-list-box', ListBox);\nexport default ListBox;\n\n\n\n// WEBPACK FOOTER //\n// ./elements/demos/src/ListBox.js","import { assignedChildren } from './content';\nimport microtask from './microtask';\nimport symbols from './symbols';\n\n\n/**\n * Mixin which defines a component's `symbols.content` property as all\n * child elements, including elements distributed to the component's slots.\n *\n * This also provides notification of changes to a component's content. It\n * will invoke a `symbols.contentChanged` method when the component is first\n * instantiated, and whenever its distributed children change. This is intended\n * to satisfy the Gold Standard checklist item for monitoring\n * [Content Changes](https://github.com/webcomponents/gold-standard/wiki/Content-Changes).\n *\n * Example:\n *\n * ```\n * let base = ChildrenContentMixin(DistributedChildrenMixin(HTMLElement));\n * class CountingElement extends base {\n *\n *   constructor() {\n *     super();\n *     let root = this.attachShadow({ mode: 'open' });\n *     root.innerHTML = `<slot></slot>`;\n *     this[symbols.shadowCreated]();\n *   }\n *\n *   [symbols.contentChanged]() {\n *     if (super[symbols.contentChanged]) { super[symbols.contentChanged](); }\n *     // Count the component's children, both initially and when changed.\n *     this.count = this.distributedChildren.length;\n *   }\n *\n * }\n * ```\n *\n * Note that content change detection depends upon the element having at least\n * one `slot` element in its shadow subtree.\n *\n * This mixin is intended for use with the\n * [DistributedChildrenMixin](DistributedChildrenMixin.md). See that mixin for\n * a discussion of how that works. This ChildrenContentMixin\n * provides an easy way of defining the \"content\" of a component as the\n * component's distributed children. That in turn lets mixins like\n * [ContentItemsMixin](ContentItemsMixin.md) manipulate the children as list\n * items.\n *\n * To receive `contentChanged` notification, this mixin expects a component to\n * invoke a method called `symbols.shadowCreated` after the component's shadow\n * root has been created and populated.\n *\n * Note: This mixin relies upon the browser firing `slotchange` events when the\n * contents of a `slot` change. Safari and the polyfills fire this event when a\n * custom element is first upgraded, while Chrome does not. This mixin always\n * invokes the `contentChanged` method after component instantiation so that the\n * method will always be invoked at least once. However, on Safari (and possibly\n * other browsers), `contentChanged` might be invoked _twice_ for a new\n * component instance.\n *\n * @module ChildrenContentMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function ChildrenContentMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class ChildrenContent extends base {\n\n    constructor() {\n      super();\n\n      // Make an initial call to contentChanged() so that the component can do\n      // initialization that it normally does when content changes.\n      //\n      // This will invoke contentChanged() handlers in other mixins. In order\n      // that those mixins have a chance to complete their own initialization,\n      // we add the contentChanged() call to the microtask queue.\n      microtask(() => {\n        if (this[symbols.contentChanged]) {\n          this[symbols.contentChanged]();\n        }\n      });\n    }\n\n    /**\n     * The content of this component, defined to be the flattened array of\n     * children distributed to the component.\n     *\n     * The default implementation of this property only returns instances of\n     * Element\n     *\n     * @type {HTMLElement[]}\n     */\n    get [symbols.content]() {\n      return assignedChildren(this);\n    }\n\n    [symbols.shadowCreated]() {\n      if (super[symbols.shadowCreated]) { super[symbols.shadowCreated](); }\n      // Listen to changes on all slots.\n      const slots = this.shadowRoot.querySelectorAll('slot');\n      slots.forEach(slot => slot.addEventListener('slotchange', event => {\n        if (this[symbols.contentChanged]) {\n          this[symbols.contentChanged]();\n        }\n      }));\n    }\n  }\n\n  return ChildrenContent;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/ChildrenContentMixin.js","/**\n * Helpers for accessing a component's content.\n *\n * The standard DOM API provides several ways of accessing child content:\n * `children`, `childNodes`, and `textContent`. None of these functions are\n * Shadow DOM aware. This mixin defines variations of those functions that\n * *are* Shadow DOM aware.\n *\n * Example: you create a component `<count-children>` that displays a number\n * equal to the number of children placed inside that component. If someone\n * instantiates your component like:\n *\n *     <count-children>\n *       <div></div>\n *       <div></div>\n *       <div></div>\n *     </count-children>\n *\n * Then the component should show \"3\", because there are three children. To\n * calculate the number of children, the component can just calculate\n * `this.children.length`. However, suppose someone instantiates your\n * component inside one of their own components, and puts a `<slot>` element\n * inside your component:\n *\n *     <count-children>\n *       <slot></slot>\n *     </count-children>\n *\n * If your component only looks at `this.children`, it will always see exactly\n * one child the `<slot>` element. But the user looking at the page will\n * *see* any nodes distributed to that slot. To match what the user sees, your\n * component should expand any `<slot>` elements it contains.\n *\n * That is one problem these helpers solve. For example, the helper\n * `assignedChildren` will return all children assigned to your component in\n * the composed tree.\n *\n * @module content\n */\n\n/**\n * An in-order collection of distributed children, expanding any slot\n * elements. Like the standard `children` property, this skips text and other\n * node types which are not Element instances.\n *\n * @param {HTMLElement} element - the element to inspect\n * @returns {Element[]} - the children assigned to the element\n */\nexport function assignedChildren(element) {\n  return expandAssignedNodes(element.children, true);\n}\n\n/**\n * An in-order collection of distributed child nodes, expanding any slot\n * elements. Like the standard `childNodes` property, this includes text and\n * other types of nodes.\n *\n * @param {HTMLElement} element - the element to inspect\n * @returns {Node[]} - the nodes assigned to the element\n */\nexport function assignedChildNodes(element) {\n  return expandAssignedNodes(element.childNodes, false);\n}\n\n/**\n * The concatenated `textContent` of all distributed child nodes, expanding\n * any slot elements.\n *\n * @param {HTMLElement} element - the element to inspect\n * @type {string} - the text content of all nodes assigned to the element\n */\nexport function assignedTextContent(element) {\n  const strings = assignedChildNodes(element).map(\n    child => child.textContent\n  );\n  return strings.join('');\n}\n\n/**\n * Return the given elements, filtering out auxiliary elements that aren't\n * typically visible. Given a `NodeList` or array of objects, it will only\n * return array members that are instances of `Element` (`HTMLElement` or\n * `SVGElement`), and not on a blacklist of normally invisible elements\n * (such as `style` or `script`).\n *\n * @param {NodeList|Element[]} elements - the list of elements to filter\n * @returns {Element[]} - the filtered elements\n */\nexport function filterAuxiliaryElements(elements) {\n\n  // These are tags that can appear in the document body, but do not seem to\n  // have any user-visible manifestation.\n  // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element\n  const auxiliaryTags = [\n    'applet',         // deprecated\n    'basefont',       // deprecated\n    'embed',\n    'font',           // deprecated\n    'frame',          // deprecated\n    'frameset',       // deprecated\n    'isindex',        // deprecated\n    'keygen',         // deprecated\n    'link',\n    'multicol',       // deprecated\n    'nextid',         // deprecated\n    'noscript',\n    'object',\n    'param',\n    'script',\n    'style',\n    'template',\n    'noembed'         // deprecated\n  ];\n\n  return [].filter.call(elements,\n    element => element instanceof Element &&\n        (!element.localName || auxiliaryTags.indexOf(element.localName) < 0)\n  );\n}\n\n//\n// Helpers for the helper functions\n//\n\n/*\n * Given a array of nodes, return a new array with any `slot` elements expanded\n * to the nodes assigned to those slots.\n *\n * If ElementsOnly is true, only Element instances are returned, as with the\n * standard `children` property. Otherwise, all nodes are returned, as in the\n * standard `childNodes` property.\n */\nfunction expandAssignedNodes(nodes, ElementsOnly) {\n  const expanded = Array.prototype.map.call(nodes, node => {\n\n    // We want to see if the node is an instanceof HTMLSlotELement, but\n    // that class won't exist if the browser that doesn't support native\n    // Shadow DOM and if the Shadow DOM polyfill hasn't been loaded. Instead,\n    // we do a simplistic check to see if the tag name is \"slot\".\n    const isSlot = typeof HTMLSlotElement !== 'undefined' ?\n      node instanceof HTMLSlotElement :\n      node.localName === 'slot';\n\n    return isSlot ?\n      node.assignedNodes({ flatten: true }) :\n      [node];\n  });\n  const flattened = [].concat(...expanded);\n  const result = ElementsOnly ?\n    flattened.filter(node => node instanceof Element) :\n    flattened;\n  return result;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/content.js","/*\n * Microtask helper for IE 11.\n *\n * Executing a function as a microtask is trivial in browsers that support\n * promises, whose then() clauses use microtask timing. IE 11 doesn't support\n * promises, but does support MutationObservers, which are also executed as\n * microtasks. So this helper uses an MutationObserver to achieve microtask\n * timing.\n *\n * See https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n *\n * Inspired by Polymer's async() function.\n */\n\n\n// The queue of pending callbacks to be executed as microtasks.\nconst callbacks = [];\n\n// Create an element that we will modify to force observable mutations.\nconst element = document.createTextNode('');\n\n// A monotonically-increasing value.\nlet counter = 0;\n\n\n/**\n * Add a callback to the microtask queue.\n *\n * This uses a MutationObserver so that it works on IE 11.\n *\n * NOTE: IE 11 may actually use timeout timing with MutationObservers. This\n * needs more investigation.\n *\n * @function microtask\n * @param {function} callback\n */\nexport default function microtask(callback) {\n  callbacks.push(callback);\n  // Force a mutation.\n  element.textContent = ++counter;\n}\n\n\n// Execute any pending callbacks.\nfunction executeCallbacks() {\n  while (callbacks.length > 0) {\n    const callback = callbacks.shift();\n    callback();\n  }\n}\n\n\n// Create the observer.\nconst observer = new MutationObserver(executeCallbacks);\nobserver.observe(element, {\n  characterData: true\n});\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/microtask.js","import Symbol from './Symbol';\n\n\n/**\n * A collection of (potentially polyfilled) Symbol objects for standard\n * component properties and methods.\n *\n * These Symbol objects are used to allow mixins and a component to internally\n * communicate, without exposing these properties and methods in the component's\n * public API.\n *\n * To use these Symbol objects in your own component, include this module and\n * then create a property or method whose key is the desired Symbol.\n *\n *     import 'SingleSelectionMixin' from 'elix-mixins/src/SingleSelectionMixin';\n *     import 'symbols' from 'elix-mixins/src/symbols';\n *\n *     class MyElement extends SingleSelectionMixin(HTMLElement) {\n *       [symbols.itemSelected](item, selected) {\n *         // This will be invoked whenever an item is selected/deselected.\n *       }\n *     }\n *\n * @module symbols\n */\nconst symbols = {\n\n  /**\n   * Symbols for the `content` property.\n   *\n   * This property returns the component's content -- however the component\n   * wants to define that. This could, for example, return the component's\n   * distributed children.\n   *\n   * @type {HTMLElement[]}\n   */\n  content: Symbol('content'),\n\n  /**\n   * Symbol for the `contentChanged` method.\n   *\n   * For components that define a `content` property, this method should be\n   * invoked when that property changes.\n   *\n   * @function contentChanged\n   */\n  contentChanged: Symbol('contentChanged'),\n\n  /**\n   * Symbol for the `defaults` property.\n   *\n   * This property can be used to set or override defaults that will be applied\n   * to a new component instance. When implementing this property, take care to\n   * first acquire any defaults defined by the superclass. The standard idiom is\n   * as follows:\n   *\n   *     get [symbols.defaults]() {\n   *       const defaults = super[symbols.defaults] || {};\n   *       // Set or override default values here\n   *       defaults.customProperty = false;\n   *       return defaults;\n   *     }\n   *\n   * @var {object} defaults\n   */\n  defaults: Symbol('defaults'),\n\n  /**\n   * Symbol for the `getItemText` method.\n   *\n   * This method can be applied to an item to return its text.\n   *\n   * @function getText\n   * @param {HTMLElement} item - the item to extract text from\n   * @returns {string} - the text of the item\n   */\n  getItemText: Symbol('getText'),\n\n  /**\n   * Symbol for the `goDown` method.\n   *\n   * This method is invoked when the user wants to go/navigate down.\n   *\n   * @function goDown\n   */\n  goDown: Symbol('goDown'),\n\n  /**\n   * Symbol for the `goEnd` method.\n   *\n   * This method is invoked when the user wants to go/navigate to the end (e.g.,\n   * of a list).\n   *\n   * @function goEnd\n   */\n  goEnd: Symbol('goEnd'),\n\n  /**\n   * Symbol for the `goLeft` method.\n   *\n   * This method is invoked when the user wants to go/navigate left.\n   *\n   * @function goLeft\n   */\n  goLeft: Symbol('goLeft'),\n\n  /**\n   * Symbol for the `goRight` method.\n   *\n   * This method is invoked when the user wants to go/navigate right.\n   *\n   * @function goRight\n   */\n  goRight: Symbol('goRight'),\n\n  /**\n   * Symbol for the `goStart` method.\n   *\n   * This method is invoked when the user wants to go/navigate to the start\n   * (e.g., of a list).\n   *\n   * @function goStart\n   */\n  goStart: Symbol('goStart'),\n\n  /**\n   * Symbol for the `goUp` method.\n   *\n   * This method is invoked when the user wants to go/navigate up.\n   *\n   * @function goUp\n   */\n  goUp: Symbol('goUp'),\n\n  /**\n   * Symbol for the `itemAdded` method.\n   *\n   * This method is invoked when a new item is added to a list.\n   *\n   * @function itemAdded\n   * @param {HTMLElement} item - the item being selected/deselected\n   */\n  itemAdded: Symbol('itemAdded'),\n\n  /**\n   * Symbol for the `itemsChanged` method.\n   *\n   * This method is invoked when the underlying contents change. It is also\n   * invoked on component initialization  since the items have \"changed\" from\n   * being nothing.\n   *\n   * @function itemsChanged\n   */\n  itemsChanged: Symbol('itemsChanged'),\n\n  /**\n   * Symbol for the `itemSelected` method.\n   *\n   * This method is invoked when an item becomes selected or deselected.\n   *\n   * @function itemSelected\n   * @param {HTMLElement} item - the item being selected/deselected\n   * @param {boolean} selected - true if the item is selected, false if not\n   */\n  itemSelected: Symbol('itemSelected'),\n\n  /**\n   * Symbol for the `keydown` method.\n   *\n   * This method is invoked when an element receives a `keydown` event.\n   *\n   * @function keydown\n   * @param {KeyboardEvent} event - the event being processed\n   */\n  keydown: Symbol('keydown'),\n\n  /**\n   * Indicates the general horizontal and/or vertical orientation of the\n   * component. This may affect both presentation and behavior (e.g., of\n   * keyboard navigation).\n   *\n   * Accepted values are \"horizontal\", \"vertical\", or \"both\" (the default).\n   *\n   * @type {string}\n   */\n  orientation: Symbol('orientation'),\n\n  /**\n   * Symbol for the `raiseChangeEvents` property.\n   *\n   * This property is used by mixins to determine whether they should raise\n   * property change events. The standard HTML pattern is to only raise such\n   * events in response to direct user interactions. For a detailed discussion\n   * of this point, see the Gold Standard checklist item for\n   * [Propery Change Events](https://github.com/webcomponents/gold-standard/wiki/Property%20Change%20Events).\n   *\n   * The above article describes a pattern for using a flag to track whether\n   * work is being performed in response to internal component activity, and\n   * whether the component should therefore raise property change events.\n   * This `raiseChangeEvents` symbol is a shared flag used for that purpose by\n   * all Elix mixins and components. Sharing this flag ensures that internal\n   * activity (e.g., a UI event listener) in one mixin can signal other mixins\n   * handling affected properties to raise change events.\n   *\n   * All UI event listeners (and other forms of internal handlers, such as\n   * timeouts and async network handlers) should set `raiseChangeEvents` to\n   * `true` at the start of the event handler, then `false` at the end:\n   *\n   *     this.addEventListener('click', event => {\n   *       this[symbols.raiseChangeEvents] = true;\n   *       // Do work here, possibly setting properties, like:\n   *       this.foo = 'Hello';\n   *       this[symbols.raiseChangeEvents] = false;\n   *     });\n   *\n   * Elsewhere, property setters that raise change events should only do so it\n   * this property is `true`:\n   *\n   *     set foo(value) {\n   *       // Save foo value here, do any other work.\n   *       if (this[symbols.raiseChangeEvents]) {\n   *         const event = new CustomEvent('foo-changed');\n   *         this.dispatchEvent(event);\n   *       }\n   *     }\n   *\n   * In this way, programmatic attempts to set the `foo` property will not\n   * trigger the `foo-changed` event, but UI interactions that update that\n   * property will cause those events to be raised.\n   *\n   * @var {boolean} raiseChangeEvents\n   */\n  raiseChangeEvents: Symbol('raiseChangeEvents'),\n\n  /**\n   * Symbol for the `shadowCreated` method.\n   *\n   * This method is invoked when the component's shadow root has been attached\n   * and populated. Other code can handle this method to perform initialization\n   * that depends upon the existence of a populated shadow subtree.\n   *\n   * @function shadowCreated\n   */\n  shadowCreated: Symbol('shadowCreated'),\n\n  /**\n   * Symbol for the `template` property.\n   *\n   * This property returns a component's template.\n   *\n   * @type {string|HTMLTemplateElement}\n   */\n  template: Symbol('template')\n};\n\nexport default symbols;\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/symbols.js","/* The number of fake symbols we've served up */\nlet count = 0;\n\nfunction uniqueString(description) {\n  return `_${description}${count++}`;\n}\n\nconst symbolFunction = typeof window.Symbol === 'function' ?\n  window.Symbol :\n  uniqueString;\n\n/**\n * Polyfill for ES6 symbol class.\n *\n * Mixins and component classes often want to associate private data with an\n * element instance, but JavaScript does not have direct support for true\n * private properties. One approach is to use the\n * [Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)\n * data type to set and retrieve data on an element.\n *\n * Unfortunately, the Symbol type is not available in Internet Explorer 11. In\n * lieu of returning a true Symbol, this polyfill returns a different string\n * each time it is called.\n *\n * Usage:\n *\n *     const fooSymbol = Symbol('foo');\n *\n *     class MyElement extends HTMLElement {\n *       get foo() {\n *         return this[fooSymbol];\n *       }\n *       set foo(value) {\n *         this[fooSymbol] = value;\n *       }\n *     }\n *\n * In IE 11, this sample will \"hide\" data behind an instance property that looks\n * like this._foo0. The underscore is meant to reduce (not eliminate) potential\n * accidental access, and the unique number at the end is mean to avoid (not\n * eliminate) naming conflicts.\n *\n * @function Symbol\n * @param {string} description - A string to identify the symbol when debugging\n * @returns {Symbol|string}  A Symbol (in ES6 browsers) or unique string ID (in\n * ES5).\n */\nexport default symbolFunction;\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/Symbol.js","import symbols from './symbols';\n\n\n/**\n * Mixin which maps a click (actually, a mousedown) to a selection.\n *\n * This simple mixin is useful in list box-like elements, where a click on a\n * list item implicitly selects it.\n *\n * The standard use for this mixin is in list-like elements. Native list\n * boxes don't appear to be consistent with regard to whether they select\n * on mousedown or click/mouseup. This mixin assumes the use of mousedown.\n * On touch devices, that event appears to trigger when the touch is *released*.\n *\n * This mixin only listens to mousedown events for the primary mouse button\n * (typically the left button). Right-clicks are ignored so that the browser\n * may display a context menu.\n *\n * Much has been written about how to ensure \"fast tap\" behavior on mobile\n * devices. This mixin makes a very straightforward use of a standard event, and\n * this appears to perform well on mobile devices when, e.g., the viewport is\n * configured with `width=device-width`.\n *\n * This mixin expects the component to provide an `items` property. It also\n * expects the component to define a `selectedItem` property; you can provide\n * that yourself, or use [SingleSelectionMixin](SingleSelectionMixin.md).\n *\n * If the component receives a clicks that doesn't correspond to an item (e.g.,\n * the user clicks on the element background visible between items), the\n * selection will be removed. However, if the component defines a\n * `selectionRequired` and this is true, a background click will *not* remove\n * the selection.\n *\n * @module ClickSelectionMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function ClickSelectionMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class ClickSelection extends base {\n\n    constructor() {\n      super();\n      this.addEventListener('mousedown', event => {\n\n        // Only process events for the main (usually left) button.\n        if (event.button !== 0) {\n          return;\n        }\n\n        this[symbols.raiseChangeEvents] = true;\n\n        // If the item clicked on is a button, the event seems to be raised in\n        // phase 2 (AT_TARGET)  but the event target will be the component, not\n        // the item that was clicked on.\n        const target = event.target === this ?\n          event.path[0] : // Event target isn't the item, so get it from path.\n          event.target;\n\n        // Find which item was clicked on and, if found, select it. For elements\n        // which don't require a selection, a background click will determine\n        // the item was null, in which we case we'll remove the selection.\n        const item = itemForTarget(this, target);\n        if (item || !this.selectionRequired) {\n\n          if (!('selectedItem' in this)) {\n            console.warn(`ClickSelectionMixin expects a component to define a \"selectedItem\" property.`);\n          } else {\n            this.selectedItem = item;\n          }\n\n          // We don't call preventDefault here. The default behavior for\n          // mousedown includes setting keyboard focus if the element doesn't\n          // already have the focus, and we want to preserve that behavior.\n          event.stopPropagation();\n        }\n\n        this[symbols.raiseChangeEvents] = false;\n      });\n    }\n\n  }\n\n  return ClickSelection;\n}\n\n\n/*\n * Return the list item that is, or contains, the indicated target element.\n * Return null if not found.\n */\nfunction itemForTarget(listElement, target) {\n  const items = listElement.items;\n  const itemCount = items ? items.length : 0;\n  for (let i = 0; i < itemCount; i++) {\n    let item = items[i];\n    if (item === target || item.contains(target)) {\n      return item;\n    }\n  }\n  return null;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/ClickSelectionMixin.js","import * as content from './content';\nimport Symbol from './Symbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst itemsSymbol = Symbol('items');\nconst itemInitializedSymbol = Symbol('itemInitialized');\n\n\n/**\n * Mixin which maps content semantics (elements) to list item semantics.\n *\n * Items differ from element contents in several ways:\n *\n * * They are often referenced via index.\n * * They may have a selection state.\n * * It's common to do work to initialize the appearance or state of a new\n *   item.\n * * Auxiliary invisible child elements are filtered out and not counted as\n *   items. Auxiliary elements include link, script, style, and template\n *   elements. This filtering ensures that those auxiliary elements can be\n *   used in markup inside of a list without being treated as list items.\n *\n * This mixin expects a component to provide a `content` property returning a\n * raw set of elements. You can provide that yourself, or use\n * [ChildrenContentMixin](ChildrenContentMixin.md).\n *\n * The most commonly referenced property defined by this mixin is the `items`\n * property. To avoid having to do work each time that property is requested,\n * this mixin supports an optimized mode. If you invoke the `contentChanged`\n * method when the set of items changes, the mixin concludes that you'll take\n * care of notifying it of future changes, and turns on the optimization. With\n * that on, the mixin saves a reference to the computed set of items, and will\n * return that immediately on subsequent calls to the `items` property. If you\n * use this mixin in conjunction with `ChildrenContentMixin`, the\n * `contentChanged` method will be invoked for you when the element's children\n * change, turning on the optimization automatically.\n *\n * @module ContentItemsMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function ContentItemsMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class ContentItems extends base {\n\n    [symbols.contentChanged]() {\n      if (super[symbols.contentChanged]) { super[symbols.contentChanged](); }\n\n      // Since we got the contentChanged call, we'll assume we'll be notified if\n      // the set of items changes later. We turn on memoization of the items\n      // property by setting our internal property to null (instead of\n      // undefined).\n      this[itemsSymbol] = null;\n\n      this[symbols.itemsChanged]();\n    }\n\n    /**\n     * The current set of items in the list. See the top-level documentation for\n     * mixin for a description of how items differ from plain content.\n     *\n     * @type {HTMLElement[]}\n     */\n    get items() {\n      let items;\n      if (this[itemsSymbol] == null) {\n        items = content.filterAuxiliaryElements(this[symbols.content]);\n        // Note: test for *equality* with null, since we use `undefined` to\n        // indicate that we're not yet caching items.\n        if (this[itemsSymbol] === null) {\n          // Memoize the set of items.\n          this[itemsSymbol] = items;\n        }\n      } else {\n        // Return the memoized items.\n        items = this[itemsSymbol];\n      }\n      return items;\n    }\n\n    /**\n     * This method is invoked when the underlying contents change. It is also\n     * invoked on component initialization  since the items have \"changed\" from\n     * being nothing.\n     */\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      // Perform per-item initialization if `itemAdded` is defined.\n      if (this[symbols.itemAdded]) {\n        Array.prototype.forEach.call(this.items, item => {\n          if (!item[itemInitializedSymbol]) {\n            this[symbols.itemAdded](item);\n            item[itemInitializedSymbol] = true;\n          }\n        });\n      }\n\n      if (this[symbols.raiseChangeEvents]) {\n        this.dispatchEvent(new CustomEvent('items-changed'));\n      }\n    }\n\n    /**\n     * Fires when the items in the list change.\n     *\n     * @memberof ContentItems\n     * @event items-changed\n     */\n  }\n\n  return ContentItems;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/ContentItemsMixin.js","import symbols from './symbols';\n\n\n/**\n * Mixin which maps direction semantics (goLeft, goRight, etc.) to selection\n * semantics (selectPrevious, selectNext, etc.).\n *\n * This mixin can be used in conjunction with\n * [KeyboardDirectionMixin](KeyboardDirectionMixin.md) (which maps keyboard\n * events to directions) and a mixin that handles selection like\n * [SingleSelectionMixin](SingleSelectionMixin.md).\n *\n * @module DirectionSelectionMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function DirectionSelectionMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class DirectionSelection extends base {\n\n    [symbols.goDown]() {\n      if (super[symbols.goDown]) { super[symbols.goDown](); }\n      if (!this.selectNext) {\n        console.warn(`DirectionSelectionMixin expects a component to define a \"selectNext\" method.`);\n      } else {\n        return this.selectNext();\n      }\n    }\n\n    [symbols.goEnd]() {\n      if (super[symbols.goEnd]) { super[symbols.goEnd](); }\n      if (!this.selectLast) {\n        console.warn(`DirectionSelectionMixin expects a component to define a \"selectLast\" method.`);\n      } else {\n        return this.selectLast();\n      }\n    }\n\n    [symbols.goLeft]() {\n      if (super[symbols.goLeft]) { super[symbols.goLeft](); }\n      if (!this.selectPrevious) {\n        console.warn(`DirectionSelectionMixin expects a component to define a \"selectPrevious\" method.`);\n      } else {\n        return this.selectPrevious();\n      }\n    }\n\n    [symbols.goRight]() {\n      if (super[symbols.goRight]) { super[symbols.goRight](); }\n      if (!this.selectNext) {\n        console.warn(`DirectionSelectionMixin expects a component to define a \"selectNext\" method.`);\n      } else {\n        return this.selectNext();\n      }\n    }\n\n    [symbols.goStart]() {\n      if (super[symbols.goStart]) { super[symbols.goStart](); }\n      if (!this.selectFirst) {\n        console.warn(`DirectionSelectionMixin expects a component to define a \"selectFirst\" method.`);\n      } else {\n        return this.selectFirst();\n      }\n    }\n\n    [symbols.goUp]() {\n      if (super[symbols.goUp]) { super[symbols.goUp](); }\n      if (!this.selectPrevious) {\n        console.warn(`DirectionSelectionMixin expects a component to define a \"selectPrevious\" method.`);\n      } else {\n        return this.selectPrevious();\n      }\n    }\n\n  }\n\n  return DirectionSelection;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/DirectionSelectionMixin.js","import symbols from './symbols';\n\n\n/**\n * Mixin which maps direction keys (Left, Right, etc.) to direction semantics\n * (go left, go right, etc.).\n *\n * This mixin expects the component to invoke a `keydown` method when a key is\n * pressed. You can use [KeyboardMixin](KeyboardMixin.md) for that\n * purpose, or wire up your own keyboard handling and call `keydown` yourself.\n *\n * This mixin calls methods such as `goLeft` and `goRight`. You can define\n * what that means by implementing those methods yourself. If you want to use\n * direction keys to navigate a selection, use this mixin with\n * [DirectionSelectionMixin](DirectionSelectionMixin.md).\n *\n * If the component defines a property called `symbols.orientation`, the value\n * of that property will constrain navigation to the horizontal or vertical axis.\n *\n * @module KeyboardDirectionMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function KeyboardDirectionMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class KeyboardDirection extends base {\n\n    /**\n     * Invoked when the user wants to go/navigate down.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goDown]() {\n      if (super[symbols.goDown]) { return super[symbols.goDown](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate to the end (e.g., of a list).\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goEnd]() {\n      if (super[symbols.goEnd]) { return super[symbols.goEnd](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate left.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goLeft]() {\n      if (super[symbols.goLeft]) { return super[symbols.goLeft](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate right.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goRight]() {\n      if (super[symbols.goRight]) { return super[symbols.goRight](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate to the start (e.g., of a\n     * list). The default implementation of this method does nothing.\n     */\n    [symbols.goStart]() {\n      if (super[symbols.goStart]) { return super[symbols.goStart](); }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate up.\n     * The default implementation of this method does nothing.\n     */\n    [symbols.goUp]() {\n      if (super[symbols.goUp]) { return super[symbols.goUp](); }\n    }\n\n    [symbols.keydown](event) {\n      let handled = false;\n\n      const orientation = this[symbols.orientation] || 'both';\n      const horizontal = (orientation === 'horizontal' || orientation === 'both');\n      const vertical = (orientation === 'vertical' || orientation === 'both');\n\n      // Ignore Left/Right keys when metaKey or altKey modifier is also pressed,\n      // as the user may be trying to navigate back or forward in the browser.\n      switch (event.keyCode) {\n        case 35: // End\n          handled = this[symbols.goEnd]();\n          break;\n        case 36: // Home\n          handled = this[symbols.goStart]();\n          break;\n        case 37: // Left\n          if (horizontal && !event.metaKey && !event.altKey) {\n            handled = this[symbols.goLeft]();\n          }\n          break;\n        case 38: // Up\n          if (vertical) {\n            handled = event.altKey ? this[symbols.goStart]() : this[symbols.goUp]();\n          }\n          break;\n        case 39: // Right\n          if (horizontal && !event.metaKey && !event.altKey) {\n            handled = this[symbols.goRight]();\n          }\n          break;\n        case 40: // Down\n          if (vertical) {\n            handled = event.altKey ? this[symbols.goEnd]() : this[symbols.goDown]();\n          }\n          break;\n      }\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super[symbols.keydown] && super[symbols.keydown](event)) || false;\n    }\n\n  }\n\n  return KeyboardDirection;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/KeyboardDirectionMixin.js","import symbols from './symbols';\n\n\n/**\n * Mixin which manages the keydown handling for a component.\n *\n * This mixin handles several keyboard-related features.\n *\n * First, it wires up a single keydown event handler that can be shared by\n * multiple mixins on a component. The event handler will invoke a `keydown`\n * method with the event object, and any mixin along the prototype chain that\n * wants to handle that method can do so.\n *\n * If a mixin wants to indicate that keyboard event has been handled, and that\n * other mixins should *not* handle it, the mixin's `keydown` handler should\n * return a value of true. The convention that seems to work well is that a\n * mixin should see if it wants to handle the event and, if not, then ask the\n * superclass to see if it wants to handle the event. This has the effect of\n * giving the mixin that was applied last the first chance at handling a\n * keyboard event.\n *\n * Example:\n *\n *     [symbols.keydown](event) {\n *       let handled;\n *       switch (event.keyCode) {\n *         // Handle the keys you want, setting handled = true if appropriate.\n *       }\n *       // Prefer mixin result if it's defined, otherwise use base result.\n *       return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n *     }\n *\n * Until iOS Safari supports the `KeyboardEvent.key` property\n * (see http://caniuse.com/#search=keyboardevent.key), mixins should generally\n * test keys using the legacy `keyCode` property, not `key`.\n *\n * A second feature provided by this mixin is that it implicitly makes the\n * component a tab stop if it isn't already, by setting `tabIndex` to 0. This\n * has the effect of adding the component to the tab order in document order.\n *\n * @module KeyboardMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function KeyboardMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class Keyboard extends base {\n\n    constructor() {\n      super();\n      this.addEventListener('keydown', event => {\n        this[symbols.raiseChangeEvents] = true;\n        const handled = this[symbols.keydown](event);\n        if (handled) {\n          event.preventDefault();\n          event.stopPropagation();\n        }\n        this[symbols.raiseChangeEvents] = false;\n      });\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      if (this.getAttribute('tabindex') == null && this[symbols.defaults].tabindex !== null) {\n        this.setAttribute('tabindex', this[symbols.defaults].tabindex);\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      // The default tab index is 0 (document order).\n      defaults.tabindex = 0;\n      return defaults;\n    }\n\n    /**\n     * Handle the indicated keyboard event.\n     *\n     * The default implementation of this method does nothing. This will\n     * typically be handled by other mixins.\n     *\n     * @param {KeyboardEvent} event - the keyboard event\n     * @return {boolean} true if the event was handled\n     */\n    [symbols.keydown](event) {\n      if (super[symbols.keydown]) { return super[symbols.keydown](event); }\n    }\n\n  }\n\n  return Keyboard;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/KeyboardMixin.js","import defaultScrollTarget from './defaultScrollTarget';\nimport symbols from './symbols';\n\n\n/**\n * Mixin which maps page keys (Page Up, Page Down) into operations that move\n * the selection by one page.\n *\n * The keyboard interaction model generally follows that of Microsoft Windows'\n * list boxes instead of those in OS X:\n *\n * * The Page Up/Down and Home/End keys actually change the selection, rather\n *   than just scrolling. The former behavior seems more generally useful for\n *   keyboard users.\n *\n * * Pressing Page Up/Down will change the selection to the topmost/bottommost\n *   visible item if the selection is not already there. Thereafter, the key\n *   will move the selection up/down by a page, and (per the above point) make\n *   the selected item visible.\n *\n * To ensure the selected item is in view following use of Page Up/Down, use\n * the related [SelectionInViewMixin](SelectionInViewMixin.md).\n *\n * This mixin expects the component to provide:\n *\n * * A `[symbols.keydown]` method invoked when a key is pressed. You can use\n *   [KeyboardMixin](KeyboardMixin.md) for that purpose, or wire up your own\n *   keyboard handling and call `[symbols.keydown]` yourself.\n * * A `selectedIndex` property that indicates the index of the selected item.\n *\n * @module KeyboardPagedSelectionMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function KeyboardPagedSelectionMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class KeyboardPagedSelection extends base {\n\n    [symbols.keydown](event) {\n      let handled = false;\n      const orientation = this[symbols.orientation];\n      if (orientation !== 'horizontal') {\n        switch (event.keyCode) {\n          case 33: // Page Up\n          handled = this.pageUp();\n          break;\n          case 34: // Page Down\n          handled = this.pageDown();\n          break;\n        }\n      }\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n    }\n\n    /**\n     * Scroll down one page.\n     */\n    pageDown() {\n      if (super.pageDown) { super.pageDown(); }\n      return scrollOnePage(this, true);\n    }\n\n    /**\n     * Scroll up one page.\n     */\n    pageUp() {\n      if (super.pageUp) { super.pageUp(); }\n      return scrollOnePage(this, false);\n    }\n\n    /* Provide a default scrollTarget implementation if none exists. */\n    get [symbols.scrollTarget]() {\n      return super[symbols.scrollTarget] || defaultScrollTarget(this);\n    }\n\n  }\n\n  return KeyboardPagedSelection;\n}\n\n\n// Return the item whose content spans the given y position (relative to the\n// top of the list's scrolling client area), or null if not found.\n//\n// If downward is true, move down the list of items to find the first item\n// found at the given y position; if downward is false, move up the list of\n// items to find the last item at that position.\nfunction getIndexOfItemAtY(element, scrollTarget, y, downward) {\n\n  const items = element.items;\n  const start = downward ? 0 : items.length - 1;\n  const end = downward ? items.length : 0;\n  const step = downward ? 1 : -1;\n\n  const topOfClientArea = scrollTarget.offsetTop + scrollTarget.clientTop;\n\n  // Find the item spanning the indicated y coordinate.\n  let item;\n  let itemIndex = start;\n  let itemTop;\n  let found = false;\n  while (itemIndex !== end) {\n    item = items[itemIndex];\n    itemTop = item.offsetTop - topOfClientArea;\n    const itemBottom = itemTop + item.offsetHeight;\n    if (itemTop <= y && itemBottom >= y) {\n      // Item spans the indicated y coordinate.\n      found = true;\n      break;\n    }\n    itemIndex += step;\n  }\n\n  if (!found) {\n    return null;\n  }\n\n  // We may have found an item whose padding spans the given y coordinate,\n  // but whose content is actually above/below that point.\n  // TODO: If the item has a border, then padding should be included in\n  // considering a hit.\n  const itemStyle = getComputedStyle(item);\n  const itemPaddingTop = parseFloat(itemStyle.paddingTop);\n  const itemPaddingBottom = parseFloat(itemStyle.paddingBottom);\n  const contentTop = itemTop + item.clientTop + itemPaddingTop;\n  const contentBottom = contentTop + item.clientHeight - itemPaddingTop - itemPaddingBottom;\n  if (downward && contentTop <= y || !downward && contentBottom >= y) {\n    // The indicated coordinate hits the actual item content.\n    return itemIndex;\n  }\n  else {\n    // The indicated coordinate falls within the item's padding. Back up to\n    // the item below/above the item we found and return that.\n    return itemIndex - step;\n  }\n}\n\n// Move by one page downward (if downward is true), or upward (if false).\n// Return true if we ended up changing the selection, false if not.\nfunction scrollOnePage(element, downward) {\n\n  // Determine the item visible just at the edge of direction we're heading.\n  // We'll select that item if it's not already selected.\n  const scrollTarget = element[symbols.scrollTarget];\n  const edge = scrollTarget.scrollTop + (downward ? scrollTarget.clientHeight : 0);\n  const indexOfItemAtEdge = getIndexOfItemAtY(element, scrollTarget, edge, downward);\n\n  const selectedIndex = element.selectedIndex;\n  let newIndex;\n  if (indexOfItemAtEdge && selectedIndex === indexOfItemAtEdge) {\n    // The item at the edge was already selected, so scroll in the indicated\n    // direction by one page. Leave the new item at that edge selected.\n    const delta = (downward ? 1 : -1) * scrollTarget.clientHeight;\n    newIndex = getIndexOfItemAtY(element, scrollTarget, edge + delta, downward);\n  }\n  else {\n    // The item at the edge wasn't selected yet. Instead of scrolling, we'll\n    // just select that item. That is, the first attempt to page up/down\n    // usually just moves the selection to the edge in that direction.\n    newIndex = indexOfItemAtEdge;\n  }\n\n  if (!newIndex) {\n    // We can't find an item in the direction we want to travel. Select the\n    // last item (if moving downward) or first item (if moving upward).\n    newIndex = (downward ? element.items.length - 1 : 0);\n  }\n\n  if (newIndex !== selectedIndex) {\n    element.selectedIndex = newIndex;\n    return true; // We handled the page up/down ourselves.\n  }\n  else {\n    return false; // We didn't do anything.\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/KeyboardPagedSelectionMixin.js","/**\n * Return a guess as to what portion of the given element can be scrolled.\n * This can be used to provide a default implementation of\n * [symbols.scrollTarget].\n *\n * If the element has a shadow root containing a default (unnamed) slot, this\n * returns the first ancestor of that slot that is styled with `overflow-y:\n * auto` or `overflow-y: scroll`. If the element has no default slot, or no\n * scrolling ancestor is found, the element itself is returned.\n *\n * @type {HTMLElement}\n */\nexport default function defaultScrollTarget(element) {\n  const slot = element.shadowRoot && element.shadowRoot.querySelector('slot:not([name])');\n  return slot ?\n    getScrollingParent(slot, element) :\n    element;\n}\n\n\n// Return the parent of the given element that can be scroll vertically. If no\n// such element is found, return the given root element.\nfunction getScrollingParent(element, root) {\n  if (element === null || element === root) {\n    // Didn't find a scrolling parent; use the root element instead.\n    return root;\n  }\n  const overflowY = getComputedStyle(element).overflowY;\n  if (overflowY === 'scroll' || overflowY === 'auto') {\n    // Found an element we can scroll vertically.\n    return element;\n  }\n  // Keep looking higher in the hierarchy for a scrolling parent.\n  return getScrollingParent(element.parentNode, root);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/defaultScrollTarget.js","import constants from './constants';\nimport Symbol from './Symbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst itemTextContentsSymbol = Symbol('itemTextContents');\nconst typedPrefixSymbol = Symbol('typedPrefix');\nconst prefixTimeoutSymbol = Symbol('prefixTimeout');\nconst settingSelectionSymbol = Symbol('settingSelection');\n\n\n/**\n * Mixin that handles list box-style prefix typing, in which the user can type\n * a string to select the first item that begins with that string.\n *\n * Example: suppose a component using this mixin has the following items:\n *\n *     <sample-list-component>\n *       <div>Apple</div>\n *       <div>Apricot</div>\n *       <div>Banana</div>\n *       <div>Blackberry</div>\n *       <div>Blueberry</div>\n *       <div>Cantaloupe</div>\n *       <div>Cherry</div>\n *       <div>Lemon</div>\n *       <div>Lime</div>\n *     </sample-list-component>\n *\n * If this component receives the focus, and the user presses the \"b\" or \"B\"\n * key, the \"Banana\" item will be selected, because it's the first item that\n * matches the prefix \"b\". (Matching is case-insensitive.) If the user now\n * presses the \"l\" or \"L\" key quickly, the prefix to match becomes \"bl\", so\n * \"Blackberry\" will be selected.\n *\n * The prefix typing feature has a one second timeout the prefix to match\n * will be reset after a second has passed since the user last typed a key.\n * If, in the above example, the user waits a second between typing \"b\" and\n * \"l\", the prefix will become \"l\", so \"Lemon\" would be selected.\n *\n * This mixin expects the component to invoke a `keydown` method when a key is\n * pressed. You can use [KeyboardMixin](KeyboardMixin.md) for that\n * purpose, or wire up your own keyboard handling and call `keydown` yourself.\n *\n * This mixin also expects the component to provide an `items` property. The\n * `textContent` of those items will be used for purposes of prefix matching.\n *\n * @module KeyboardPrefixSelectionMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function KeyboardPrefixSelectionMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class KeyboardPrefixSelection extends base {\n\n    // Default implementation returns an item's `alt` attribute or its\n    // `textContent`, in that order.\n    [symbols.getItemText](item) {\n      return item.getAttribute('alt') || item.textContent;\n    }\n\n    // If the set of items has changed, reset the prefix. We'll also need to\n    // rebuild our cache of item text the next time we're asked for it.\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n      this[itemTextContentsSymbol] = null;\n      resetTypedPrefix(this);\n    }\n\n    [symbols.keydown](event) {\n      let handled;\n      let resetPrefix = true;\n\n      switch (event.keyCode) {\n        case 8: // Backspace\n          handleBackspace(this);\n          handled = true;\n          resetPrefix = false;\n          break;\n        case 27: // Escape\n          handled = true;\n          break;\n        default:\n          if (!event.ctrlKey && !event.metaKey && !event.altKey &&\n              event.which !== 32 /* Space */) {\n            handlePlainCharacter(this, String.fromCharCode(event.keyCode));\n          }\n          resetPrefix = false;\n      }\n\n      if (resetPrefix) {\n        resetTypedPrefix(this);\n      }\n\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n    }\n\n    get selectedIndex() {\n      return super.selectedIndex;\n    }\n    set selectedIndex(index) {\n      if ('selectedIndex' in base.prototype) { super.selectedIndex = index; }\n      if (!this[settingSelectionSymbol]) {\n        // Someone else (not this mixin) has changed the selection. In response,\n        // we invalidate the prefix under construction.\n        resetTypedPrefix(this);\n      }\n    }\n\n    /**\n     * Select the first item whose text content begins with the given prefix.\n     *\n     * @param prefix [String] The prefix string to search for\n     */\n    selectItemWithTextPrefix(prefix) {\n      if (super.selectItemWithTextPrefix) { super.selectItemWithTextPrefix(prefix); }\n      if (prefix == null || prefix.length === 0) {\n        return;\n      }\n      const index = getIndexOfItemWithTextPrefix(this, prefix);\n      if (index >= 0) {\n        // Update the selection. During that operation, set the flag that lets\n        // us know that we are the cause of the selection change. See note at\n        // this mixin's `selectedIndex` implementation.\n        this[settingSelectionSymbol] = true;\n        this.selectedIndex = index;\n        this[settingSelectionSymbol] = false;\n      }\n    }\n\n  }\n\n  return KeyboardPrefixSelection;\n}\n\n\n// Return the index of the first item with the given prefix, else -1.\nfunction getIndexOfItemWithTextPrefix(element, prefix) {\n  const itemTextContents = getItemTextContents(element);\n  const prefixLength = prefix.length;\n  for (let i = 0; i < itemTextContents.length; i++) {\n    const itemTextContent = itemTextContents[i];\n    if (itemTextContent.substr(0, prefixLength) === prefix) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n// Return an array of the text content (in lowercase) of all items.\n// Cache these results.\nfunction getItemTextContents(element) {\n  if (!element[itemTextContentsSymbol]) {\n    const items = element.items;\n    element[itemTextContentsSymbol] = Array.prototype.map.call(items, item => {\n      const text = element[symbols.getItemText](item);\n      return text.toLowerCase();\n    });\n  }\n  return element[itemTextContentsSymbol];\n}\n\n// Handle the Backspace key: remove the last character from the prefix.\nfunction handleBackspace(element) {\n  const length = element[typedPrefixSymbol] ? element[typedPrefixSymbol].length : 0;\n  if (length > 0) {\n    element[typedPrefixSymbol] = element[typedPrefixSymbol].substr(0, length - 1);\n  }\n  element.selectItemWithTextPrefix(element[typedPrefixSymbol]);\n  setPrefixTimeout(element);\n}\n\n// Add a plain character to the prefix.\nfunction handlePlainCharacter(element, char) {\n  const prefix = element[typedPrefixSymbol] || '';\n  element[typedPrefixSymbol] = prefix + char.toLowerCase();\n  element.selectItemWithTextPrefix(element[typedPrefixSymbol]);\n  setPrefixTimeout(element);\n}\n\n// Stop listening for typing.\nfunction resetPrefixTimeout(element) {\n  if (element[prefixTimeoutSymbol]) {\n    clearTimeout(element[prefixTimeoutSymbol]);\n    element[prefixTimeoutSymbol] = false;\n  }\n}\n\n// Clear the prefix under construction.\nfunction resetTypedPrefix(element) {\n  element[typedPrefixSymbol] = '';\n  resetPrefixTimeout(element);\n}\n\n// Wait for the user to stop typing.\nfunction setPrefixTimeout(element) {\n  resetPrefixTimeout(element);\n  element[prefixTimeoutSymbol] = setTimeout(() => {\n    resetTypedPrefix(element);\n  }, constants.TYPING_TIMEOUT_DURATION);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/KeyboardPrefixSelectionMixin.js","/**\n * A collection of constants used by Elix mixins and components for consistency\n * in things such as user interface timings.\n *\n * @module constants\n */\nconst constants = {\n\n  /**\n   * Time in milliseconds after which the user is considered to have stopped\n   * typing.\n   *\n   * @const {number} TYPING_TIMEOUT_DURATION\n   */\n  TYPING_TIMEOUT_DURATION: 1000\n\n};\n\n\nexport default constants;\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/constants.js","import symbols from './symbols';\n\n\n// Used to assign unique IDs to item elements without IDs.\nlet idCount = 0;\n\n\n/**\n * Mixin which treats the selected item in a list as the active item in ARIA\n * accessibility terms.\n *\n * Handling ARIA selection state properly is actually quite complex:\n *\n * * The items in the list need to be indicated as possible items via an ARIA\n *   `role` attribute value such as \"option\".\n * * The selected item need to be marked as selected by setting the item's\n *   `aria-selected` attribute to true *and* the other items need be marked as\n *   *not* selected by setting `aria-selected` to false.\n * * The outermost element with the keyboard focus needs to have attributes\n *   set on it so that the selection is knowable at the list level via the\n *   `aria-activedescendant` attribute.\n * * Use of `aria-activedescendant` in turn requires that all items in the\n *   list have ID attributes assigned to them.\n *\n * This mixin tries to address all of the above requirements. To that end,\n * this mixin will assign generated IDs to any item that doesn't already have\n * an ID.\n *\n * ARIA relies on elements to provide `role` attributes. This mixin will apply\n * a default role of \"listbox\" on the outer list if it doesn't already have an\n * explicit role. Similarly, this mixin will apply a default role of \"option\"\n * to any list item that does not already have a role specified.\n *\n * This mixin expects a set of members that manage the state of the selection:\n * `[symbols.itemSelected]`, `[symbols.itemAdded]`, and `selectedItem`. You can\n * supply these yourself, or do so via\n * [SingleSelectionMixin](SingleSelectionMixin.md).\n *\n * @module\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function (base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class SelectionAria extends base {\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n\n      // Set default ARIA role for the overall component.\n      if (this.getAttribute('role') == null && this[symbols.defaults].role) {\n        this.setAttribute('role', this[symbols.defaults].role);\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.role = 'listbox';\n      defaults.itemRole = 'option';\n      return defaults;\n    }\n\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n\n      if (!item.getAttribute('role')) {\n        // Assign a default ARIA role for an individual item.\n        item.setAttribute('role', this[symbols.defaults].itemRole);\n      }\n\n      // Ensure each item has an ID so we can set aria-activedescendant on the\n      // overall list whenever the selection changes.\n      //\n      // The ID will take the form of a base ID plus a unique integer. The base\n      // ID will be incorporate the component's own ID. E.g., if a component has\n      // ID \"foo\", then its items will have IDs that look like \"_fooOption1\". If\n      // the compnent has no ID itself, its items will get IDs that look like\n      // \"_option1\". Item IDs are prefixed with an underscore to differentiate\n      // them from manually-assigned IDs, and to minimize the potential for ID\n      // conflicts.\n      if (!item.id) {\n        const baseId = this.id ?\n            \"_\" + this.id + \"Option\" :\n            \"_option\";\n        item.id = baseId + idCount++;\n      }\n    }\n\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n      item.setAttribute('aria-selected', selected);\n      const itemId = item.id;\n      if (itemId && selected) {\n        this.setAttribute('aria-activedescendant', itemId);\n      }\n    }\n\n    get selectedItem() {\n      return super.selectedItem;\n    }\n    set selectedItem(item) {\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n      if (item == null) {\n        // Selection was removed.\n        this.removeAttribute('aria-activedescendant');\n      }\n    }\n\n  }\n\n  return SelectionAria;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/SelectionAriaMixin.js","import defaultScrollTarget from './defaultScrollTarget';\nimport symbols from './symbols';\n\n\n/**\n * Mixin which scrolls a container horizontally and/or vertically to ensure that\n * a newly-selected item is visible to the user.\n *\n * When the selected item in a list-like component changes, the selected item\n * should be brought into view so that the user can confirm their selection.\n *\n * This mixin expects a `selectedItem` property to be set when the selection\n * changes. You can supply that yourself, or use\n * [SingleSelectionMixin](SingleSelectionMixin.md).\n *\n * @module SelectinInViewMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default (base) => {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class SelectionInView extends base {\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      const selectedItem = this.selectedItem;\n      if (selectedItem) {\n        this.scrollItemIntoView(selectedItem);\n      }\n    }\n\n    /**\n     * Scroll the given element completely into view, minimizing the degree of\n     * scrolling performed.\n     *\n     * Blink has a `scrollIntoViewIfNeeded()` function that does something\n     * similar, but unfortunately it's non-standard, and in any event often ends\n     * up scrolling more than is absolutely necessary.\n     *\n     * This scrolls the containing element defined by the `scrollTarget`\n     * property. See that property for a discussion of the default value of\n     * that property.\n     *\n     * @param {HTMLElement} item - the item to scroll into view.\n     */\n    scrollItemIntoView(item) {\n      if (super.scrollItemIntoView) { super.scrollItemIntoView(); }\n\n      const scrollTarget = this[symbols.scrollTarget];\n\n      // Determine the bounds of the scroll target and item. We use\n      // getBoundingClientRect instead of .offsetTop, etc., because the latter\n      // round values, and we want to handle fractional values.\n      const scrollTargetRect = scrollTarget.getBoundingClientRect();\n      const itemRect = item.getBoundingClientRect();\n\n      // Determine how far the item is outside the viewport.\n      const bottomDelta = itemRect.bottom - scrollTargetRect.bottom;\n      const topDelta = itemRect.top - scrollTargetRect.top;\n      const leftDelta = itemRect.left - scrollTargetRect.left;\n      const rightDelta = itemRect.right - scrollTargetRect.right;\n\n      // Scroll the target as necessary to bring the item into view.\n      if (bottomDelta > 0) {\n        scrollTarget.scrollTop += bottomDelta;            // Scroll down\n      } else if (topDelta < 0) {\n        scrollTarget.scrollTop += Math.ceil(topDelta);    // Scroll up\n      }\n      if (rightDelta > 0) {\n        scrollTarget.scrollLeft += rightDelta;            // Scroll right\n      } else if (leftDelta < 0) {\n        scrollTarget.scrollLeft += Math.ceil(leftDelta);  // Scroll left\n      }\n    }\n\n    /* Provide a default scrollTarget implementation if none exists. */\n    get [symbols.scrollTarget]() {\n      return super[symbols.scrollTarget] || defaultScrollTarget(this);\n    }\n\n    get selectedItem() {\n      return super.selectedItem;\n    }\n    set selectedItem(item) {\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n      if (item) {\n        // Keep the selected item in view.\n        this.scrollItemIntoView(item);\n      }\n    }\n  }\n\n  return SelectionInView;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/SelectionInViewMixin.js","import symbols from '../src/symbols';\n\n\n// A cache of processed templates.\n//\n// We maintain this as a map keyed by element tag (localName). We could store\n// an element's processed template on its element prototype. One scenario that\n// wouldn't support would be registration of the same constructor under multiple\n// tag names, which was a (perhaps theoretical) use case for Custom Elements.\n//\nconst mapTagToTemplate = {};\n\n\n/**\n * Mixin which adds stamping a template into a Shadow DOM subtree upon component\n * instantiation.\n *\n * To use this mixin, define a `template` property as a string or HTML\n * `<template>` element:\n *\n *     class MyElement extends ShadowTemplateMixin(HTMLElement) {\n *       get [symbols.template]() {\n *         return `Hello, <em>world</em>.`;\n *       }\n *     }\n *\n * When your component class is instantiated, a shadow root will be created on\n * the instance, and the contents of the template will be cloned into the\n * shadow root. If your component does not define a `template` property, this\n * mixin has no effect.\n *\n * For the time being, this extension retains support for Shadow DOM v0. That\n * will eventually be deprecated as browsers (and the Shadow DOM polyfill)\n * implement Shadow DOM v1.\n *\n * @module ShadowTemplateMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function ShadowTemplateMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class ShadowTemplate extends base {\n\n    /*\n     * If the component defines a template, a shadow root will be created on the\n     * component instance, and the template stamped into it.\n     */\n    constructor() {\n      super();\n\n      const tag = this.localName;\n      let template = mapTagToTemplate[tag];\n\n      // See if we've already processed a template for this tag.\n      if (!template) {\n        // This is the first time we've created an instance of this tag.\n\n        // Get the template and perform initial processing.\n        template = this[symbols.template];\n        if (!template) {\n          console.warn(`ShadowTemplateMixin expects a component to define a property called [symbols.template].`);\n          return;\n        }\n\n        if (typeof template === 'string') {\n          // Upgrade plain string to real template.\n          const templateText = template;\n          template = document.createElement('template');\n          template.innerHTML = templateText;\n        }\n\n        if (window.ShadyCSS) {\n          // Let the CSS polyfill do its own initialization.\n          window.ShadyCSS.prepareTemplate(template, tag);\n        }\n\n        // Store this for the next time we create the same type of element.\n        mapTagToTemplate[tag] = template;\n      }\n\n      // Stamp the template into a new shadow root.\n      const root = this.attachShadow({ mode: 'open' });\n      const clone = document.importNode(template.content, true);\n      root.appendChild(clone);\n\n      /* Let the component know the shadow tree has been populated. */\n      if (this[symbols.shadowCreated]) {\n        this[symbols.shadowCreated]();\n      }\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      if (window.ShadyCSS) {\n        window.ShadyCSS.applyStyle(this);\n      }\n    }\n\n  }\n\n  return ShadowTemplate;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/ShadowTemplateMixin.js","import Symbol from './Symbol';\nimport symbols from './symbols';\n\n\n// Symbols for private data members on an element.\nconst canSelectNextSymbol = Symbol('canSelectNext');\nconst canSelectPreviousSymbol = Symbol('canSelectPrevious');\nconst selectionRequiredSymbol = Symbol('selectionRequired');\nconst selectionWrapsSymbol = Symbol('selectionWraps');\n\n// We want to expose both selectedIndex and selectedItem as independent\n// properties but keep them in sync. This allows a component user to reference\n// the selection by whatever means is most natural for their situation.\n//\n// To efficiently keep these properties in sync, we track \"external\" and\n// \"internal\" references for each property:\n//\n// The external index or item is the one we report to the outside world when\n// asked for selection.  When handling a change to index or item, we update the\n// external reference as soon as possible, so that if anyone immediately asks\n// for the current selection, they will receive a stable answer.\n//\n// The internal index or item tracks whichever index or item last received the\n// full set of processing. Processing includes raising a change event for the\n// new value. Once we've begun that processing, we store the new value as the\n// internal value to indicate we've handled it.\n//\nconst externalSelectedIndexSymbol = Symbol('externalSelectedIndex');\nconst externalSelectedItemSymbol = Symbol('externalSelectedItem');\nconst internalSelectedIndexSymbol = Symbol('internalSelectedIndex');\nconst internalSelectedItemSymbol = Symbol('internalSelectedItem');\n\n\n/**\n * Mixin which adds single-selection semantics for items in a list.\n *\n * This mixin expects a component to provide an `items` Array or NodeList of\n * all elements in the list.\n *\n * This mixin tracks a single selected item in the list, and provides means to\n * get and set that state by item position (`selectedIndex`) or item identity\n * (`selectedItem`). The selection can be moved in the list via the methods\n * `selectFirst`, `selectLast`, `selectNext`, and `selectPrevious`.\n *\n * This mixin does not produce any user-visible effects to represent\n * selection.\n *\n * @module SingleSelectionMixin\n * @param base {Class} the base class to extend\n * @returns {Class} the extended class\n */\nexport default function SingleSelectionMixin(base) {\n\n  /**\n   * The class prototype added by the mixin.\n   */\n  class SingleSelection extends base {\n\n    constructor() {\n      super();\n      // Set defaults.\n      if (typeof this.selectionRequired === 'undefined') {\n        this.selectionRequired = this[symbols.defaults].selectionRequired;\n      }\n      if (typeof this.selectionWraps === 'undefined') {\n        this.selectionWraps = this[symbols.defaults].selectionWraps;\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the next item, false if not (the\n     * selected item is the last item in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectNext() {\n      return this[canSelectNextSymbol];\n    }\n    set canSelectNext(canSelectNext) {\n      const changed = canSelectNext !== this[canSelectNextSymbol];\n      this[canSelectNextSymbol] = canSelectNext;\n      if ('canSelectNext' in base.prototype) { super.canSelectNext = canSelectNext; }\n      if (this[symbols.raiseChangeEvents] && changed) {\n        this.dispatchEvent(new CustomEvent('can-select-next-changed'));\n      }\n    }\n\n    /**\n     * True if the selection can be moved to the previous item, false if not\n     * (the selected item is the first one in the list).\n     *\n     * @type {boolean}\n     */\n    get canSelectPrevious() {\n      return this[canSelectPreviousSymbol];\n    }\n    set canSelectPrevious(canSelectPrevious) {\n      const changed = canSelectPrevious !== this[canSelectPreviousSymbol];\n      this[canSelectPreviousSymbol] = canSelectPrevious;\n      if ('canSelectPrevious' in base.prototype) { super.canSelectPrevious = canSelectPrevious; }\n      if (this[symbols.raiseChangeEvents] && changed) {\n        this.dispatchEvent(new CustomEvent('can-select-previous-changed'));\n      }\n    }\n\n    get [symbols.defaults]() {\n      const defaults = super[symbols.defaults] || {};\n      defaults.selectionRequired = false;\n      defaults.selectionWraps = false;\n      return defaults;\n    }\n\n    /**\n     * Handle a new item being added to the list.\n     *\n     * The default implementation of this method simply sets the item's\n     * selection state to false.\n     *\n     * @param {HTMLElement} item - the item being added\n     */\n    [symbols.itemAdded](item) {\n      if (super[symbols.itemAdded]) { super[symbols.itemAdded](item); }\n      this[symbols.itemSelected](item, item === this.selectedItem);\n    }\n\n    [symbols.itemsChanged]() {\n      if (super[symbols.itemsChanged]) { super[symbols.itemsChanged](); }\n\n      // In case selected item changed position or was removed.\n      trackSelectedItem(this);\n\n      // In case the change in items affected which navigations are possible.\n      updatePossibleNavigations(this);\n    }\n\n    /**\n     * Apply the indicate selection state to the item.\n     *\n     * The default implementation of this method does nothing. User-visible\n     * effects will typically be handled by other mixins.\n     *\n     * @param {HTMLElement} item - the item being selected/deselected\n     * @param {boolean} selected - true if the item is selected, false if not\n     */\n    [symbols.itemSelected](item, selected) {\n      if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    }\n\n    /**\n     * The index of the item which is currently selected.\n     *\n     * The setter expects an integer or a string representing an integer.\n     *\n     * A `selectedIndex` of -1 indicates there is no selection. Setting this\n     * property to -1 will remove any existing selection.\n     *\n     * @type {number}\n     */\n    get selectedIndex() {\n      return this[externalSelectedIndexSymbol] != null ?\n        this[externalSelectedIndexSymbol] :\n        -1;\n    }\n    set selectedIndex(index) {\n      // See notes at top about internal vs. external copies of this property.\n      const changed = index !== this[internalSelectedIndexSymbol];\n      let item;\n      let parsedIndex = parseInt(index);\n      if (parsedIndex !== this[externalSelectedIndexSymbol]) {\n        // Store the new index and the corresponding item.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        if (!(hasItems && parsedIndex >= 0 && parsedIndex < items.length)) {\n          parsedIndex = -1; // No item at that index.\n        }\n        this[externalSelectedIndexSymbol] = parsedIndex;\n        item = hasItems && parsedIndex >= 0 ? items[parsedIndex] : null;\n        this[externalSelectedItemSymbol] = item;\n      } else {\n        item = this[externalSelectedItemSymbol];\n      }\n\n      // Now let super do any work.\n      if ('selectedIndex' in base.prototype) { super.selectedIndex = index; }\n\n      if (changed) {\n        // The selected index changed.\n        this[internalSelectedIndexSymbol] = parsedIndex;\n\n        if (this[symbols.raiseChangeEvents]) {\n          const event = new CustomEvent('selected-index-changed', {\n            detail: {\n              selectedIndex: parsedIndex,\n              value: parsedIndex // for Polymer binding. TODO: Verify still necessary\n            }\n          });\n          this.dispatchEvent(event);\n        }\n      }\n\n      if (this[internalSelectedItemSymbol] !== item) {\n        // Update selectedItem property so it can have its own effects.\n        this.selectedItem = item;\n      }\n    }\n\n    /**\n     * The currently selected item, or null if there is no selection.\n     *\n     * Setting this property to null deselects any currently-selected item.\n     * Setting this property to an object that is not in the list has no effect.\n     *\n     * TODO: Even if selectionRequired, can still explicitly set selectedItem to null.\n     * TODO: If selectionRequired, leave selection alone?\n     *\n     * @type {object}\n     */\n    get selectedItem() {\n      return this[externalSelectedItemSymbol] || null;\n    }\n    set selectedItem(item) {\n      // See notes at top about internal vs. external copies of this property.\n      const previousSelectedItem = this[internalSelectedItemSymbol];\n      const changed = item !== previousSelectedItem;\n      let index;\n      if (item !== this[externalSelectedItemSymbol]) {\n        // Store item and look up corresponding index.\n        const items = this.items;\n        const hasItems = items && items.length > 0;\n        index = hasItems ? Array.prototype.indexOf.call(items, item) : -1;\n        this[externalSelectedIndexSymbol] = index;\n        if (index < 0) {\n          item = null; // The indicated item isn't actually in `items`.\n        }\n        this[externalSelectedItemSymbol] = item;\n      } else {\n        index = this[externalSelectedIndexSymbol];\n      }\n\n      // Now let super do any work.\n      if ('selectedItem' in base.prototype) { super.selectedItem = item; }\n\n      if (changed) {\n        // The selected item changed.\n        this[internalSelectedItemSymbol] = item;\n\n        if (previousSelectedItem) {\n          // Update selection state of old item.\n          this[symbols.itemSelected](previousSelectedItem, false);\n        }\n        if (item) {\n          // Update selection state to new item.\n          this[symbols.itemSelected](item, true);\n        }\n\n        updatePossibleNavigations(this);\n\n        if (this[symbols.raiseChangeEvents]) {\n          const event = new CustomEvent('selected-item-changed', {\n            detail: {\n              selectedItem: item,\n              value: item // for Polymer binding\n            }\n          });\n          this.dispatchEvent(event);\n        }\n      }\n\n      if (this[internalSelectedIndexSymbol] !== index) {\n        // Update selectedIndex property so it can have its own effects.\n        this.selectedIndex = index;\n      }\n    }\n\n    /**\n     * Select the first item in the list.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectFirst() {\n      if (super.selectFirst) { super.selectFirst(); }\n      return selectIndex(this, 0);\n    }\n\n    /**\n     * True if the list should always have a selection (if it has items).\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionRequired() {\n      return this[selectionRequiredSymbol];\n    }\n    set selectionRequired(selectionRequired) {\n      const parsed = String(selectionRequired) === 'true';\n      const changed = parsed !== this[selectionRequiredSymbol];\n      this[selectionRequiredSymbol] = parsed;\n      if ('selectionRequired' in base.prototype) { super.selectionRequired = selectionRequired; }\n      if (changed) {\n        if (this[symbols.raiseChangeEvents]) {\n          const event = new CustomEvent('selection-required-changed');\n          this.dispatchEvent(event);\n        }\n        if (selectionRequired) {\n          trackSelectedItem(this);\n        }\n      }\n    }\n\n    /**\n     * True if selection navigations wrap from last to first, and vice versa.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selectionWraps() {\n      return this[selectionWrapsSymbol];\n    }\n    set selectionWraps(selectionWraps) {\n      const parsed = String(selectionWraps) === 'true';\n      const changed = parsed !== this[selectionWrapsSymbol];\n      this[selectionWrapsSymbol] = parsed;\n      if ('selectionWraps' in base.prototype) { super.selectionWraps = selectionWraps; }\n      if (changed) {\n        if (this[symbols.raiseChangeEvents]) {\n          const event = new CustomEvent('selection-wraps-changed');\n          this.dispatchEvent(event);\n        }\n        updatePossibleNavigations(this);\n      }\n    }\n\n    /**\n     * Select the last item in the list.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectLast() {\n      if (super.selectLast) { super.selectLast(); }\n      return selectIndex(this, this.items.length - 1);\n    }\n\n    /**\n     * Select the next item in the list.\n     *\n     * If the list has no selection, the first item will be selected.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectNext() {\n      if (super.selectNext) { super.selectNext(); }\n      return selectIndex(this, this.selectedIndex + 1);\n    }\n\n    /**\n     * Select the previous item in the list.\n     *\n     * If the list has no selection, the last item will be selected.\n     *\n     * @returns {Boolean} True if the selection changed, false if not.\n     */\n    selectPrevious() {\n      if (super.selectPrevious) { super.selectPrevious(); }\n      const newIndex = this.selectedIndex < 0 ?\n        this.items.length - 1 :     // No selection yet; select last item.\n        this.selectedIndex - 1;\n      return selectIndex(this, newIndex);\n    }\n\n    /**\n     * Fires when the canSelectNext property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event can-select-next-changed\n     */\n\n    /**\n     * Fires when the canSelectPrevious property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event can-select-previous-changed\n     */\n\n    /**\n     * Fires when the selectedIndex property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event selected-index-changed\n     * @param {number} detail.selectedIndex The new selected index.\n     */\n\n    /**\n     * Fires when the selectedItem property changes in response to internal\n     * component activity.\n     *\n     * @memberof SingleSelection\n     * @event selected-item-changed\n     * @param {HTMLElement} detail.selectedItem The new selected item.\n     */\n\n  }\n\n  return SingleSelection;\n}\n\n\n// Ensure the given index is within bounds, and select it if it's not already\n// selected.\nfunction selectIndex(element, index) {\n\n  const items = element.items;\n  if (items == null) {\n    // Nothing to select.\n    return false;\n  }\n\n  const count = items.length;\n  const boundedIndex = element.selectionWraps ?\n    // JavaScript mod doesn't handle negative numbers the way we want to wrap.\n    // See http://stackoverflow.com/a/18618250/76472\n    ((index % count) + count) % count :\n\n    // Keep index within bounds of array.\n    Math.max(Math.min(index, count - 1), 0);\n\n  const previousIndex = element.selectedIndex;\n  if (previousIndex !== boundedIndex) {\n    element.selectedIndex = boundedIndex;\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// Following a change in the set of items, or in the value of the\n// `selectionRequired` property, reacquire the selected item. If it's moved,\n// update `selectedIndex`. If it's been removed, and a selection is required,\n// try to select another item.\nfunction trackSelectedItem(element) {\n\n  const items = element.items;\n  const itemCount = items ? items.length : 0;\n\n  const previousSelectedItem = element.selectedItem;\n  if (!previousSelectedItem) {\n    // No item was previously selected.\n    if (element.selectionRequired) {\n      // Select the first item by default.\n      element.selectedIndex = 0;\n    }\n  } else if (itemCount === 0) {\n    // We've lost the selection, and there's nothing left to select.\n    element.selectedItem = null;\n  } else {\n    // Try to find the previously-selected item in the current set of items.\n    const indexInCurrentItems = Array.prototype.indexOf.call(items, previousSelectedItem);\n    const previousSelectedIndex = element.selectedIndex;\n    if (indexInCurrentItems < 0) {\n      // Previously-selected item was removed from the items.\n      // Select the item at the same index (if it exists) or as close as possible.\n      const newSelectedIndex = Math.min(previousSelectedIndex, itemCount - 1);\n      // Select by item, since index may be the same, and we want to raise the\n      // selected-item-changed event.\n      element.selectedItem = items[newSelectedIndex];\n    } else if (indexInCurrentItems !== previousSelectedIndex) {\n      // Previously-selected item still there, but changed position.\n      element.selectedIndex = indexInCurrentItems;\n    }\n  }\n}\n\n// Following a change in selection, report whether it's now possible to\n// go next/previous from the given index.\nfunction updatePossibleNavigations(element) {\n  let canSelectNext;\n  let canSelectPrevious;\n  const items = element.items;\n  if (items == null || items.length === 0) {\n    // No items to select.\n    canSelectNext = false;\n    canSelectPrevious = false;\n  } else if (element.selectionWraps) {\n    // Since there are items, can always go next/previous.\n    canSelectNext = true;\n    canSelectPrevious = true;\n  } else {\n    const index = element.selectedIndex;\n    if (index < 0 && items.length > 0) {\n      // Special case. If there are items but no selection, declare that it's\n      // always possible to go next/previous to create a selection.\n      canSelectNext = true;\n      canSelectPrevious = true;\n    } else {\n      // Normal case: we have an index in a list that has items.\n      canSelectPrevious = (index > 0);\n      canSelectNext = (index < items.length - 1);\n    }\n  }\n  if (element.canSelectNext !== canSelectNext) {\n    element.canSelectNext = canSelectNext;\n  }\n  if (element.canSelectPrevious !== canSelectPrevious) {\n    element.canSelectPrevious = canSelectPrevious;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./elements/elix-mixins/src/SingleSelectionMixin.js","import SingleSelectionMixin from '../../elix-mixins/src/SingleSelectionMixin';\nimport symbols from '../../elix-mixins/src/symbols';\n\n\n/*\n * A very simple component to show the application of SingleSelectionMixin.\n *\n * For a more complete demo using SingleSelectionMixin, see the ListBox demo.\n */\nexport default class SingleSelectionDemo extends SingleSelectionMixin(HTMLElement) {\n\n  constructor() {\n    super();\n    this.addEventListener('mousedown', event => {\n      this[symbols.raiseChangeEvents] = true;\n      this.selectedItem = event.target;\n      event.stopPropagation();\n      this[symbols.raiseChangeEvents] = false;\n    });\n  }\n\n  attributeChangedCallback(attributeName, oldValue, newValue) {\n    if (super.attributeChangedCallback) { super.attributeChangedCallback(attributeName, oldValue, newValue); }\n    if (attributeName === 'selected-index') {\n      this.selectedIndex = newValue;\n    }\n  }\n\n  // Map item selection to a `selected` CSS class.\n  [symbols.itemSelected](item, selected) {\n    if (super[symbols.itemSelected]) { super[symbols.itemSelected](item, selected); }\n    item.classList.toggle('selected', selected);\n  }\n\n  // Simplistic implementation of items property doesn't handle redistribution.\n  get items() {\n    return this.children;\n  }\n\n  static get observedAttributes() {\n    return ['selected-index'];\n  }\n\n}\n\n\ncustomElements.define('single-selection-demo', SingleSelectionDemo);\n\n\n\n// WEBPACK FOOTER //\n// ./elements/demos/src/SingleSelectionDemo.js"],"sourceRoot":""}